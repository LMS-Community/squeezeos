Index: busybox-1.7.0/networking/ifupdown.c
===================================================================
--- busybox-1.7.0/networking/ifupdown.c	(revision 391)
+++ busybox-1.7.0/networking/ifupdown.c	(revision 427)
@@ -29,7 +29,7 @@
 #define EUNBALPER   10000
 
 #if ENABLE_FEATURE_IFUPDOWN_MAPPING
-#define MAX_INTERFACE_LENGTH 10
+#define MAX_INTERFACE_LENGTH 33
 #endif
 
 #define debug_noise(args...) /*fprintf(stderr, args)*/
@@ -502,7 +502,10 @@
 	if (!execute("ip link set %iface% up", ifd, exec))
 		return 0;
 #endif
-	return execute("udhcpc -R -n -p /var/run/udhcpc.%iface%.pid "
+
+// -R was not in the file patched by Elvis. Check what it does
+	return execute("udhcpc -R -p /var/run/udhcpc.%iface%.pid "
+					"-b --zeroconf [[-s %script%]] "
 			"-i %iface%[[ -H %hostname%]][[ -c %clientid%]][[ -s %script%]]",
 			ifd, exec);
 #else

Index: busybox-1.7.0/networking/udhcp/arpping.c
===================================================================
--- busybox-1.7.0/networking/udhcp/arpping.c	(revision 391)
+++ busybox-1.7.0/networking/udhcp/arpping.c	(revision 427)
@@ -11,28 +11,10 @@
 
 #include "common.h"
 #include "dhcpd.h"
+#include "arpping.h"
 
 
-struct arpMsg {
-	/* Ethernet header */
-	uint8_t  h_dest[6];     /* 00 destination ether addr */
-	uint8_t  h_source[6];   /* 06 source ether addr */
-	uint16_t h_proto;       /* 0c packet type ID field */
 
-	/* ARP packet */
-	uint16_t htype;         /* 0e hardware type (must be ARPHRD_ETHER) */
-	uint16_t ptype;         /* 10 protocol type (must be ETH_P_IP) */
-	uint8_t  hlen;          /* 12 hardware address length (must be 6) */
-	uint8_t  plen;          /* 13 protocol address length (must be 4) */
-	uint16_t operation;     /* 14 ARP opcode */
-	uint8_t  sHaddr[6];     /* 16 sender's hardware address */
-	uint8_t  sInaddr[4];    /* 1c sender's IP address */
-	uint8_t  tHaddr[6];     /* 20 target's hardware address */
-	uint8_t  tInaddr[4];    /* 26 target's IP address */
-	uint8_t  pad[18];       /* 2a pad for min. ethernet payload (60 bytes) */
-} ATTRIBUTE_PACKED;
-
-
 /* Returns 1 if no reply received */
 
 int arpping(uint32_t test_ip, uint32_t from_ip, uint8_t *from_mac, const char *interface)
Index: busybox-1.7.0/networking/udhcp/arpping.h
===================================================================
--- busybox-1.7.0/networking/udhcp/arpping.h	(revision 0)
+++ busybox-1.7.0/networking/udhcp/arpping.h	(revision 427)
@@ -0,0 +1,32 @@
+/*
+ * arpping .h
+ */
+
+#ifndef ARPPING_H
+#define ARPPING_H
+
+#include <netinet/if_ether.h>
+#include <net/if_arp.h>
+#include <net/if.h>
+#include <netinet/in.h>
+
+struct arpMsg {
+	/* Ethernet header */
+	u_char   h_dest[6];			/* destination ether addr */
+	u_char   h_source[6];			/* source ether addr */
+	u_short  h_proto;			/* packet type ID field */
+
+	/* ARP packet */
+	uint16_t htype;				/* hardware type (must be ARPHRD_ETHER) */
+	uint16_t ptype;				/* protocol type (must be ETH_P_IP) */
+	uint8_t  hlen;				/* hardware address length (must be 6) */
+	uint8_t  plen;				/* protocol address length (must be 4) */
+	uint16_t operation;			/* ARP opcode */
+	uint8_t  sHaddr[6];			/* sender's hardware address */
+	uint8_t  sInaddr[4];			/* sender's IP address */
+	uint8_t  tHaddr[6];			/* target's hardware address */
+	uint8_t  tInaddr[4];			/* target's IP address */
+	uint8_t  pad[18];			/* pad for min. Ethernet payload (60 bytes) */
+} ATTRIBUTE_PACKED;
+
+#endif
Index: busybox-1.7.0/networking/udhcp/dhcpc.c
===================================================================
--- busybox-1.7.0/networking/udhcp/dhcpc.c	(revision 391)
+++ busybox-1.7.0/networking/udhcp/dhcpc.c	(revision 427)
@@ -8,6 +8,11 @@
  * Licensed under the GPL v2 or later, see the file LICENSE in this tarball.
  */
 
+/*
+ * 3 Sept 2007 Martin applied the zeroconf patch from:
+ *     http://udhcp.busybox.net/lists/udhcp/2005-May/000124.html
+ */
+
 #include <getopt.h>
 #include <syslog.h>
 
@@ -18,7 +23,11 @@
 #include "dhcpc.h"
 #include "options.h"
 
+#ifdef ENABLE_FEATURE_UDHCP_ZEROCONF
+#include "zeroconf.h"
+#endif
 
+
 /* Something is definitely wrong here. IPv4 addresses
  * in variables of type long?? BTW, we use inet_ntoa()
  * in the code. Manpage says that struct in_addr has a member of type long (!)
@@ -66,6 +75,9 @@
 		break;
 	case RENEW_REQUESTED: /* impatient are we? fine, square 1 */
 		udhcp_run_script(NULL, "deconfig");
+#ifdef ENABLE_FEATURE_UDHCP_ZEROCONF
+		zeroconf_event(ZEROCONF_EVENT_DHCPOUT);
+#endif
 	case REQUESTING:
 	case RELEASED:
 		change_mode(LISTEN_RAW);
@@ -96,6 +108,9 @@
 		temp_addr.s_addr = requested_ip;
 		bb_info_msg("Unicasting a release of %s to %s",
 				inet_ntoa(temp_addr), buffer);
+#ifdef ENABLE_FEATURE_UDHCP_ZEROCONF
+		zeroconf_event(ZEROCONF_EVENT_DHCPOUT);
+#endif
 		send_release(server_addr, requested_ip); /* unicast */
 		udhcp_run_script(NULL, "deconfig");
 	}
@@ -158,6 +173,9 @@
 	struct in_addr temp_addr;
 	struct dhcpMessage packet;
 	fd_set rfds;
+#ifdef ENABLE_FEATURE_UDHCP_ZEROCONF
+	int with_zeroconf = 0;
+#endif
 
 	enum {
 		OPT_c = 1 << 0,
@@ -179,6 +197,7 @@
 		OPT_t = 1 << 16,
 		OPT_v = 1 << 17,
 		OPT_S = 1 << 18,
+		OPT_z = 1 << 19,
 	};
 #if ENABLE_GETOPT_LONG
 	static const char udhcpc_longopts[] ALIGN1 =
@@ -201,6 +220,7 @@
 		"version\0"       No_argument       "v"
 		"retries\0"       Required_argument "t"
 		"syslog\0"        No_argument       "S"
+		"zeroconf\0"      No_argument       "z"
 		;
 #endif
 	/* Default options. */
@@ -215,7 +235,7 @@
 #if ENABLE_GETOPT_LONG
 	applet_long_options = udhcpc_longopts;
 #endif
-	opt = getopt32(argv, "c:CV:fbH:h:F:i:np:qRr:s:T:t:vS",
+	opt = getopt32(argv, "c:CV:fbH:h:F:i:np:qRr:s:T:t:vSz",
 		&str_c, &str_V, &str_h, &str_h, &str_F,
 		&client_config.interface, &client_config.pidfile, &str_r,
 		&client_config.script, &str_T, &str_t
@@ -245,6 +265,12 @@
 		/* client_config.fqdn[OPT_DATA + 2] = 0; - redundant */
 	}
 	// if (opt & OPT_i) client_config.interface = ...
+	if (opt & OPT_z)
+#ifdef ENABLE_FEATURE_UDHCP_ZEROCONF
+		with_zeroconf = 1;
+#else
+		printf("Zeroconf support not included in this build.\n");
+#endif
 	if (opt & OPT_n)
 		client_config.abort_if_no_lease = 1;
 	// if (opt & OPT_p) client_config.pidfile = ...
@@ -285,6 +311,11 @@
 	/* Goes to stdout and possibly syslog */
 	bb_info_msg("%s (v%s) started", applet_name, BB_VER);
 
+#ifdef ENABLE_FEATURE_UDHCP_ZEROCONF
+	zeroconf_init(with_zeroconf, client_config.arp, client_config.interface, 
+		      client_config.ifindex);
+#endif
+
 	/* if not set, and not suppressed, setup the default client ID */
 	if (!client_config.clientid && !(opt & OPT_C)) {
 		client_config.clientid = alloc_dhcp_option(DHCP_CLIENT_ID, "", 7);
@@ -300,25 +331,45 @@
 
 	state = INIT_SELECTING;
 	udhcp_run_script(NULL, "deconfig");
+
+
 	change_mode(LISTEN_RAW);
+
+#ifdef ENABLE_FEATURE_UDHCP_ZEROCONF
+	zeroconf_event(ZEROCONF_EVENT_DHCPOUT);
+#else
 	tv.tv_sec = 0;
 	goto jump_in;
+#endif
 
 	for (;;) {
+
+#ifdef ENABLE_FEATURE_UDHCP_ZEROCONF
+		zeroconf_set_smallest_timeout(&tv, timeout);
+#else
 		tv.tv_sec = timeout - monotonic_sec();
  jump_in:
 		tv.tv_usec = 0;
-
+#endif
 		if (listen_mode != LISTEN_NONE && sockfd < 0) {
 			if (listen_mode == LISTEN_KERNEL)
 				sockfd = listen_socket(/*INADDR_ANY,*/ CLIENT_PORT, client_config.interface);
 			else
 				sockfd = raw_socket(client_config.ifindex);
 		}
+
+#ifdef ENABLE_FEATURE_UDHCP_ZEROCONF
+		if (zeroconf_fd > -1) {
+			max_fd = udhcp_sp_fd_set2(&rfds, sockfd, zeroconf_fd);
+		} else {
+			max_fd = udhcp_sp_fd_set(&rfds, sockfd);
+		}
+#else
 		max_fd = udhcp_sp_fd_set(&rfds, sockfd);
+#endif
 
 		retval = 0; /* If we already timed out, fall through, else... */
-		if (tv.tv_sec > 0) {
+		if (tv.tv_sec > 0 || tv.tv_usec > 0) {
 			DEBUG("Waiting on select...");
 			retval = select(max_fd + 1, &rfds, NULL, NULL, &tv);
 		}
@@ -331,7 +382,20 @@
 				bb_perror_msg_and_die("select");
 			}
 		} else if (retval == 0) {
-			/* timeout dropped to zero */
+			/* timeout, must be forwarded to Zeroconf and DHCP state machines */
+#ifdef ENABLE_FEATURE_UDHCP_ZEROCONF
+			/* Zeroconf has its own timeout tests, just tick it */
+			zeroconf_event(ZEROCONF_EVENT_TICK);
+#endif
+
+			if (timeout > now) {
+				/* it is not DHCP's timeout */
+				continue;
+			}
+
+			DEBUG(LOG_INFO, "DHCP timeout");
+			
+			/* DHCP timeout dropped to zero */
 			switch (state) {
 			case INIT_SELECTING:
 				if (packet_num < client_config.retries) {
@@ -372,6 +436,9 @@
 					/* timed out, go back to init state */
 					if (state == RENEW_REQUESTED)
 						udhcp_run_script(NULL, "deconfig");
+#ifdef ENABLE_FEATURE_UDHCP_ZEROCONF
+					zeroconf_event(ZEROCONF_EVENT_DHCPOUT);
+#endif
 					state = INIT_SELECTING;
 					timeout = now;
 					packet_num = 0;
@@ -405,6 +472,9 @@
 					state = INIT_SELECTING;
 					bb_info_msg("Lease lost, entering init state");
 					udhcp_run_script(NULL, "deconfig");
+#ifdef ENABLE_FEATURE_UDHCP_ZEROCONF
+					zeroconf_event(ZEROCONF_EVENT_DHCPOUT);
+#endif
 					timeout = now;
 					packet_num = 0;
 					change_mode(LISTEN_RAW);
@@ -420,7 +490,18 @@
 				timeout = INT_MAX;
 				break;
 			}
+#ifdef ENABLE_FEATURE_UDHCP_ZEROCONF
+		} else if (retval > 0 && zeroconf_fd > -1 && FD_ISSET(zeroconf_fd, &rfds)) {
+			/* zeroconf packet is ready, process */
+
+			DEBUG(LOG_INFO, "Socket data for Zeroconf");
+
+			zeroconf_event(ZEROCONF_EVENT_SOCKETREADY);
+#endif
 		} else if (listen_mode != LISTEN_NONE && FD_ISSET(sockfd, &rfds)) {
+
+			DEBUG(LOG_INFO, "Socket data for DHCP");
+
 			/* a packet is ready, read it */
 
 			if (listen_mode == LISTEN_KERNEL)
@@ -497,6 +578,9 @@
 					start = now;
 					timeout = start + t1;
 					requested_ip = packet.yiaddr;
+#ifdef ENABLE_FEATURE_UDHCP_ZEROCONF
+					zeroconf_event(ZEROCONF_EVENT_DHCPIN);
+#endif
 					udhcp_run_script(&packet,
 						   ((state == RENEWING || state == REBINDING) ? "renew" : "bound"));
 
@@ -514,8 +598,12 @@
 					/* return to init state */
 					bb_info_msg("Received DHCP NAK");
 					udhcp_run_script(&packet, "nak");
-					if (state != REQUESTING)
+					if (state != REQUESTING) {
 						udhcp_run_script(NULL, "deconfig");
+#ifdef ENABLE_FEATURE_UDHCP_ZEROCONF
+						zeroconf_event(ZEROCONF_EVENT_DHCPOUT);
+#endif
+					}
 					state = INIT_SELECTING;
 					timeout = now;
 					requested_ip = 0;
@@ -535,6 +623,13 @@
 			case SIGUSR2:
 				perform_release();
 				break;
+			case SIGHUP:
+				/* Richard 30 May 2007
+				 * release the interface and exit
+				 */
+				bb_info_msg("Received SIGHUP");
+				udhcp_run_script(NULL, "deconfig");
+				return 0;
 			case SIGTERM:
 				bb_info_msg("Received SIGTERM");
 				if (client_config.release_on_quit)
Index: busybox-1.7.0/networking/udhcp/zeroconf.c
===================================================================
--- busybox-1.7.0/networking/udhcp/zeroconf.c	(revision 0)
+++ busybox-1.7.0/networking/udhcp/zeroconf.c	(revision 427)
@@ -0,0 +1,595 @@
+/* zeroconf.c
+ *
+ * Zeroconf handling
+ * Based on draft-ietf-zeroconf-ipv4-linklocal.txt (July 2004)
+ *
+ * Elvis Pf√ºtzenreuter <elvis@indt.org> May 2005
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/* TODO (future): Excess traffic in DHCP socket (while DHCP lease has not been granted)
+ * TODO: Tests with autoimmune response (two network interfaces in the same net, with/wo 2 udhcpc)
+ * TODO (future): ARP "is-at" in broadcast mode if using link-local address - move to kernel ?
+ */
+
+#include <sys/time.h>
+#include <sys/file.h>
+#include <unistd.h>
+#include <getopt.h>
+#include <stdlib.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <signal.h>
+#include <time.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+#include <errno.h>
+#include <netpacket/packet.h>
+#include <net/ethernet.h>
+
+#include <net/if_arp.h>
+
+#include "common.h"
+#include "arpping.h"
+#include "zeroconf.h"
+
+
+/* Prototypes */
+static void choose_addr(void);
+static void disarm_timeout(void);
+static int is_timeout_disarmed(void);
+static int arp_conflict(void);
+static void arp_probe(void);
+static void arp_announce(struct in_addr *target);
+static void initial_time(void);
+static void probe(void);
+static void active_announce(void);
+static void active_rest(void);
+static int timeout_passed(void);
+static int timeout_exhausted(void);
+static void _disable(void);
+static void disable(void);
+static void disable_permanently(void);
+static void rate_limit(void);
+
+
+/* static variables */
+
+int state;
+int conflicted;
+int conflict_count;
+
+int zeroconf_fd;
+struct timeval timeout;
+int timeout_count;
+char* interface;
+int ifindex;
+
+struct in_addr linklocal_addr;
+uint8_t mac_addr[6];
+uint64_t mac_addr_as_int;
+
+
+/* Inits zeroconf structures and state machine */
+
+void zeroconf_init(int enable, uint8_t arp[], const char* pinterface, int pifindex)
+{
+	int i;
+
+	if (enable) {
+		state = ZEROCONF_SM_DISABLED;
+	} else {
+		state = ZEROCONF_SM_PERMANENTLY_DISABLED;
+	}
+
+	disarm_timeout();
+	linklocal_addr.s_addr = 0;
+	conflicted = 0;
+	zeroconf_fd = -1;
+	mac_addr_as_int = 0;
+	
+	conflict_count = 0;
+	
+	for(i = 0; i < 6; ++i) {
+		mac_addr[i] = arp[i];
+		mac_addr_as_int <<= 8;
+		mac_addr_as_int += arp[i];
+	}
+
+	interface = strdup(pinterface);
+	ifindex = pifindex;
+}
+
+/* generates address in 169.254.0.0/16 range, excluding 169.254.0.0/24 and
+ * 169.254.255.0/24 edge ranges */
+
+static void choose_addr(void)
+{
+	if (conflicted) {
+
+		/* conflicts took place sometime, our MAC-derived address
+		 * is not good enough, try random() for a change */
+
+		linklocal_addr.s_addr = (169 << 24) + 
+				(254 << 16) +
+				256 + (random() % (65536 - 256 - 256));
+
+		DEBUG("zeroconf: previous address conflicted, trying random this time");
+
+	} else {
+		/* calculate IP address based on MAC so it will be the same
+		 * every time the machine is turned on */
+		
+		linklocal_addr.s_addr = (169 << 24) + 
+				(254 << 16) +
+				256 + ((mac_addr_as_int + 13371361) % (65536 - 256 - 256));
+	}
+
+	linklocal_addr.s_addr = htonl(linklocal_addr.s_addr);
+	
+	DEBUG("zeroconf: address selected is %s", inet_ntoa(linklocal_addr));
+}
+
+/* Helper function to set TIMEVAL structure to smallest timeout
+ * between DHCP and zeroconf (NOTE: other_timeout is UNIX time seconds since 1970) */
+
+void zeroconf_set_smallest_timeout(struct timeval* tv, long int other_timeout)
+{
+	struct timeval now;
+	gettimeofday(&now, NULL);
+
+	if (other_timeout <= 0) {
+		*tv = now;
+	} else if (is_timeout_disarmed()) {
+		tv->tv_sec = other_timeout;
+		tv->tv_usec = 0;
+	} else if (other_timeout <= timeout.tv_sec) {
+		tv->tv_sec = other_timeout;
+		tv->tv_usec = 0;
+	} else {
+		*tv = timeout;
+	}
+
+	/* we want differential timeout for select(), so we subtract time */
+	tv->tv_sec -= now.tv_sec;
+	tv->tv_usec -= now.tv_usec;
+
+	while (tv->tv_usec < 0) {
+		tv->tv_usec += 1000000;
+		tv->tv_sec -= 1;
+	}
+
+	if (tv->tv_sec < 0) {
+		/* glup */
+		tv->tv_sec = tv->tv_usec = 0;
+	}
+
+// DEBUG("zeroconf_set_smallest_timeout: o=%d, z=%d:%d, tv set to %d:%d, now is %d:%d", 
+//			other_timeout, timeout.tv_sec, timeout.tv_usec,
+// 			tv->tv_sec, tv->tv_usec, now.tv_sec, now.tv_usec);
+}
+
+/* Sets timeout to a moment in absolute time */
+
+static void set_timeout(long int usecs, int times)
+{
+	struct timeval now;
+	gettimeofday(&now, NULL);
+
+	timeout.tv_sec = now.tv_sec + (usecs / 1000000);
+	timeout.tv_usec = now.tv_usec + (usecs % 1000000);
+
+	if (timeout.tv_usec >= 1000000) {
+		timeout.tv_usec -= 1000000;
+		timeout.tv_sec += 1;
+	}
+
+	/* If "times" is zero, timeout_count is not touched, it is used by some
+	 * machine states that can receive several timeout events without going
+	 * to another state (e.g. probe). */
+
+	if (times > 0) {
+		timeout_count = times;
+	}
+
+	DEBUG("zeroconf timeout set to %d:%d, now is %d:%d",	timeout.tv_sec,
+							 		timeout.tv_usec,
+									now.tv_sec,
+									now.tv_usec);
+}
+
+/* Disarms timeout bomb :) */
+
+static void disarm_timeout(void)
+{
+	timeout.tv_sec = timeout.tv_usec = 0;
+}
+
+/* Timeout test functions */
+
+static int is_timeout_disarmed(void)
+{
+	return timeout.tv_sec == 0 && timeout.tv_usec == 0;
+}
+
+/* Tests if timeout moment has passed (i.e. timeout is done) */
+
+static int timeout_passed(void)
+{
+	struct timeval now;
+	gettimeofday(&now, NULL);
+
+	if (timeout.tv_sec == 0 && timeout.tv_usec == 0) {
+		/* timeout disarmed */
+		return 0;
+	}
+
+	return ((now.tv_sec > timeout.tv_sec) ||
+	    (now.tv_sec == timeout.tv_sec && 
+	     now.tv_usec >= timeout.tv_usec));
+}
+
+static int timeout_exhausted(void)
+{
+	return timeout_count <= 0;
+}
+
+/* Does the low-level disabling task, it is used by many functions */
+
+static void _disable(void)
+{
+	close(zeroconf_fd);
+	zeroconf_fd = -1;
+	disarm_timeout();
+}
+
+/* State machine transition: disables zeroconf (probably because DHCP got an address) */
+
+static void disable(void)
+{
+	DEBUG("zeroconf: state is Disabled.");
+	_disable();
+	state = ZEROCONF_SM_DISABLED;
+}
+
+static void disable_permanently(void)
+{
+	DEBUG("zeroconf: state is Disabled permanently.");
+	_disable();
+	state = ZEROCONF_SM_DISABLED_PERMANENTLY;
+}
+
+/* Sends ARP probe to see if our chosen IP address has another owner */
+
+static void arp_probe(void)
+{
+	struct arpMsg arpbuffer;
+	struct sockaddr iface;
+
+	memset(&arpbuffer, 0, sizeof(arpbuffer));
+	memcpy(arpbuffer.h_dest, MAC_BCAST_ADDR, 6);		/* MAC DA */
+	memcpy(arpbuffer.h_source, mac_addr, 6);	/* MAC SA */
+	arpbuffer.h_proto = htons(ETH_P_ARP);			/* protocol type (Ethernet) */
+	arpbuffer.htype = htons(ARPHRD_ETHER);			/* hardware type */
+	arpbuffer.ptype = htons(ETH_P_IP);			/* protocol type (ARP message) */
+	arpbuffer.hlen = 6;					/* hardware address length */
+	arpbuffer.plen = 4;					/* protocol address length */
+	arpbuffer.operation = htons(ARPOP_REQUEST);		/* ARP op code */
+	// arpbuffer.sInaddr = 0;				/* source IP address */
+	memcpy(arpbuffer.sHaddr, mac_addr, 6);		/* source hardware address */
+	memcpy(arpbuffer.tInaddr, &linklocal_addr, sizeof(linklocal_addr));	/* target IP address */
+
+	memset(&iface, 0, sizeof(iface));
+	strcpy(iface.sa_data, interface);
+
+	DEBUG("zeroconf: Sending ARP probe.");
+
+	if (sendto(zeroconf_fd, &arpbuffer, sizeof(arpbuffer), 0, &iface, sizeof(iface)) < 0) {
+
+		/* serious error, disable zeroconf completely */
+
+		perror("zeroconf: packet socket error in sendto(), disabling zeroconf.");
+
+		disable_permanently();
+	}
+}
+
+/* Announces the link-local address as broadcasted ARP "is-at" packets. */
+
+static void arp_announce(struct in_addr *target)
+{
+	struct arpMsg arpbuffer;
+	struct sockaddr iface;
+
+	memset(&arpbuffer, 0, sizeof(arpbuffer));
+	memcpy(arpbuffer.h_dest, MAC_BCAST_ADDR, 6);		/* MAC DA */
+	memcpy(arpbuffer.h_source, mac_addr, 6);		/* MAC SA */
+	arpbuffer.h_proto = htons(ETH_P_ARP);			/* protocol type (Ethernet) */
+	arpbuffer.htype = htons(ARPHRD_ETHER);			/* hardware type */
+	arpbuffer.ptype = htons(ETH_P_IP);			/* protocol type (ARP message) */
+	arpbuffer.hlen = 6;					/* hardware address length */
+	arpbuffer.plen = 4;					/* protocol address length */
+	arpbuffer.operation = htons(ARPOP_REPLY);		/* ARP op code */
+	memcpy(arpbuffer.sInaddr, &linklocal_addr, sizeof(linklocal_addr));	/* source IP address */
+	memcpy(arpbuffer.sHaddr, mac_addr, 6);			/* source hardware address */
+	memcpy(arpbuffer.tInaddr, target, sizeof(struct in_addr));		/* target IP address */
+
+	memset(&iface, 0, sizeof(iface));
+	strcpy(iface.sa_data, interface);
+
+	DEBUG("zeroconf: Sending ARP announcement.");
+
+	if (sendto(zeroconf_fd, &arpbuffer, sizeof(arpbuffer), 0, &iface, sizeof(iface)) < 0) {
+
+		/* serious error, disable zeroconf completely */
+
+		perror("zeroconf: packet socket error in sendto(), disabling zeroconf.");
+
+		disable_permanently();
+	}
+}
+
+/* State machine transition: enables zeroconf (probably because DHCP didn't get a
+ * better IP address yet */
+
+static void initial_time(void)
+{
+	struct ifreq iface;
+	int optval = 1;
+
+	if (zeroconf_fd >= 0) {
+		close(zeroconf_fd);
+	}
+
+	zeroconf_fd = socket(PF_PACKET, SOCK_PACKET, htons(ETH_P_ARP));
+
+	if (zeroconf_fd < 0) {
+		perror("zeroconf: link socket creation error, disabling zeroconf.");
+		disable_permanently();
+		return;
+	}
+
+	if (setsockopt(zeroconf_fd, SOL_SOCKET, SO_BROADCAST, &optval, sizeof(optval)) == -1) {
+		perror("zeroconf: Could not setsocketopt(BROADCAST) link socket");
+		disable_permanently();
+		return;
+	}
+
+	strncpy(iface.ifr_ifrn.ifrn_name, interface, IFNAMSIZ);
+	if (setsockopt(zeroconf_fd, SOL_SOCKET, SO_BINDTODEVICE, (char*) &iface, sizeof(iface)) < 0) {
+		perror("zeroconf: Could not setsocketopt(BINDTODEVICE) link socket");
+		disable_permanently();
+		return;
+	}
+
+	choose_addr();
+	state = ZEROCONF_SM_INITIALTIME;
+
+	/* Timeout is one-shot */
+	set_timeout(ZEROCONF_PROBE_WAIT_MINIMUM + 
+			  random() % (ZEROCONF_PROBE_WAIT_MAXIMUM - ZEROCONF_PROBE_WAIT_MINIMUM),
+			  1);
+}
+
+/* State machine transition: after initial time, probe to see if the chosen link-local
+ * address does not have an owner */
+
+static void probe(void)
+{
+	if (state != ZEROCONF_SM_PROBE) {
+		DEBUG("zeroconf: Changed state to PROBE");
+		state = ZEROCONF_SM_PROBE;
+
+		/* Timeout will fire for ZEROCONF_PROBE_NUM times */
+
+		set_timeout(ZEROCONF_PROBE_MIN + 
+					random() % (ZEROCONF_PROBE_MAX - ZEROCONF_PROBE_MIN),
+				     ZEROCONF_PROBE_NUM);
+		arp_probe();
+
+	} else if (! timeout_exhausted()) {
+
+		/* Timeout count not exausthed, probe again */
+		
+		DEBUG("zeroconf: PROBE state maintained, probing again");
+
+		set_timeout(ZEROCONF_PROBE_MIN + 
+					random() % (ZEROCONF_PROBE_MAX - ZEROCONF_PROBE_MIN),
+				     0);
+		arp_probe();
+	} else {
+		DEBUG("zeroconf: PROBE complete, going to active/ann state");
+		active_announce();
+	}
+	
+}
+
+/* State machine transition: link-local address is ours, hooray! */
+
+static void active_announce(void)
+{
+	if (state != ZEROCONF_SM_ACTIVE_ANNOUNCE) {
+		struct dhcpMessage fake;
+
+		DEBUG("zeroconf: state is Active/Announce, Link-local address %s",
+				inet_ntoa(linklocal_addr));
+
+		bzero(&fake, sizeof(fake));
+		fake.yiaddr = linklocal_addr.s_addr;
+		
+		udhcp_run_script(&fake, "zeroconf");
+
+		state = ZEROCONF_SM_ACTIVE_ANNOUNCE;
+		
+		/* Timeout will shoot ZEROCONF_ANNOUNCE_NUM times */
+		set_timeout(ZEROCONF_ANNOUNCE_WAIT, ZEROCONF_ANNOUNCE_NUM);
+		arp_announce(&linklocal_addr);
+
+	} else if (! timeout_exhausted()) {
+		DEBUG("zeroconf: Announcing again link-local address");
+		set_timeout(ZEROCONF_ANNOUNCE_INTERVAL, 0);
+		arp_announce(&linklocal_addr);
+
+	} else {
+		active_rest();
+	}
+}
+
+/* Machine state: active and no more announcements due. Rest in peace */
+
+static void active_rest(void)
+{
+	DEBUG("zeroconf: State is Active/rest");
+	state = ZEROCONF_SM_ACTIVE_REST;
+	conflict_count = 0;
+	disarm_timeout();
+}
+
+/* Machine state: too many conflicts in link-local negotiation, sleep for a while */
+
+static void rate_limit(void)
+{
+	DEBUG("zeroconf: State is Rate limit");
+
+	_disable();
+	state = ZEROCONF_SM_RATE_LIMIT;
+	linklocal_addr.s_addr = 0;
+
+	/* One-shot timeout */
+	set_timeout(ZEROCONF_RATE_LIMIT_INTERVAL, 1);
+}
+
+/* Reads link-layer socket about ARP packets, and detects conflicts */
+
+static int arp_conflict(void)
+{
+	struct arpMsg arpbuffer;
+	
+	if (zeroconf_fd < 0) {
+		DEBUG("zeroconf: arp_conflict(): hey, socket is closed, do not call me!");
+		return 0;
+	}
+	
+	if (recv(zeroconf_fd, &arpbuffer, sizeof(arpbuffer), 0) < 0) {
+
+		/* socket error, we disable zeroconf completely */
+
+		perror("zeroconf: link socket read error, disabling zeroconf.");
+
+		if (state == ZEROCONF_SM_ACTIVE_ANNOUNCE || state == ZEROCONF_SM_ACTIVE_REST) {
+			udhcp_run_script(NULL, "deconfig");
+		}
+		disable_permanently();
+		return 0;
+	}
+
+	if (arpbuffer.operation == htons(ARPOP_REPLY) && 
+	    bcmp(arpbuffer.sHaddr, mac_addr, 6) != 0 &&
+	    *((uint32_t *) arpbuffer.sInaddr) == linklocal_addr.s_addr) {
+
+		/* if the packet is ARPOP_REPLY, and the source MAC address is not ours,
+		 * and the source IP address *is* ours, there is a conflict. */
+		
+		DEBUG("zeroconf: conflict: %02x:%02x:%02x:%02x:%02x:%02x claims "
+			      "to have same IP as ours.", arpbuffer.sHaddr[0], arpbuffer.sHaddr[1], 
+			      arpbuffer.sHaddr[2], arpbuffer.sHaddr[3], arpbuffer.sHaddr[4],
+			      arpbuffer.sHaddr[5]);
+		return 1;
+	}
+	
+	if (arpbuffer.operation == htons(ARPOP_REQUEST) && 
+	    bcmp(arpbuffer.sHaddr, mac_addr, 6) != 0 &&
+	    *((uint32_t *) arpbuffer.tInaddr) == linklocal_addr.s_addr) {
+
+		/* if the packet is ARPOP_REQUEST, and the source MAC address is not ours,
+		 * and the target IP addres *is* ours, send ARP reply as broadcast
+		 * (ok, it will duplicate kernel response, a kernel patch for Zeroconf
+		 * would be a better solution) */
+		
+		DEBUG("zeroconf: ARP request for our address, answering in broadcast.");
+		arp_announce((struct in_addr*) &arpbuffer.sInaddr);
+	}
+	
+	/* No conflict detected */
+
+	return 0;
+}
+
+/* main state machine controller */
+
+void zeroconf_event(int event)
+{
+	if (state == ZEROCONF_SM_PERMANENTLY_DISABLED) {
+		DEBUG("zeroconf: event: we are permanently disabled, ignoring.");
+		return;
+
+	} else if (event == ZEROCONF_EVENT_DHCPIN) {
+		/* DHCP offers a better address, cut off zeroconf */
+		DEBUG("zeroconf: Going to disabled state.");
+		disable();
+
+	} else if (event == ZEROCONF_EVENT_DHCPOUT) {
+		if (state == ZEROCONF_SM_DISABLED) {
+			/* If zeroconf is off but not permanently off, turn it on */
+			DEBUG("zeroconf: Going to 'initial time' state.");
+			initial_time();
+		}
+
+	} else if (event == ZEROCONF_EVENT_SOCKETREADY) {
+		if (arp_conflict() &&
+		    state != ZEROCONF_SM_DISABLED && state != ZEROCONF_SM_DISABLED_PERMANENTLY) {
+			DEBUG("zeroconf: Conflict detected and we are not disabled.");
+			conflicted = 1;
+			++conflict_count;
+			if (conflict_count > ZEROCONF_MAX_COLLISIONS) {
+				DEBUG("zeroconf: Too many conflicts, rate limiting!");
+				rate_limit();
+			} else {
+				DEBUG("zeroconf: Back to square one.");
+				initial_time();
+			}
+		}
+	}
+
+	/* We grab every opportunity to test if timeout has elapsed */
+
+	if (timeout_passed()) {
+		DEBUG("zeroconf: a timeout has passed");
+
+		disarm_timeout();
+		--timeout_count;
+
+		if (state == ZEROCONF_SM_INITIALTIME) {
+			DEBUG("zeroconf: initial time T/O, going to probe");
+			probe();
+
+		} else if (state == ZEROCONF_SM_PROBE) {
+			DEBUG("zeroconf: probe T/O, probing again");
+			probe();
+
+		} else if (state == ZEROCONF_SM_ACTIVE_ANNOUNCE) {
+			DEBUG("zeroconf: announce T/O, announcing again");
+			active_announce();
+
+		} else if (state == ZEROCONF_SM_RATE_LIMIT) {
+			DEBUG("zeroconf: rate limit T/O, going to initial time");
+			initial_time();
+		}
+	}
+}
+
Index: busybox-1.7.0/networking/udhcp/Kbuild
===================================================================
--- busybox-1.7.0/networking/udhcp/Kbuild	(revision 391)
+++ busybox-1.7.0/networking/udhcp/Kbuild	(revision 427)
@@ -17,3 +17,4 @@
 lib-$(CONFIG_APP_DUMPLEASES)    += dumpleases.o
 lib-$(CONFIG_APP_DHCPRELAY)     += dhcprelay.o
 lib-$(CONFIG_FEATURE_RFC3397)   += domain_codec.o
+lib-$(CONFIG_FEATURE_UDHCP_ZEROCONF)   += zeroconf.o
\ No newline at end of file
Index: busybox-1.7.0/networking/udhcp/Config.in
===================================================================
--- busybox-1.7.0/networking/udhcp/Config.in	(revision 391)
+++ busybox-1.7.0/networking/udhcp/Config.in	(revision 427)
@@ -65,6 +65,14 @@
 
 	  See http://udhcp.busybox.net for further details.
 
+config FEATURE_UDHCP_ZEROCONF
+	bool "Compile udhcp with zeroconf"
+	default y
+	depends on APP_UDHCPC
+	help
+	  If selected, udhcpd will include zeroconf support directly in DHCP
+	  client.
+
 config FEATURE_RFC3397
 	bool "Support for RFC3397 domain search (experimental)"
 	default n
Index: busybox-1.7.0/networking/udhcp/zeroconf.h
===================================================================
--- busybox-1.7.0/networking/udhcp/zeroconf.h	(revision 0)
+++ busybox-1.7.0/networking/udhcp/zeroconf.h	(revision 427)
@@ -0,0 +1,44 @@
+/* dhcpc.h */
+#ifndef _ZEROCONF_H
+#define _ZEROCONF_H
+
+#include <sys/time.h>
+
+#define ZEROCONF_SM_PERMANENTLY_DISABLED -1
+#define ZEROCONF_SM_DISABLED_PERMANENTLY ZEROCONF_SM_PERMANENTLY_DISABLED
+#define ZEROCONF_SM_DISABLED 0
+#define ZEROCONF_SM_INITIALTIME 1
+#define ZEROCONF_SM_PROBE 2
+#define ZEROCONF_SM_ACTIVE_ANNOUNCE 4
+#define ZEROCONF_SM_ACTIVE_REST 5
+#define ZEROCONF_SM_ACTIVE_DEFENDING 6
+#define ZEROCONF_SM_RATE_LIMIT 7
+
+#define ZEROCONF_EVENT_TICK 1
+#define ZEROCONF_EVENT_DHCPIN 2
+#define ZEROCONF_EVENT_DHCPOUT 3
+#define ZEROCONF_EVENT_START ZEROCONF_EVENT_DHCP_OUT
+#define ZEROCONF_EVENT_SOCKETREADY 4
+
+extern int zeroconf_fd;
+
+void zeroconf_init(int enable, uint8_t arp[], const char* interface, int ifindex);
+void zeroconf_event(int event);
+void zeroconf_set_smallest_timeout(struct timeval* tm, long int other_timeout);
+
+/* Zeroconf constants, time constants in microseconds */
+
+#define ZEROCONF_PROBE_WAIT_MINIMUM	 500*1000
+#define ZEROCONF_PROBE_WAIT_MAXIMUM	1000*1000
+#define ZEROCONF_PROBE_MIN 		 200*1000
+#define ZEROCONF_PROBE_MAX		 400*1000
+#define ZEROCONF_PROBE_NUM		3
+#define ZEROCONF_ANNOUNCE_WAIT		1000*1000
+#define ZEROCONF_ANNOUNCE_NUM		2
+#define ZEROCONF_ANNOUNCE_INTERVAL	2000*1000
+#define ZEROCONF_MAX_COLLISIONS		10
+#define ZEROCONF_RATE_LIMIT_INTERVAL	60*1000*1000
+#define ZEROCONF_DEFEND_INTERVAL	10*1000*1000
+
+#endif
+
Index: busybox-1.7.0/networking/udhcp/options.c
===================================================================
--- busybox-1.7.0/networking/udhcp/options.c	(revision 391)
+++ busybox-1.7.0/networking/udhcp/options.c	(revision 427)
@@ -80,7 +80,8 @@
 	length = 308;
 	while (!done) {
 		if (i >= length) {
-			bb_error_msg("bogus packet, option fields too long");
+			if (length > 0)
+				bb_error_msg("bogus packet, option fields too long");
 			return NULL;
 		}
 		if (optionptr[i + OPT_CODE] == code) {
Index: busybox-1.7.0/networking/udhcp/signalpipe.c
===================================================================
--- busybox-1.7.0/networking/udhcp/signalpipe.c	(revision 391)
+++ busybox-1.7.0/networking/udhcp/signalpipe.c	(revision 427)
@@ -45,6 +45,7 @@
 	signal(SIGUSR1, signal_handler);
 	signal(SIGUSR2, signal_handler);
 	signal(SIGTERM, signal_handler);
+	signal(SIGHUP, signal_handler);
 }
 
 
@@ -62,7 +63,14 @@
 	return signal_pipe[0] > extra_fd ? signal_pipe[0] : extra_fd;
 }
 
+int udhcp_sp_fd_set2(fd_set *rfds, int extra_fd, int extra_fd2)
+{
+	int max_fd = udhcp_sp_fd_set(rfds, extra_fd);
+	if (extra_fd2 >= 0) FD_SET(extra_fd2, rfds);
+	return (max_fd > extra_fd2 ? max_fd : extra_fd2);
+}
 
+
 /* Read a signal from the signal pipe. Returns 0 if there is
  * no signal, -1 on error (and sets errno appropriately), and
  * your signal on success */
Index: busybox-1.7.0/networking/udhcp/common.h
===================================================================
--- busybox-1.7.0/networking/udhcp/common.h	(revision 391)
+++ busybox-1.7.0/networking/udhcp/common.h	(revision 427)
@@ -80,6 +80,7 @@
 
 void udhcp_sp_setup(void);
 int udhcp_sp_fd_set(fd_set *rfds, int extra_fd);
+int udhcp_sp_fd_set2(fd_set *rfds, int extra_fd, int extra_fd2);
 int udhcp_sp_read(fd_set *rfds);
 int raw_socket(int ifindex);
 int read_interface(const char *interface, int *ifindex, uint32_t *addr, uint8_t *arp);

