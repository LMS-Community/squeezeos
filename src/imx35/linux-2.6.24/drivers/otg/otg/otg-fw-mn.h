/*
 * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
 */

/*
 * The code contained herein is licensed under the GNU General Public
 * License. You may obtain a copy of the GNU General Public License
 * Version 2 or later at the following locations:
 *
 * http://www.opensource.org/licenses/gpl-license.html
 * http://www.gnu.org/copyleft/gpl.html
 */

/* Generated by otg-states-h.awk
 *
 * Do not Edit thie file
 */

/* %Z %K */

/*!
* @file otg/otg/otg-fw-mn.h
* @brief OTG Firmware - Firmware for mn
*
* This file defines the OTG State Machine tests.
*
* @ingroup OTGFW
*/


/*!
* @page OTGFW
* @section OTGFW_SECTION - otg-fw-mn.h
* This contains the input, output and timout definitions for the OTG state machine firmware
*/
extern char     otg_fw_name_mn[];
extern int      otg_test_max_mn;
extern struct otg_test otg_tests_mn[];

 /*
  * Copyright (c) 2005-2007 Belcarra Technologies 2005 Corp
  */
 /*!
  * This is the initialization set for pcd, hcd and tcd.
  */
 /*!
  * @name Meta State - otg_init
  * @{
  */

#define invalid_state                   0        /*  Un-initialized state. */
 /*
  * This the initial state of the software when first loaded.
  * It is not possible to return to this state.
  */

#define otg_disabled                    1        /*  State Machine ready but disabled. */
 /*
  * The USBOTG State Machine has been initialized but is inactive.
  * This state may have arrived at from either the invalid_state or
  * from the otg_disable state.
  */

#define otg_disable_tcd                 2        /*  State Machine waiting for driver de-initialization. */
 /*
  * The State Machine stops the device drivers and waits for them
  * to signal that they have finished de-initializing.
  */

#define otg_disable_hcd                 3        /*  State Machine waiting for driver de-initialization. */
 /*
  * The State Machine stops the device drivers and waits for them
  * to signal that they have finished de-initializing.
  */

#define otg_disable_pcd                 4        /*  State Machine waiting for driver de-initialization. */
 /*
  * The State Machine stops the device drivers and waits for them
  * to signal that they have finished de-initializing.
  */

#define otg_disable_ocd                 5        /*  State Machine waiting for driver de-initialization. */
 /*
  * The State Machine stops the device drivers and waits for them
  * to signal that they have finished de-initializing.
  */

#define otg_enable_ocd                  6        /*  State Machine waiting for driver initialization. */
 /*
  * The State Machine starts the device drivers and waits for them
  * to signal that they have finished initializing.
  */

#define otg_enable_pcd                  7        /*  State Machine waiting for driver initialization. */
 /*
  * The State Machine starts the device drivers and waits for them
  * to signal that they have finished initializing.
  */

#define otg_enable_hcd                  8        /*  State Machine waiting for driver initialization. */
 /*
  * The State Machine starts the device drivers and waits for them
  * to signal that they have finished initializing.
  */

#define otg_enable_tcd                  9        /*  State Machine waiting for driver initialization. */
 /*
  * The State Machine starts the device drivers and waits for them
  * to signal that they have finished initializing.
  */
 /* @} */
 /*
  * Copyright (c) 2005-2007 Belcarra Technologies 2005 Corp
  *
  */
 /*!
  * This is the minimal firmware. It can be included in the
  * compiled modules and supports the auto Traditional USB
  * mode. No user inputs are required for normal operation.
  *
  * The b_bus_drop input can be optionally used to disconnect and re-connect.
  *
  * The enable_otg input can be optionally used to disable and re-enable.
  * Note that disable/enable will reset b_bus_drop.
  *
  *
  * B-Device Input Signals
  *
  * ID_GND/
  * B_SESS_VLD
  *
  *
  *
  * A-Device Input Signals
  *
  * ID_GND
  * DM_HIGH
  * VBUS_VLD
  * HUB_PORT_CONNECT
  * BUS_RESET
  * ADDRESSED
  * CONFIGURED
  * A_SESS_VLD/
  *
  *
  *
  */
 /*!
  * @name Meta State - otg_init
  * @{
  */

#define otg_enabled                    10        /*  State machine has been initialized. */
 /*!
  * The State Machine has successfully started the device drivers and
  * is waiting for an input event. Typically it will move from here to
  * an idle state specific to the current conditions (peripheral_idle etc.)
  * based on user request b_bus_drop.
  *
  */
 /* @} */
 /*!
  * @name Meta State - b_idle
  * @{
  */

#define peripheral_idle                11        /*  Idle */
 /*!
  * USB Peripheral is idle.
  * Waiting for Vbus to indicate that it has been plugged into a USB Host.
  *
  */

#define peripheral_dropped             12        /*  Dropped */
 /*!
  * USB Peripheral, user has dropped the bus.
  */
 /* @} */
 /*!
  * @name Meta State - b_peripheral
  * @{
  */

#define peripheral_wait                13        /*  Signal a connection and wait for packet traffic. */
 /*!
  * USB Peripheral, Vbus sensed, enabling pullup.
  * The D+ pullup is enabled and we are waiting for a BUS_RESET to
  * indicate that the USB Host has recognized that a USB Device is attached.
  */

#define peripheral_bus_reset           14        /*  The bus has been reset. */
 /*!
  * USB Peripheral, waiting to be addressed.
  * It is waiting to be enumerated and configured by the USB Host.
  */

#define peripheral_addressed           15        /*  The device has been addressed. */
 /*!
  * The State Machine in the configured state for a Traditional USB Device.
  * This means that there is an active session, there is packet traffic
  * with this device.
  */

#define peripheral_configured          16        /*  The device has been configured. */
 /*!
  * The State Machine in the configured state for a Traditional USB Device.
  * This means that there is an active session, there is packet traffic
  * with this device.
  */

#define peripheral_discharge_vbus      17        /*  Discharging Vbus */
 /*!
  * The State Machine in the discharge state for a Traditional USB Device.
  * The device has been unplugged. The Vbus discharge resistor will be enabled
  * for the TLDISC_DSCHRG time period.
  */
 /* @} */
 /*!
  * @name Meta State - b_suspended
  * @{
  */

#define peripheral_suspended           18        /*  The bus has been suspended */
 /*!
  * The State Machine in the suspend state for a Traditional USB Device.
  */

#define peripheral_wakeup_enabled      19        /*  Suspended with REMOTE WAKEUP enabled. */
 /*!
  * The State Machine in the suspend state for a Traditional USB Device,
  * prior to suspended the USB Host enabled Remote Wakeup by sending a
  * set REMOTE WAKUP request.
  */

#define peripheral_wakeup              20        /*  Perform REMOTE WAKEUP procedure. */
 /*!
  * The State Machine in the wakeup state for a Traditional USB Device,
  * The REMOTE WAKEUP procedure will be performed.
  */
 /* @} */

#define host_idle                      21        /*  A-device idle. */
 /*!
  * A-Device idle state. An A-Plug is inserted in the Mini A-B Receptacle.
  * This is the Host Only idle state. Waiting for user to allow
  * the bus to be used.
  *
  * N.B. Reset all progress indicator inputs here.
  */

#define host_idle_dropped              22        /*  A-device idle. */
 /*!
  * A-Device idle state. An A-Plug is inserted in the Mini A-B Receptacle.
  * This is the Host Only idle state. Waiting for user to allow
  * the bus to be used.
  *
  * N.B. Reset all progress indicator inputs here.
  */

#define host_wait_vrise                23        /*  Check if charge pump should be enabled. */
 /*!
  * First check if external charge pump is required.
  *
  * XXX We force a wait of Ta_wait_vrise here, arriving in host wait
  * port connect to quickly causes system hangs occasionally.
  */

#define host_wait_vrise_overcurrent    24        /*  Overcurrent error. */
 /*!
  * A-Device Overcurrent condition (taking too long for Vbus to become valid.)
  *
  */

#define host_wait_port_connect         25        /*  Wait for a B-device connect. */
 /*!
  * Wait for a connection.
  *
  * A-Device wait for B-Device Connect. This is the normal route using the
  * long debounce window.
  *
  * This state can optionally use the Ta_wait_bcon timeout (OTG mode) or
  * wait forever (traditional USB Host mode.)
  *
  * XXX Arriving in this state to quickly from wait vrise can cause a system hang.
  */

#define host_port_connected            26        /*  Reset the bus */
 /*!
  * A-Device host, the host controller driver has noticed a port status change,
  * reset the bus and proceed.
  */

#define host_bus_reset                 27        /*  Address the device. */
 /*!
  * A-Device host, the bus has been reset, attempt to address the device.
  */

#define host_addressed                 28        /*  Enumerate the device. */
 /*!
  * A-Device host, the device has been addressed, attempt to enumerate,
  * find the appropriate class driver and configure.
  */

#define host_configured                29        /*  The device is configured. */
 /*!
  * A-Device host, the enumerated device is supported, and has been configured.
  *
  * XXX N.B. Currently assuming HNP enable feature is automatically performed.
  * XXX N.B. Currently forcing HNP_CAPABLE and HNP_ENABLED.
  */
 /*!
  * @name Meta State - a_vbus_err
  * @{
  */

#define host_vbus_err                  30        /*  Vbus error. */
 /*!
  * A-Device Vbus error.
  * The user must be informed and allowed to clear the problem.
  */
 /* @} */
 /*!
  * @name Meta State - host_wait_vfall
  * @{
  */

#define host_wait_dischrg              31        /*  Wait for Vbus to fall. */
 /*!
  */

#define host_wait_vfall                32        /*  Wait for Vbus to fall. */
 /*!
  * A-Device wait for Vbus to fall.
  *
  * XXX Currently reseting a_bus_req on entry, require explicit a_bus_req to proceed.
  */

#define terminator_state               33        /*  terminator */
 /*!
  * This is not an OTG State. It is used internally to mark the end of the
  * list of states and inputs.
  */

#define OTG_STATES_MN     34

/* @} */

extern struct otg_state otg_states_mn[OTG_STATES_MN + 1];

extern char    *otg_get_state_name_mn(int);

extern struct otg_firmware otg_firmware_mn;
