/*
 * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
 */

/*
 * The code contained herein is licensed under the GNU General Public
 * License. You may obtain a copy of the GNU General Public License
 * Version 2 or later at the following locations:
 *
 * http://www.opensource.org/licenses/gpl-license.html
 * http://www.gnu.org/copyleft/gpl.html
 */

/* Generated by otg-tests-c.awk
 *
 * Do not Edit, see otg-state.awk
 */

/* %Z %K */


/*!
* @file otg/otgcore/otg-fw-mn.c
* @brief OTG Firmware - Firmware for mn
*
* This file defines the OTG State Machine tests.
*
*
* @ingroup OTGFW
*/

/*!
* @page OTGFW
* @section OTGFW_SECTION - otg-fw-mn.c
* This contains the input, output and timout definitions for the OTG state machine firmware
*/


#ifdef OTG_APPLICATION
#define NULL 0
#include "otg-fw.h"
#include "otg-fw-mn.h"
#else   /* OTG_APPLICATION/ */
#include <otg/otg-compat.h>
#include <otg/usbp-chap9.h>
#include <otg/usbp-func.h>
#include <otg/usbp-bus.h>
#include <otg/otg-trace.h>
//#include <otg/otg-api.h>
#include <otg/otg-fw.h>
#include <otg/otg-fw-mn.h>
#endif  /* OTG_APPLICATION */

char            otg_fw_name_mn[] = "otg_mn";


struct otg_test otg_tests_mn[] = {
        /*
         * Copyright (c) 2005-2007 Belcarra Technologies 2005 Corp
         */
        /*!
         * This is the initialization set for pcd, hcd and tcd.
         */
        /*
         * This the initial state of the software when first loaded.
         * It is not possible to return to this state.
         */
        {                                        /*   Initialize by sending the otg_enable signal. */
         0,                                      /* .test */
         invalid_state,                          /* .state */
         otg_disabled,                           /* .target */
         enable_otg,                             /* .test1 */
         },
        /*
         * The USBOTG State Machine has been initialized but is inactive.
         * This state may have arrived at from either the invalid_state or
         * from the otg_disable state.
         */
        {                                        /*   Initialize by sending the otg_enable signal. */
         1,                                      /* .test */
         otg_disabled,                           /* .state */
         otg_enable_ocd,                         /* .target */
         enable_otg,                             /* .test1 */
         },
        /*
         * The State Machine stops the device drivers and waits for them
         * to signal that they have finished de-initializing.
         */
        {                                        /*   Wait for ok from de-initializing drivers. */
         2,                                      /* .test */
         otg_disable_tcd,                        /* .state */
         otg_disable_hcd,                        /* .target */
         TCD_OK,                                 /* .test1 */
         },
        /*
         * The State Machine stops the device drivers and waits for them
         * to signal that they have finished de-initializing.
         */
        {                                        /*   Wait for ok from de-initializing drivers. */
         3,                                      /* .test */
         otg_disable_hcd,                        /* .state */
         otg_disable_pcd,                        /* .target */
         HCD_OK,                                 /* .test1 */
         },
        /*
         * The State Machine stops the device drivers and waits for them
         * to signal that they have finished de-initializing.
         */
        {                                        /*   Wait for ok from de-initializing drivers. */
         4,                                      /* .test */
         otg_disable_pcd,                        /* .state */
         otg_disable_ocd,                        /* .target */
         PCD_OK,                                 /* .test1 */
         },
        /*
         * The State Machine stops the device drivers and waits for them
         * to signal that they have finished de-initializing.
         */
        {                                        /*   Wait for ok from de-initializing drivers. */
         5,                                      /* .test */
         otg_disable_ocd,                        /* .state */
         otg_disabled,                           /* .target */
         OCD_OK,                                 /* .test1 */
         },
        /*
         * The State Machine starts the device drivers and waits for them
         * to signal that they have finished initializing.
         */
        {                                        /*   Wait for ok from initializing drivers. */
         6,                                      /* .test */
         otg_enable_ocd,                         /* .state */
         otg_enable_pcd,                         /* .target */
         OCD_OK,                                 /* .test1 */
         },
        /*
         * The State Machine starts the device drivers and waits for them
         * to signal that they have finished initializing.
         */
        {                                        /*   Wait for ok from initializing drivers. */
         7,                                      /* .test */
         otg_enable_pcd,                         /* .state */
         otg_enable_hcd,                         /* .target */
         PCD_OK,                                 /* .test1 */
         },
        /*
         * The State Machine starts the device drivers and waits for them
         * to signal that they have finished initializing.
         */
        {                                        /*   Wait for ok from initializing drivers. */
         8,                                      /* .test */
         otg_enable_hcd,                         /* .state */
         otg_enable_tcd,                         /* .target */
         HCD_OK,                                 /* .test1 */
         },
        /*
         * The State Machine starts the device drivers and waits for them
         * to signal that they have finished initializing.
         */
        {                                        /*   Wait for ok from initializing drivers. */
         9,                                      /* .test */
         otg_enable_tcd,                         /* .state */
         otg_enabled,                            /* .target */
         TCD_OK,                                 /* .test1 */
         },
        /*
         * Copyright (c) 2005-2007 Belcarra Technologies 2005 Corp
         *
         */
        /*!
         * This is the minimal firmware. It can be included in the
         * compiled modules and supports the auto Traditional USB
         * mode. No user inputs are required for normal operation.
         *
         * The b_bus_drop input can be optionally used to disconnect and re-connect.
         *
         * The enable_otg input can be optionally used to disable and re-enable.
         * Note that disable/enable will reset b_bus_drop.
         *
         *
         * B-Device Input Signals
         *
         * ID_GND/
         * B_SESS_VLD
         *
         *
         *
         * A-Device Input Signals
         *
         * ID_GND
         * DM_HIGH
         * VBUS_VLD
         * HUB_PORT_CONNECT
         * BUS_RESET
         * ADDRESSED
         * CONFIGURED
         * A_SESS_VLD/
         *
         *
         *
         */
        /*!
         * The State Machine has successfully started the device drivers and
         * is waiting for an input event. Typically it will move from here to
         * an idle state specific to the current conditions (peripheral_idle etc.)
         * based on user request b_bus_drop.
         *
         */
        {                                        /*   Check for disable. */
         10,                                     /* .test */
         otg_enabled,                            /* .state */
         otg_disable_tcd,                        /* .target */
         enable_otg_,                            /* .test1 */
         Tst_one_second,                         /* .test2 */
         },
        {                                        /*   Move to idle. */
         11,                                     /* .test */
         otg_enabled,                            /* .state */
         peripheral_idle,                        /* .target */
         ID_GND_,                                /* .test1 */
         enable_otg,                             /* .test2 */
         },
        {                                        /*   */
         12,                                     /* .test */
         otg_enabled,                            /* .state */
         host_idle,                              /* .target */
         ID_GND,                                 /* .test1 */
         enable_otg,                             /* .test2 */
         },
        /*!
         * USB Peripheral is idle.
         * Waiting for Vbus to indicate that it has been plugged into a USB Host.
         *
         */
        {                                        /*   Check for disable (must be done for check for bus_drop.) */
         13,                                     /* .test */
         peripheral_idle,                        /* .state */
         otg_enabled,                            /* .target */
         ID_GND | enable_otg_,                   /* .test1 */
         },
        {                                        /*   Check for b_bus_drop */
         14,                                     /* .test */
         peripheral_idle,                        /* .state */
         peripheral_dropped,                     /* .target */
         b_bus_drop,                             /* .test1 */
         },
        {                                        /*   Move to peripheral mode when SESSION valid. */
         15,                                     /* .test */
         peripheral_idle,                        /* .state */
         peripheral_wait,                        /* .target */
         B_SESS_VLD,                             /* .test1 */
         },
        /*!
         * USB Peripheral, user has dropped the bus.
         */
        {                                        /*   Wait for b_bus_drop/ or enable_otg/ */
         16,                                     /* .test */
         peripheral_dropped,                     /* .state */
         peripheral_idle,                        /* .target */
         ID_GND | b_bus_drop_ | enable_otg_,     /* .test1 */
         },
        /*!
         * USB Peripheral, Vbus sensed, enabling pullup.
         * The D+ pullup is enabled and we are waiting for a BUS_RESET to
         * indicate that the USB Host has recognized that a USB Device is attached.
         */
        {                                        /*   Move to idle if we loose any of these inputs. */
         17,                                     /* .test */
         peripheral_wait,                        /* .state */
         peripheral_idle,                        /* .target */
         ID_GND | enable_otg_ | B_SESS_VLD_ | b_bus_drop,       /* .test1 */
         },
        {                                        /*   Move to next state if bus reset is seen. */
         18,                                     /* .test */
         peripheral_wait,                        /* .state */
         peripheral_bus_reset,                   /* .target */
         BUS_RESET,                              /* .test1 */
         },
        /*!
         * USB Peripheral, waiting to be addressed.
         * It is waiting to be enumerated and configured by the USB Host.
         */
        {                                        /*   Move to idle via discharge, if we loose any of these inputs. */
         19,                                     /* .test */
         peripheral_bus_reset,                   /* .state */
         peripheral_discharge_vbus,              /* .target */
         ID_GND | enable_otg_ | B_SESS_VLD_ | b_bus_drop,       /* .test1 */
         },
        {                                        /*   Progress if we are addressed. */
         20,                                     /* .test */
         peripheral_bus_reset,                   /* .state */
         peripheral_addressed,                   /* .target */
         ADDRESSED,                              /* .test1 */
         },
        /*!
         * The State Machine in the configured state for a Traditional USB Device.
         * This means that there is an active session, there is packet traffic
         * with this device.
         */
        {                                        /*   Move to idle via discharge, if we loose any of these inputs. */
         21,                                     /* .test */
         peripheral_addressed,                   /* .state */
         peripheral_discharge_vbus,              /* .target */
         ID_GND | enable_otg_ | B_SESS_VLD_ | b_bus_drop,       /* .test1 */
         },
        {                                        /*   Progress if we are configured. */
         22,                                     /* .test */
         peripheral_addressed,                   /* .state */
         peripheral_configured,                  /* .target */
         CONFIGURED,                             /* .test1 */
         },
        /*!
         * The State Machine in the configured state for a Traditional USB Device.
         * This means that there is an active session, there is packet traffic
         * with this device.
         */
        {                                        /*   */
         23,                                     /* .test */
         peripheral_configured,                  /* .state */
         peripheral_suspended,                   /* .target */
         BUS_SUSPENDED,                          /* .test1 */
         },
        {                                        /*   Move to idle via discharge, if we loose any of these inputs. */
         24,                                     /* .test */
         peripheral_configured,                  /* .state */
         peripheral_discharge_vbus,              /* .target */
         ID_GND | enable_otg_ | B_SESS_VLD_ | b_bus_drop,       /* .test1 */
         },
        /*!
         * The State Machine in the discharge state for a Traditional USB Device.
         * The device has been unplugged. The Vbus discharge resistor will be enabled
         * for the TLDISC_DSCHRG time period.
         */
        {                                        /*   Progress to idle on timeout. */
         25,                                     /* .test */
         peripheral_discharge_vbus,              /* .state */
         peripheral_idle,                        /* .target */
         Tldisc_dschrg,                          /* .test1 */
         },
        /*!
         * The State Machine in the suspend state for a Traditional USB Device.
         */
        {                                        /*   Move to idle via discharge, if we loose any of these inputs. */
         26,                                     /* .test */
         peripheral_suspended,                   /* .state */
         peripheral_discharge_vbus,              /* .target */
         ID_GND | enable_otg_ | B_SESS_VLD_ | b_bus_drop,       /* .test1 */
         },
        {                                        /*   Check for a resumed bus. */
         27,                                     /* .test */
         peripheral_suspended,                   /* .state */
         peripheral_configured,                  /* .target */
         BUS_SUSPENDED_,                         /* .test1 */
         },
        {                                        /*   Is remote wakeup enabled? */
         28,                                     /* .test */
         peripheral_suspended,                   /* .state */
         peripheral_wakeup_enabled,              /* .target */
         REMOTE_WAKEUP_ENABLED,                  /* .test1 */
         },
        /*!
         * The State Machine in the suspend state for a Traditional USB Device,
         * prior to suspended the USB Host enabled Remote Wakeup by sending a
         * set REMOTE WAKUP request.
         */
        {                                        /*   Move to idle via discharge, if we loose any of these inputs. */
         29,                                     /* .test */
         peripheral_wakeup_enabled,              /* .state */
         peripheral_discharge_vbus,              /* .target */
         enable_otg_ | B_SESS_VLD_,              /* .test1 */
         },
        {                                        /*   Check for a resumed bus. */
         30,                                     /* .test */
         peripheral_wakeup_enabled,              /* .state */
         peripheral_suspended,                   /* .target */
         BUS_SUSPENDED_,                         /* .test1 */
         },
        {                                        /*   Remote wakeup requested? */
         31,                                     /* .test */
         peripheral_wakeup_enabled,              /* .state */
         peripheral_wakeup,                      /* .target */
         remote_wakeup_cmd,                      /* .test1 */
         },
        /*!
         * The State Machine in the wakeup state for a Traditional USB Device,
         * The REMOTE WAKEUP procedure will be performed.
         */
        {                                        /*   Automatic return. */
         32,                                     /* .test */
         peripheral_wakeup,                      /* .state */
         peripheral_wakeup_enabled,              /* .target */
         AUTO | AUTO_,                           /* .test1 */
         },
        /*!
         * A-Device idle state. An A-Plug is inserted in the Mini A-B Receptacle.
         * This is the Host Only idle state. Waiting for user to allow
         * the bus to be used.
         *
         * N.B. Reset all progress indicator inputs here.
         */
        {                                        /*   */
         33,                                     /* .test */
         host_idle,                              /* .state */
         host_idle_dropped,                      /* .target */
         a_bus_drop,                             /* .test1 */
         },
        {                                        /*   Check for ID change or disable (this must be before b_bus_drop test.) */
         34,                                     /* .test */
         host_idle,                              /* .state */
         otg_enabled,                            /* .target */
         ID_GND_ | enable_otg_,                  /* .test1 */
         },
        {                                        /*   is this correct? */
         35,                                     /* .test */
         host_idle,                              /* .state */
         host_wait_vrise,                        /* .target */
         AUTO | AUTO_,                           /* .test1 */
         },
        /*!
         * A-Device idle state. An A-Plug is inserted in the Mini A-B Receptacle.
         * This is the Host Only idle state. Waiting for user to allow
         * the bus to be used.
         *
         * N.B. Reset all progress indicator inputs here.
         */
        {                                        /*   */
         36,                                     /* .test */
         host_idle_dropped,                      /* .state */
         host_idle,                              /* .target */
         a_bus_drop_ | ID_GND_ | enable_otg_,    /* .test1 */
         },
        /*!
         * First check if external charge pump is required.
         *
         * XXX We force a wait of Ta_wait_vrise here, arriving in host wait
         * port connect to quickly causes system hangs occasionally.
         */
        {                                        /*   */
         37,                                     /* .test */
         host_wait_vrise,                        /* .state */
         host_idle,                              /* .target */
         ID_GND_ | enable_otg_ | a_bus_drop,     /* .test1 */
         },
        {                                        /*   */
         38,                                     /* .test */
         host_wait_vrise,                        /* .state */
         host_wait_port_connect,                 /* .target */
         VBUS_VLD,                               /* .test1 */
         Ta_wait_vrise,                          /* .test2 */
         },
        {                                        /*   */
         39,                                     /* .test */
         host_wait_vrise,                        /* .state */
         host_wait_vrise_overcurrent,            /* .target */
         Ta_wait_vrise,                          /* .test1 */
         },
        /*!
         * A-Device Overcurrent condition (taking too long for Vbus to become valid.)
         *
         */
        {                                        /*   */
         40,                                     /* .test */
         host_wait_vrise_overcurrent,            /* .state */
         host_wait_port_connect,                 /* .target */
         Tst_one_second,                         /* .test1 */
         },
        /*!
         * Wait for a connection.
         *
         * A-Device wait for B-Device Connect. This is the normal route using the
         * long debounce window.
         *
         * This state can optionally use the Ta_wait_bcon timeout (OTG mode) or
         * wait forever (traditional USB Host mode.)
         *
         * XXX Arriving in this state to quickly from wait vrise can cause a system hang.
         */
        {                                        /*   Vbus error? */
         41,                                     /* .test */
         host_wait_port_connect,                 /* .state */
         host_vbus_err,                          /* .target */
         VBUS_VLD_,                              /* .test1 */
         },
        {                                        /*   */
         42,                                     /* .test */
         host_wait_port_connect,                 /* .state */
         host_wait_dischrg,                      /* .target */
         ID_GND_ | enable_otg_ | a_bus_drop,     /* .test1 */
         },
        {                                        /*   */
         43,                                     /* .test */
         host_wait_port_connect,                 /* .state */
         host_port_connected,                    /* .target */
         HUB_PORT_CONNECT,                       /* .test1 */
         },
        /*!
         * A-Device host, the host controller driver has noticed a port status change,
         * reset the bus and proceed.
         */
        {                                        /*   */
         44,                                     /* .test */
         host_port_connected,                    /* .state */
         host_wait_dischrg,                      /* .target */
         ID_GND_ | enable_otg_ | a_bus_drop | HUB_PORT_CONNECT_ | Tst_two_second,       /* .test1 */
         },
        {                                        /*   */
         45,                                     /* .test */
         host_port_connected,                    /* .state */
         host_bus_reset,                         /* .target */
         BUS_RESET,                              /* .test1 */
         },
        {                                        /*   */
         46,                                     /* .test */
         host_port_connected,                    /* .state */
         host_addressed,                         /* .target */
         ADDRESSED,                              /* .test1 */
         },
        /*!
         * A-Device host, the bus has been reset, attempt to address the device.
         */
        {                                        /*   */
         47,                                     /* .test */
         host_bus_reset,                         /* .state */
         host_wait_dischrg,                      /* .target */
         ID_GND_ | enable_otg_ | a_bus_drop,     /* .test1 */
         },
        {                                        /*   */
         48,                                     /* .test */
         host_bus_reset,                         /* .state */
         host_addressed,                         /* .target */
         ADDRESSED,                              /* .test1 */
         },
        /*!
         * A-Device host, the device has been addressed, attempt to enumerate,
         * find the appropriate class driver and configure.
         */
        {                                        /*   Lost B-Connect or user changed his mind? */
         49,                                     /* .test */
         host_addressed,                         /* .state */
         host_wait_dischrg,                      /* .target */
         ID_GND_ | enable_otg_ | a_bus_drop | HUB_PORT_CONNECT_,        /* .test1 */
         },
        {                                        /*   Device configured, class driver loaded. */
         50,                                     /* .test */
         host_addressed,                         /* .state */
         host_configured,                        /* .target */
         CONFIGURED,                             /* .test1 */
         },
        /*!
         * A-Device host, the enumerated device is supported, and has been configured.
         *
         * XXX N.B. Currently assuming HNP enable feature is automatically performed.
         * XXX N.B. Currently forcing HNP_CAPABLE and HNP_ENABLED.
         */
        {                                        /*   Vbus error? */
         51,                                     /* .test */
         host_configured,                        /* .state */
         host_vbus_err,                          /* .target */
         VBUS_VLD_,                              /* .test1 */
         },
        {                                        /*   */
         52,                                     /* .test */
         host_configured,                        /* .state */
         host_wait_dischrg,                      /* .target */
         HUB_PORT_CONNECT_,                      /* .test1 */
         },
        {                                        /*   */
         53,                                     /* .test */
         host_configured,                        /* .state */
         host_wait_dischrg,                      /* .target */
         ID_GND_ | enable_otg_ | a_bus_drop,     /* .test1 */
         },
        /*!
         * A-Device Vbus error.
         * The user must be informed and allowed to clear the problem.
         */
        {                                        /*   */
         54,                                     /* .test */
         host_vbus_err,                          /* .state */
         host_wait_dischrg,                      /* .target */
         ID_GND_ | clr_err_cmd | a_bus_drop,     /* .test1 */
         },
        /*!
         */
        {                                        /*   Normal finish, wait for a_sess_vld/ */
         55,                                     /* .test */
         host_wait_dischrg,                      /* .state */
         host_wait_vfall,                        /* .target */
         AUTO | AUTO_,                           /* .test1 */
         },
        /*!
         * A-Device wait for Vbus to fall.
         *
         * XXX Currently reseting a_bus_req on entry, require explicit a_bus_req to proceed.
         */
        {                                        /*   Normal finish, wait for a_sess_vld/ */
         56,                                     /* .test */
         host_wait_vfall,                        /* .state */
         host_idle,                              /* .target */
         A_SESS_VLD_ | Tst_one_second,           /* .test1 */
         },
        /*!
         * This is not an OTG State. It is used internally to mark the end of the
         * list of states and inputs.
         */
        {                                        /*   */
         57,                                     /* .test */
         terminator_state,                       /* .state */
         invalid_state,                          /* .target */
         0,                                      /* .test1 */
         },
        {58, invalid_state,},

};

#define OTG_TESTS_MN 58

int             otg_test_max_mn = 58;

 /* eof */

/* Generated by otg-info-c.awk
 *
 * Do not Edit, see otg-state.awk
 */

/* %Z %K */

struct otg_state otg_states_mn[OTG_STATES_MN + 1] = {
        {                                        /* 0 */
         invalid_state,                          /* .state */
         m_otg_init,                             /* .meta */
         "invalid_state",                        /* .name */
         0,                                      /* .tmout */
         0,                                      /* .reset */
         },
        {                                        /* 1 */
         otg_disabled,                           /* .state */
         m_otg_init,                             /* .meta */
         "otg_disabled",                         /* .name */
         0,                                      /* .tmout */
         enable_otg_ | PCD_OK_ | TCD_OK_ | HCD_OK_,     /* .reset */
         /* .outputs */
         chrg_vbus_out_ | drv_vbus_out_ | charge_pump_out_ | dm_pullup_out_ | dp_pullup_out_ | loc_sof_out_ |
         hcd_rh_out_,
         },
        {                                        /* 2 */
         otg_disable_tcd,                        /* .state */
         m_otg_init,                             /* .meta */
         "otg_disable_tcd",                      /* .name */
         0,                                      /* .tmout */
         TCD_OK_,                                /* .reset */
         /* .outputs */
         tcd_init_out_,
         },
        {                                        /* 3 */
         otg_disable_hcd,                        /* .state */
         m_otg_init,                             /* .meta */
         "otg_disable_hcd",                      /* .name */
         0,                                      /* .tmout */
         HCD_OK_,                                /* .reset */
         /* .outputs */
         hcd_init_out_,
         },
        {                                        /* 4 */
         otg_disable_pcd,                        /* .state */
         m_otg_init,                             /* .meta */
         "otg_disable_pcd",                      /* .name */
         0,                                      /* .tmout */
         PCD_OK_,                                /* .reset */
         /* .outputs */
         pcd_init_out_,
         },
        {                                        /* 5 */
         otg_disable_ocd,                        /* .state */
         m_otg_init,                             /* .meta */
         "otg_disable_ocd",                      /* .name */
         0,                                      /* .tmout */
         OCD_OK_,                                /* .reset */
         /* .outputs */
         ocd_init_out_,
         },
        {                                        /* 6 */
         otg_enable_ocd,                         /* .state */
         m_otg_init,                             /* .meta */
         "otg_enable_ocd",                       /* .name */
         0,                                      /* .tmout */
         OCD_OK_,                                /* .reset */
         /* .outputs */
         ocd_init_out,
         },
        {                                        /* 7 */
         otg_enable_pcd,                         /* .state */
         m_otg_init,                             /* .meta */
         "otg_enable_pcd",                       /* .name */
         0,                                      /* .tmout */
         PCD_OK_,                                /* .reset */
         /* .outputs */
         pcd_init_out,
         },
        {                                        /* 8 */
         otg_enable_hcd,                         /* .state */
         m_otg_init,                             /* .meta */
         "otg_enable_hcd",                       /* .name */
         0,                                      /* .tmout */
         HCD_OK_,                                /* .reset */
         /* .outputs */
         hcd_init_out,
         },
        {                                        /* 9 */
         otg_enable_tcd,                         /* .state */
         m_otg_init,                             /* .meta */
         "otg_enable_tcd",                       /* .name */
         0,                                      /* .tmout */
         TCD_OK_,                                /* .reset */
         /* .outputs */
         tcd_init_out,
         },
        {                                        /* 10 */
         otg_enabled,                            /* .state */
         m_otg_init,                             /* .meta */
         "otg_enabled",                          /* .name */
         TST_ONE_SECOND,                         /* .tmout */
         b_bus_drop_,                            /* .reset */
         /* .outputs */
         dm_det_out_ | dp_det_out_,
         },
        {                                        /* 11 */
         peripheral_idle,                        /* .state */
         m_b_idle,                               /* .meta */
         "peripheral_idle",                      /* .name */
         0,                                      /* .tmout */
         0,                                      /* .reset */
         /* .outputs */
         dp_pullup_out_ | hcd_rh_out | pcd_en_out_ | tcd_en_out_power | dischrg_vbus_out_ | dp_pulldown_out |
         dm_pulldown_out | hcd_en_out_,
         },
        {                                        /* 12 */
         peripheral_dropped,                     /* .state */
         m_b_idle,                               /* .meta */
         "peripheral_dropped",                   /* .name */
         0,                                      /* .tmout */
         0,                                      /* .reset */
         },
        {                                        /* 13 */
         peripheral_wait,                        /* .state */
         m_b_peripheral,                         /* .meta */
         "peripheral_wait",                      /* .name */
         0,                                      /* .tmout */
         BUS_RESET_,                             /* .reset */
         /* .outputs */
         dp_pullup_out | pcd_en_out | dp_pulldown_out_ | dm_pulldown_out_ | hcd_en_out_,
         },
        {                                        /* 14 */
         peripheral_bus_reset,                   /* .state */
         m_b_peripheral,                         /* .meta */
         "peripheral_bus_reset",                 /* .name */
         0,                                      /* .tmout */
         BUS_RESET_ | ADDRESSED_,                /* .reset */
         },
        {                                        /* 15 */
         peripheral_addressed,                   /* .state */
         m_b_peripheral,                         /* .meta */
         "peripheral_addressed",                 /* .name */
         0,                                      /* .tmout */
         ADDRESSED_ | CONFIGURED_ | REMOTE_WAKEUP_ENABLED_,     /* .reset */
         },
        {                                        /* 16 */
         peripheral_configured,                  /* .state */
         m_b_peripheral,                         /* .meta */
         "peripheral_configured",                /* .name */
         0,                                      /* .tmout */
         CONFIGURED_ | BUS_SUSPENDED_,           /* .reset */
         },
        {                                        /* 17 */
         peripheral_discharge_vbus,              /* .state */
         m_b_peripheral,                         /* .meta */
         "peripheral_discharge_vbus",            /* .name */
         TLDISC_DSCHRG,                          /* .tmout */
         0,                                      /* .reset */
         /* .outputs */
         dp_pullup_out_ | dischrg_vbus_out | pcd_en_out_ | hcd_en_out_,
         },
        {                                        /* 18 */
         peripheral_suspended,                   /* .state */
         m_b_suspended,                          /* .meta */
         "peripheral_suspended",                 /* .name */
         0,                                      /* .tmout */
         0,                                      /* .reset */
         },
        {                                        /* 19 */
         peripheral_wakeup_enabled,              /* .state */
         m_b_suspended,                          /* .meta */
         "peripheral_wakeup_enabled",            /* .name */
         0,                                      /* .tmout */
         remote_wakeup_cmd_,                     /* .reset */
         },
        {                                        /* 20 */
         peripheral_wakeup,                      /* .state */
         m_b_suspended,                          /* .meta */
         "peripheral_wakeup",                    /* .name */
         0,                                      /* .tmout */
         0,                                      /* .reset */
         /* .outputs */
         remote_wakeup_out_power,
         },
        {                                        /* 21 */
         host_idle,                              /* .state */
         m_a_idle,                               /* .meta */
         "host_idle",                            /* .name */
         0,                                      /* .tmout */
         0,                                      /* .reset */
         /* .outputs */
         chrg_vbus_out_ | hcd_en_out | hcd_rh_out_ | dp_pulldown_out | dm_pulldown_out | HUB_PORT_CONNECT_ |
         pcd_en_out_,
         },
        {                                        /* 22 */
         host_idle_dropped,                      /* .state */
         m_a_idle,                               /* .meta */
         "host_idle_dropped",                    /* .name */
         0,                                      /* .tmout */
         0,                                      /* .reset */
         },
        {                                        /* 23 */
         host_wait_vrise,                        /* .state */
         m_a_wait_vrise,                         /* .meta */
         "host_wait_vrise",                      /* .name */
         TA_WAIT_VRISE,                          /* .tmout */
         0,                                      /* .reset */
         /* .outputs */
         drv_vbus_out,
         },
        {                                        /* 24 */
         host_wait_vrise_overcurrent,            /* .state */
         m_a_wait_vrise,                         /* .meta */
         "host_wait_vrise_overcurrent",          /* .name */
         TST_ONE_SECOND,                         /* .tmout */
         0,                                      /* .reset */
         },
        {                                        /* 25 */
         host_wait_port_connect,                 /* .state */
         m_a_wait_bcon,                          /* .meta */
         "host_wait_port_connect",               /* .name */
         0,                                      /* .tmout */
         0,                                      /* .reset */
         /* .outputs */
         loc_sof_out_ | loc_suspend_out_ | dp_pullup_out_ | hcd_rh_out,
         },
        {                                        /* 26 */
         host_port_connected,                    /* .state */
         m_a_host,                               /* .meta */
         "host_port_connected",                  /* .name */
         TST_TWO_SECOND * 5,                     /* .tmout */
         BUS_RESET_,                             /* .reset */
         /* .outputs */
         loc_sof_out,
         },
        {                                        /* 27 */
         host_bus_reset,                         /* .state */
         m_a_host,                               /* .meta */
         "host_bus_reset",                       /* .name */
         0,                                      /* .tmout */
         a_suspend_req_,                         /* .reset */
         },
        {                                        /* 28 */
         host_addressed,                         /* .state */
         m_a_host,                               /* .meta */
         "host_addressed",                       /* .name */
         0,                                      /* .tmout */
         0,                                      /* .reset */
         },
        {                                        /* 29 */
         host_configured,                        /* .state */
         m_a_host,                               /* .meta */
         "host_configured",                      /* .name */
         TST_TWO_SECOND,                         /* .tmout */
         CONFIGURED_ | HNP_CAPABLE | HNP_ENABLED,       /* .reset */
         },
        {                                        /* 30 */
         host_vbus_err,                          /* .state */
         m_a_vbus_err,                           /* .meta */
         "host_vbus_err",                        /* .name */
         0,                                      /* .tmout */
         clr_err_cmd_ | a_suspend_req_,          /* .reset */
         /* .outputs */
         hcd_en_out | pcd_en_out_ | drv_vbus_out_ | charge_pump_out_ | dp_pullup_out_ | loc_sof_out_ | loc_suspend_out_
         | dp_pulldown_out | dm_pulldown_out | hcd_rh_out_,
         },
        {                                        /* 31 */
         host_wait_dischrg,                      /* .state */
         m_a_wait_vfall,                         /* .meta */
         "host_wait_dischrg",                    /* .name */
         0,                                      /* .tmout */
         0,                                      /* .reset */
         /* .outputs */
         drv_vbus_out_ | charge_pump_out_ | loc_sof_out_ | tcd_en_out_power | hcd_rh_out_ | dischrg_vbus_out,
         },
        {                                        /* 32 */
         host_wait_vfall,                        /* .state */
         m_a_wait_vfall,                         /* .meta */
         "host_wait_vfall",                      /* .name */
         TST_ONE_SECOND,                         /* .tmout */
         0,                                      /* .reset */
         /* .outputs */
         hcd_en_out_ | loc_suspend_out_ | pcd_en_out_ | chrg_vbus_out_,
         },
        {                                        /* 33 */
         terminator_state,                       /* .state */
         m_otg_init,                             /* .meta */
         "terminator_state",                     /* .name */
         0,                                      /* .tmout */
         0,                                      /* .reset */
         /* .outputs */
         0,
         },

        {0, 0, "", 0, 0,},

};

struct otg_firmware otg_firmware_mn = {
        OTG_STATES_MN,                           /* number of states */
        OTG_TESTS_MN,                            /* number of tests */
        "otg-mn",                                /* name of firmware */
        otg_states_mn,                           /* struct otg_state * */
        otg_tests_mn,                            /* struct otg_test * */
};

/* eof */
