From 8e834e2299149eff888df97f9de5493bd0d0fa5a Mon Sep 17 00:00:00 2001
From: Shen Yong <b00984@freescale.com>
Date: Thu, 19 Feb 2009 16:58:41 +0800
Subject: [PATCH] ENGR00107987 restructure FM driver

1.refine FM driver code
2.add some functions on FM parameter setting
3.turn on chip power only when device is open

Signed-off-by: Shen Yong<b00984@freescale.com>
---
 drivers/char/mxc_si4702.c      | 1122 +++++++++++++++++++++++++---------------
 include/asm-arm/arch-mxc/mxc.h |   16 +
 2 files changed, 722 insertions(+), 416 deletions(-)

diff --git a/drivers/char/mxc_si4702.c b/drivers/char/mxc_si4702.c
index 0d6a923..52320fe 100644
--- a/drivers/char/mxc_si4702.c
+++ b/drivers/char/mxc_si4702.c
@@ -1,7 +1,7 @@
 /*
  * linux/drivers/char/mxc_si4702.c
  *
- * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -27,15 +27,13 @@
 #include <asm-arm/arch-mxc/mxc.h>
 
 #define SI4702_DEV_NAME		"si4702"
-#define DEV_MAJOR		0
+#define DEV_MAJOR		0	/* this could be module param */
 #define DEV_MINOR		0
 #define DEV_BASE_MINOR		0
 #define DEV_MINOR_COUNT		256
 #define SI4702_I2C_ADDR	0x10	/* 7bits I2C address */
-#define BAND		87500	/* 87.5 MHz */
-#define MAX_BAND	108000
-#define SPACING		100	/* 100 KHz */
-#define DELAY_WAIT	100	/* loop_counter max value */
+#define DELAY_WAIT	0xffff	/* loop_counter max value */
+/* register define */
 #define SI4702_DEVICEID		0x00
 #define SI4702_CHIPID			0x01
 #define SI4702_POWERCFG		0x02
@@ -54,229 +52,100 @@
 #define SI4702_RW_REG_NUM	(SI4702_STATUSRSSI - SI4702_POWERCFG)
 #define SI4702_RW_OFFSET	\
 	(SI4702_REG_NUM - SI4702_STATUSRSSI + SI4702_POWERCFG)
-#define BYTE_TO_WORD(hi, lo)	(((hi) << 8) & 0xFF00) | ((lo) & 0x00FF)
 
-/*module_param();*/
+#define SI4702_SPACE_MASK	0x0030
+#define SI4702_SPACE_200K	0x0
+#define SI4702_SPACE_100K	0x10
+#define SI4702_SPACE_50K	0x20
 
-struct si4702_info {
-	int volume;
-	int channel;
-	int mute:1;
-};
+#define SI4702_BAND_MASK	0x00c0
+#define SI4702_BAND_LSB		6
 
-static struct regulator *reg_vio;
-static struct regulator *reg_vdd;
-static struct class *radio_class;
-static struct device *class_dev;
-static struct si4702_info dev_info;
-/*by default, dev major is zero, and it's alloc dynamicaly. */
-static int dev_major = DEV_MAJOR;
-static int dev_minor = DEV_MINOR;
-static struct cdev si4702_dev;
-static int count;		/* open count */
-DEFINE_SPINLOCK(count_lock);
-static struct i2c_client *si4702_client;
-static unsigned char reg_rw_buf[SI4702_REG_BYTE];
-static int si4702_id_detect(struct i2c_client *client);
-static int __devinit si4702_probe(struct i2c_client *client, const struct i2c_device_id *id);
-static int __devexit si4702_remove(struct i2c_client *client);
-static int si4702_suspend(struct i2c_client *client, pm_message_t state);
-static int si4702_resume(struct i2c_client *client);
-static ssize_t si4702_show(struct device *dev,
-			   struct device_attribute *attr, char *buf);
-static ssize_t si4702_store(struct device *dev,
-			    struct device_attribute *attr, const char *buf,
-			    size_t count);
-static int ioctl_si4702(struct inode *inode, struct file *file,
-			unsigned int cmd, unsigned long arg);
-static int release_si4702(struct inode *inode, struct file *file);
-static int open_si4702(struct inode *inode, struct file *file);
+#define SI4702_SEEKTH_MASK	0xff00
+#define SI4702_SEEKTH_LSB	8
 
-#undef DEBUG
-#ifdef DEBUG
-static void si4702_dump_reg(void);
-#endif
+#define SI4702_SNR_MASK		0x00f0
+#define SI4702_SNR_LSB		4
 
-static struct mxc_fm_platform_data *plat_data;
+#define SI4702_CNT_MASK		0x000f
+#define SI4702_CNT_LSB		0
 
-static struct device_attribute si4702_dev_attr = {
-	.attr = {
-		 .name = "si4702_ctl",
-		 .mode = S_IRUSR | S_IWUSR,
-		 },
-	.show = si4702_show,
-	.store = si4702_store,
-};
+#define SI4702_VOL_MASK		0x000f
+#define SI4702_VOL_LSB		0
 
-static const struct i2c_device_id si4702_id[] = {
-	{ "si4702", 0 },
-	{},
-};
-MODULE_DEVICE_TABLE(i2c, si4702_id);
+#define SI4702_CHAN_MASK	0x03ff
+#define SI4702_TUNE_BIT		0x8000
+#define SI4702_STC_BIT		0x4000
+#define SI4702_DMUTE_BIT	0x4000
+#define SI4702_SEEKUP_BIT	0x0200
+#define SI4702_SEEK_BIT		0x0100
+#define SI4702_SF_BIT		0x2000
+#define SI4702_ENABLE_BIT	0x0001
+#define SI4702_DISABLE_BIT	0x0040
 
-static struct i2c_driver i2c_si4702_driver = {
-	.driver = {
-		   .name = "si4702",
-		   },
-	.probe = si4702_probe,
-	.remove = si4702_remove,
-	.id_table = si4702_id,
-	.suspend = si4702_suspend,
-	.resume = si4702_resume,
-};
-static struct file_operations si4702_fops = {
-	.owner = THIS_MODULE,
-	.open = open_si4702,
-	.release = release_si4702,
-	.ioctl = ioctl_si4702,
+enum {
+	BAND_USA = 0,
+	BAND_JAP_W,
+	BAND_JAP
 };
 
-static int __devinit si4702_probe(struct i2c_client *client, const struct i2c_device_id *id)
-{
-	int ret = 0;
-	dev_t dev;
-	struct mxc_fm_platform_data *data;
-
-	dev_info(&client->dev, "si4702 device probe process start.\n");
-
-	data = (struct mxc_fm_platform_data *)client->dev.platform_data;
-	if (data == NULL) {
-		dev_err(&client->dev, "lack of platform data!\n");
-		return -ENODEV;
-	} else {
-		plat_data = data;
-	}
-
-	/*enable power supply */
-	reg_vio = regulator_get(&client->dev, data->reg_vio);
-	if (reg_vio == ERR_PTR(-ENOENT))
-		return -ENOENT;
-	regulator_enable(reg_vio);	/*shall i check the return value */
-	regulator_put(reg_vio, &client->dev);
-
-	reg_vdd = regulator_get(&client->dev, data->reg_vdd);
-	if (reg_vdd == ERR_PTR(-ENOENT))
-		return -ENOENT;
-	regulator_enable(reg_vdd);
-	regulator_put(reg_vdd, &client->dev);
-	/*attach client and check device id */
-	if (SI4702_DEVICE_ID != si4702_id_detect(client)) {
-		dev_info(&client->dev, "id wrong.\n");
-		goto disable_power;
-	}
-	dev_info(&client->dev, "chip id %x detect.\n", SI4702_DEVICE_ID);
-	si4702_client = client;
+struct si4702_info {
+	int min_band;
+	int max_band;
+	int space;
+	int volume;
+	int channel;
+	int mute;
+};
 
-	plat_data->gpio_get();
+struct si4702_drvdata {
+	struct regulator *vio;
+	struct regulator *vdd;
+	struct class *radio_class;
+	struct si4702_info info;
+	/*by default, dev major is zero, and it's alloc dynamicaly. */
+	int major;
+	int minor;
+	struct cdev *cdev;
+	int count;		/* open count */
+	struct i2c_client *client;
+	unsigned char reg_rw_buf[SI4702_REG_BYTE];
+	struct mxc_fm_platform_data *plat_data;
+};
 
-	/*user interface begain */
-	/*create device file in sysfs as a user interface,
-	 * also for debug support */
-	ret = device_create_file(&client->dev, &si4702_dev_attr);
-	if (ret) {
-		dev_err(&client->dev, "create device file failed!\n");
-		goto gpio_put;	/* shall i use some meanful error code? */
-	}
+static struct si4702_drvdata *si4702_drvdata;
 
-	/*create a char dev for application code access */
-	if (dev_major) {
-		ret = 0;
-	} else {
-		/*does this name field have any usefull meaning */
-		ret = alloc_chrdev_region(&dev, DEV_BASE_MINOR,
-					  DEV_MINOR_COUNT, "si4702");
-		dev_major = MAJOR(dev);
-		dev_minor = MINOR(dev);
-	}
+DEFINE_SPINLOCK(count_lock);
 
-	if (ret < 0)
-		goto device_file_remove;
+#ifdef DEBUG
+static void si4702_dump_reg(void)
+{
+	int i, j;
+	unsigned char *reg_rw_buf;
 
-	cdev_init(&si4702_dev, &si4702_fops);
-	si4702_dev.owner = THIS_MODULE;
+	if (NULL == si4702_drvdata)
+		return;
 
-	if (cdev_add(&si4702_dev, dev, DEV_MINOR_COUNT))
-		goto device_file_remove;
+	reg_rw_buf = si4702_drvdata->reg_rw_buf;
 
-	/* create class and device for udev information */
-	radio_class = class_create(THIS_MODULE, "radio");
-	if (IS_ERR(radio_class)) {
-		dev_err(&si4702_client->dev,
-			"SI4702: failed to create radio class\n");
-		goto char_dev_remove;
+	for (i = 0; i < 10; i++) {
+		j = i * 2 + 12;
+		pr_debug("reg[%02d] = %04x\n", i,
+			 ((reg_rw_buf[j] << 8) & 0xFF00) +
+			 (reg_rw_buf[j + 1] & 0x00FF));
 	}
-
-	class_dev =
-	    device_create(radio_class, NULL, MKDEV(dev_major, dev_minor),
-			  SI4702_DEV_NAME);
-	if (IS_ERR(class_dev)) {
-		dev_err(&si4702_client->dev,
-			"SI4702: failed to create radio class device\n");
-		goto class_remove;
+	for (; i < 16; i++) {
+		j = (i - 10) * 2;
+		pr_debug("reg[%02d] = %04x\n", i,
+			 ((reg_rw_buf[j] << 8) & 0xFF00) +
+			 (reg_rw_buf[j + 1] & 0x00FF));
 	}
-	/*User interface end */
-
-	return 0;
-      class_remove:
-	class_destroy(radio_class);
-      char_dev_remove:
-	cdev_del(&si4702_dev);
-      device_file_remove:
-	device_remove_file(&client->dev, &si4702_dev_attr);
-      gpio_put:
-	plat_data->gpio_put();
-      disable_power:
-	reg_vio = regulator_get(&client->dev, data->reg_vio);
-	if (reg_vio == ERR_PTR(-ENOENT))
-		return -ENOENT;
-	regulator_disable(reg_vio);	/*shall i check the return value */
-	regulator_put(reg_vio, &client->dev);
-
-	reg_vdd = regulator_get(&client->dev, data->reg_vdd);
-	if (reg_vdd == ERR_PTR(-ENOENT))
-		return -ENOENT;
-	regulator_disable(reg_vdd);
-	regulator_put(reg_vdd, &client->dev);
-
-	return 0;
 }
-
-static int __devexit si4702_remove(struct i2c_client *client)
+#else
+static void si4702_dump_reg(void)
 {
-	struct mxc_fm_platform_data *data;
-
-	data = (struct mxc_fm_platform_data *)client->dev.platform_data;
-
-	device_destroy(radio_class, MKDEV(dev_major, dev_minor));
-	class_destroy(radio_class);
-	cdev_del(&si4702_dev);
-	device_remove_file(&client->dev, &si4702_dev_attr);
-	plat_data->gpio_put();
-
-	reg_vio = regulator_get(&client->dev, data->reg_vio);
-	if (reg_vio == ERR_PTR(-ENOENT))
-		return -ENOENT;
-	regulator_disable(reg_vio);	/*shall i check the return value */
-	regulator_put(reg_vio, &client->dev);
-
-	reg_vdd = regulator_get(&client->dev, data->reg_vdd);
-	if (reg_vdd == ERR_PTR(-ENOENT))
-		return -ENOENT;
-	regulator_disable(reg_vdd);
-	regulator_put(reg_vdd, &client->dev);
-
-	return 0;
-}
-
-static int si4702_suspend(struct i2c_client *client, pm_message_t state)
-{
-	return 0;
-}
-
-static int si4702_resume(struct i2c_client *client)
-{
-	return 0;
 }
+#endif				/* DEBUG */
 
 /*
  *check the si4702 spec for the read/write concequence.
@@ -285,7 +154,6 @@ static int si4702_resume(struct i2c_client *client)
  *-------------------------------
  *      buf:0 2      A     F
  */
-
 #define REG_to_BUF(reg) (((reg >= 0) && (reg < SI4702_STATUSRSSI))?\
 		(reg - SI4702_STATUSRSSI + SI4702_REG_NUM):\
 		((reg >= SI4702_STATUSRSSI) && (reg < SI4702_REG_NUM))?\
@@ -294,30 +162,38 @@ static int si4702_resume(struct i2c_client *client)
 static int si4702_read_reg(const int reg, u16 *value)
 {
 	int ret, index;
+	unsigned char *reg_rw_buf;
 
-	if (NULL == si4702_client)
+	if (NULL == si4702_drvdata)
 		return -1;
 
+	reg_rw_buf = si4702_drvdata->reg_rw_buf;
+
 	index = REG_to_BUF(reg);
 
 	if (-1 == index)
 		return -1;
 
-	ret = i2c_master_recv(si4702_client, reg_rw_buf, SI4702_REG_BYTE);
+	ret =
+	    i2c_master_recv(si4702_drvdata->client, reg_rw_buf,
+			    SI4702_REG_BYTE);
 
 	*value = (reg_rw_buf[index * 2] << 8) & 0xFF00;
 	*value |= reg_rw_buf[index * 2 + 1] & 0x00FF;
 
-	return ret;
+	return ret < 0 ? ret : 0;
 }
 
 static int si4702_write_reg(const int reg, const u16 value)
 {
-	int index;
+	int index, ret;
+	unsigned char *reg_rw_buf;
 
-	if (NULL == si4702_client)
+	if (NULL == si4702_drvdata)
 		return -1;
 
+	reg_rw_buf = si4702_drvdata->reg_rw_buf;
+
 	index = REG_to_BUF(reg);
 
 	if (-1 == index)
@@ -326,23 +202,57 @@ static int si4702_write_reg(const int reg, const u16 value)
 	reg_rw_buf[index * 2] = (value & 0xFF00) >> 8;
 	reg_rw_buf[index * 2 + 1] = value & 0x00FF;
 
-	return i2c_master_send(si4702_client,
-			       &reg_rw_buf[SI4702_RW_OFFSET * 2],
-			       (SI4702_STATUSRSSI - SI4702_POWERCFG) * 2);
+	ret = i2c_master_send(si4702_drvdata->client,
+			      &reg_rw_buf[SI4702_RW_OFFSET * 2],
+			      (SI4702_STATUSRSSI - SI4702_POWERCFG) * 2);
+	return ret < 0 ? ret : 0;
+}
+
+static void si4702_gpio_get(void)
+{
+	if (NULL == si4702_drvdata)
+		return;
+
+	si4702_drvdata->plat_data->gpio_get();
+}
+
+static void si4702_gpio_put(void)
+{
+	if (NULL == si4702_drvdata)
+		return;
+
+	si4702_drvdata->plat_data->gpio_put();
+}
+
+static void si4702_reset(void)
+{
+	if (NULL == si4702_drvdata)
+		return;
+
+	si4702_drvdata->plat_data->reset();
+}
+
+static void si4702_clock_en(int flag)
+{
+	if (NULL == si4702_drvdata)
+		return;
+
+	si4702_drvdata->plat_data->clock_ctl(flag);
 }
 
 static int si4702_id_detect(struct i2c_client *client)
 {
 	int ret, index;
 	unsigned int ID = 0;
+	unsigned char reg_rw_buf[SI4702_REG_BYTE];
 
-	plat_data->gpio_get();
-	plat_data->reset();
-	plat_data->clock_ctl(1);
+	si4702_gpio_get();
+	si4702_reset();
+	si4702_clock_en(1);
 
 	ret = i2c_master_recv(client, (char *)reg_rw_buf, SI4702_REG_BYTE);
 
-	plat_data->gpio_put();
+	si4702_gpio_put();
 
 	if (ret < 0)
 		return ret;
@@ -357,144 +267,304 @@ static int si4702_id_detect(struct i2c_client *client)
 	return ID;
 }
 
+/* valid args 50/100/200 */
+static int si4702_set_space(int space)
+{
+	u16 reg;
+	int ret;
+	struct si4702_info *info;
+
+	if (NULL == si4702_drvdata)
+		return -1;
+
+	ret = si4702_read_reg(SI4702_SYSCONFIG2, &reg);
+	if (ret == -1)
+		return ret;
+
+	reg &= ~SI4702_SPACE_MASK;
+	switch (space) {
+	case 50:
+		reg |= SI4702_SPACE_50K;
+		break;
+	case 100:
+		reg |= SI4702_SPACE_100K;
+		break;
+	case 200:
+		ret |= SI4702_SPACE_200K;
+		break;
+	default:
+		return -1;
+	}
+
+	ret = si4702_write_reg(SI4702_SYSCONFIG2, reg);
+	if (ret == -1)
+		return ret;
+
+	info = &si4702_drvdata->info;
+	info->space = space;
+	return 0;
+}
+
+static int si4702_set_band_range(int band)
+{
+	u16 reg;
+	int ret, band_min, band_max;
+	struct si4702_info *info;
+
+	if (NULL == si4702_drvdata)
+		return -1;
+
+	switch (band) {
+	case BAND_USA:
+		band_min = 87500;
+		band_max = 108000;
+		break;
+	case BAND_JAP_W:
+		band_min = 76000;
+		band_max = 108000;
+		break;
+	case BAND_JAP:
+		band_min = 76000;
+		band_max = 90000;
+		break;
+	default:
+		return -1;
+	}
+
+	ret = si4702_read_reg(SI4702_SYSCONFIG2, &reg);
+	if (ret == -1)
+		return ret;
+
+	reg = (reg & ~SI4702_BAND_MASK)
+	    | ((band << SI4702_BAND_LSB) & SI4702_BAND_MASK);
+	ret = si4702_write_reg(SI4702_SYSCONFIG2, reg);
+	if (ret == -1)
+		return ret;
+
+	info = &si4702_drvdata->info;
+	info->min_band = band_min;
+	info->max_band = band_max;
+	return 0;
+}
+
+static int si4702_set_seekth(u8 seekth)
+{
+	u16 reg;
+	int ret;
+
+	if (NULL == si4702_drvdata)
+		return -1;
+
+	ret = si4702_read_reg(SI4702_SYSCONFIG2, &reg);
+	if (ret == -1)
+		return ret;
+
+	reg =
+	    (reg & ~SI4702_SEEKTH_MASK) | ((seekth << SI4702_SEEKTH_LSB) &
+					   SI4702_SEEKTH_MASK);
+	ret = si4702_write_reg(SI4702_SYSCONFIG2, reg);
+	if (ret == -1)
+		return ret;
+
+	return 0;
+}
+
+static int si4702_set_sksnr(u8 sksnr)
+{
+	u16 reg;
+	int ret;
+
+	if (NULL == si4702_drvdata)
+		return -1;
+
+	ret = si4702_read_reg(SI4702_SYSCONFIG3, &reg);
+	if (ret == -1)
+		return ret;
+
+	reg =
+	    (reg & ~SI4702_SNR_MASK) | ((sksnr << SI4702_SNR_LSB) &
+					SI4702_SNR_MASK);
+	ret = si4702_write_reg(SI4702_SYSCONFIG3, reg);
+	if (ret == -1)
+		return ret;
+
+	return 0;
+}
+
+static int si4702_set_skcnt(u8 skcnt)
+{
+	u16 reg;
+	int ret;
+
+	if (NULL == si4702_drvdata)
+		return -1;
+
+	ret = si4702_read_reg(SI4702_SYSCONFIG3, &reg);
+	if (ret == -1)
+		return ret;
+
+	reg = (reg & ~SI4702_CNT_MASK) | (skcnt & SI4702_CNT_MASK);
+	ret = si4702_write_reg(SI4702_SYSCONFIG3, reg);
+	if (ret == -1)
+		return ret;
+
+	return 0;
+}
+
+static int si4702_set_vol(int vol)
+{
+	u16 reg;
+	int ret;
+	struct si4702_info *info;
+
+	if (NULL == si4702_drvdata)
+		return -1;
+
+	ret = si4702_read_reg(SI4702_SYSCONFIG2, &reg);
+	if (ret == -1)
+		return ret;
+
+	reg = (reg & ~SI4702_VOL_MASK) | (vol & SI4702_VOL_MASK);
+	ret = si4702_write_reg(SI4702_SYSCONFIG2, reg);
+	if (ret == -1)
+		return ret;
+
+	info = &si4702_drvdata->info;
+	info->volume = vol;
+
+	return 0;
+}
+
 static u8 si4702_channel_select(u32 freq)
 {
 	u16 loop_counter = 0;
 	s16 channel;
-	u16 si4702_read_data, si4702_write_data;
+	u16 si4702_reg_data;
 	u8 error_ind = 0;
-	u8 si4702_channel_start_tune[] = { 0x40, 0x01, 0x80, 0x00 };
-	u8 si4702_channel_stop_tune[] = { 0x40, 0x01, 0x00 };
+	struct i2c_client *client;
+	struct si4702_info *info;
 
-	if (dev_info.mute) {
-		/* enable mute */
-		si4702_channel_start_tune[0] = 0;
-		si4702_channel_stop_tune[0] = 0;
-	}
-	dev_info(&si4702_client->dev, "Input frequnce is %d\n", freq);
-	/* convert freq to channel */
-	channel = (freq - BAND) / SPACING;
-	if (channel < 0 || channel > 1023) {
-		dev_err(&si4702_client->dev, "Input frequnce is invalid\n");
+	if (NULL == si4702_drvdata)
 		return -1;
-	}
-	/* fill channel bits */
-	si4702_channel_start_tune[2] |= channel >> 8;
-	si4702_channel_start_tune[3] |= channel & 0xFF;
 
-	/* set tune bit */
-	si4702_write_data =
-	    BYTE_TO_WORD(si4702_channel_start_tune[0],
-			 si4702_channel_start_tune[1]);
-	error_ind = si4702_write_reg(SI4702_POWERCFG, si4702_write_data);
+	info = &si4702_drvdata->info;
+	client = si4702_drvdata->client;
 
-	si4702_write_data =
-	    BYTE_TO_WORD(si4702_channel_start_tune[2],
-			 si4702_channel_start_tune[3]);
-	error_ind = si4702_write_reg(SI4702_CHANNEL, si4702_write_data);
+	dev_info(&client->dev, "Input frequnce is %d\n", freq);
+	if (freq < 76000 || freq > 108000) {
+		dev_err(&client->dev, "Input frequnce is invalid\n");
+		return -1;
+	}
+	/* convert freq to channel */
+	channel = (freq - info->min_band) / info->space;
 
+	si4702_reg_data = SI4702_TUNE_BIT | (channel & SI4702_CHAN_MASK);
+	/* set channel */
+	error_ind = si4702_write_reg(SI4702_CHANNEL, si4702_reg_data);
 	if (error_ind) {
-		dev_err(&si4702_client->dev, "Failed to set start tune\n");
+		dev_err(&client->dev, "Failed to set channel\n");
 		return -1;
 	}
+	dev_info(&client->dev, "Set channel to %d\n", channel);
 
 	/* wait for STC == 1 */
 	do {
 		error_ind =
-		    si4702_read_reg(SI4702_STATUSRSSI, &si4702_read_data);
+		    si4702_read_reg(SI4702_STATUSRSSI, &si4702_reg_data);
 
 		if (error_ind) {
-			dev_err(&si4702_client->dev,
-				"Failed to read setted STC\n");
+			dev_err(&client->dev, "Failed to read setted STC\n");
 			return -1;
 		}
-		if ((si4702_read_data & 0x4000) != 0)
+		if ((si4702_reg_data & SI4702_STC_BIT) != 0)
 			break;
-		/* sleep to wait */
-		msleep(200);
-
 	} while (++loop_counter < DELAY_WAIT);
 
 	/* check loop_counter */
 	if (loop_counter >= DELAY_WAIT) {
-		dev_err(&si4702_client->dev, "Can't wait for STC bit set");
+		dev_err(&client->dev, "Can't wait for STC bit set");
 		return -1;
 	}
-	loop_counter = 0;
+	dev_info(&client->dev, "loop counter %d\n", loop_counter);
 
+	loop_counter = 0;
 	/* clear tune bit */
 	error_ind = si4702_write_reg(SI4702_CHANNEL, 0);
 
 	if (error_ind) {
-		dev_err(&si4702_client->dev, "Failed to set stop tune\n");
+		dev_err(&client->dev, "Failed to set stop tune\n");
 		return -1;
 	}
 
 	/* wait for STC == 0 */
 	do {
 		error_ind =
-		    si4702_read_reg(SI4702_STATUSRSSI, &si4702_read_data);
+		    si4702_read_reg(SI4702_STATUSRSSI, &si4702_reg_data);
 
 		if (error_ind) {
-			dev_err(&si4702_client->dev,
-				"Failed to set read STC\n");
+			dev_err(&client->dev, "Failed to set read STC\n");
 			return -1;
 		}
-		if ((si4702_read_data & 0x4000) == 0)
+		if ((si4702_reg_data & SI4702_STC_BIT) == 0)
 			break;
-		/* sleep to wait */
-		msleep(200);
-
 	} while (++loop_counter < DELAY_WAIT);
 
 	/* check loop_counter */
 	if (loop_counter >= DELAY_WAIT) {
-		dev_err(&si4702_client->dev, "Can't wait for STC bit set");
+		dev_err(&client->dev, "Can't wait for STC bit clean");
 		return -1;
 	}
-#if 1
+	dev_info(&client->dev, "loop counter %d\n", loop_counter);
+
 	/* read RSSI */
-	error_ind = si4702_read_reg(SI4702_READCHAN, &si4702_read_data);
+	error_ind = si4702_read_reg(SI4702_READCHAN, &si4702_reg_data);
 
 	if (error_ind) {
-		dev_err(&si4702_client->dev, "Failed to read RSSI\n");
+		dev_err(&client->dev, "Failed to read RSSI\n");
 		return -1;
 	}
 
-	channel = si4702_read_data & 0x03ff;
-	dev_err(&si4702_client->dev, "seek finish: channel(%d)\n", channel);
-#endif
+	channel = si4702_reg_data & SI4702_CHAN_MASK;
+	dev_info(&client->dev, "seek finish: channel(%d)\n", channel);
+
 	return 0;
 }
 
 static s32 si4702_channel_seek(s16 dir)
 {
 	u16 loop_counter = 0;
-	u16 si4702_reg_data;
+	u16 si4702_reg_data, reg_power_cfg;
 	u8 error_ind = 0;
-	s32 seek_error = 0;
-	u32 channel;
+	u32 channel, freq;
+	struct i2c_client *client;
+	struct si4702_info *info;
+
+	if (NULL == si4702_drvdata)
+		return -1;
+
+	info = &si4702_drvdata->info;
+	client = si4702_drvdata->client;
 
-	error_ind = si4702_read_reg(SI4702_POWERCFG, &si4702_reg_data);
+	error_ind = si4702_read_reg(SI4702_POWERCFG, &reg_power_cfg);
 
-	if (dev_info.mute) {
+	if (info->mute) {
 		/* check disable mute */
-		si4702_reg_data &= 0xBFFF;
+		reg_power_cfg &= ~SI4702_DMUTE_BIT;
 	} else {
-		si4702_reg_data |= 0x4000;
+		reg_power_cfg |= SI4702_DMUTE_BIT;
 	}
 
 	if (dir) {
-		si4702_reg_data |= 0x0200;
+		reg_power_cfg |= SI4702_SEEKUP_BIT;
 	} else {
-		si4702_reg_data &= 0xFDFF;
+		reg_power_cfg &= ~SI4702_SEEKUP_BIT;
 	}
 	/* start seek */
-	si4702_reg_data |= 0x4100;
-	error_ind = si4702_write_reg(SI4702_POWERCFG, si4702_reg_data);
+	reg_power_cfg |= SI4702_SEEK_BIT;
+	error_ind = si4702_write_reg(SI4702_POWERCFG, reg_power_cfg);
 
 	if (error_ind) {
-		dev_err(&si4702_client->dev, "Failed to set seek start bit\n");
+		dev_err(&client->dev, "Failed to set seek start bit\n");
 		return -1;
 	}
 
@@ -503,113 +573,128 @@ static s32 si4702_channel_seek(s16 dir)
 		error_ind =
 		    si4702_read_reg(SI4702_STATUSRSSI, &si4702_reg_data);
 		if (error_ind) {
-			dev_err(&si4702_client->dev,
-				"Failed to read STC bit\n");
+			dev_err(&client->dev, "Failed to read STC bit\n");
 			return -1;
 		}
 
-		if ((si4702_reg_data & 0x4000) != 0)
+		if ((si4702_reg_data & SI4702_STC_BIT) != 0)
 			break;
-		/* sleep to wait */
-		msleep(50);
-
 	} while (++loop_counter < DELAY_WAIT);
 
-	if (loop_counter >= DELAY_WAIT) {
-		dev_err(&si4702_client->dev, "Can't wait for STC bit set\n");
+	/* clear seek bit */
+	reg_power_cfg &= ~SI4702_SEEK_BIT;
+	error_ind = si4702_write_reg(SI4702_POWERCFG, reg_power_cfg);
+	if (error_ind) {
+		dev_err(&client->dev, "Failed to stop seek\n");
 		return -1;
 	}
-	loop_counter = 0;
 
-	/* check whether SF==1 (seek failed bit) */
-	if ((si4702_reg_data & 0x2000) != 0) {
-		dev_err(&si4702_client->dev, "Failed to seek any channel\n");
-		seek_error = -2;
+	if (loop_counter >= DELAY_WAIT) {
+		dev_err(&client->dev, "Can't wait for STC bit set\n");
+		return -1;
 	}
 
-	/* clear seek bit */
-	error_ind = si4702_read_reg(SI4702_POWERCFG, &si4702_reg_data);
-	si4702_reg_data &= 0xFEFF;
-	error_ind = si4702_write_reg(SI4702_POWERCFG, si4702_reg_data);
-
-	if (error_ind) {
-		dev_err(&si4702_client->dev, "Failed to stop seek\n");
+	/* check whether SF==1 (seek failed bit) */
+	if ((si4702_reg_data & SI4702_SF_BIT) != 0) {
+		dev_err(&client->dev, "Failed to seek any channel\n");
 		return -1;
 	}
+
+	loop_counter = 0;
 	/* wait STC == 0 */
 	do {
 		error_ind =
 		    si4702_read_reg(SI4702_STATUSRSSI, &si4702_reg_data);
 
 		if (error_ind) {
-			dev_err(&si4702_client->dev,
+			dev_err(&client->dev,
 				"Failed to wait STC bit to clear\n");
 			return -1;
 		}
-		if ((si4702_reg_data & 0x4000) == 0)
+		if ((si4702_reg_data & SI4702_STC_BIT) == 0)
 			break;
-		/* sleep to wait */
-		msleep(50);
 	} while (++loop_counter < DELAY_WAIT);
 
 	/* check loop_counter */
 	if (loop_counter >= DELAY_WAIT) {
-		dev_err(&si4702_client->dev, "Can't wait for STC bit set");
+		dev_err(&client->dev, "Can't wait for STC bit clean");
 		return -1;
 	}
 
 	error_ind = si4702_read_reg(SI4702_READCHAN, &si4702_reg_data);
 
 	if (error_ind) {
-		dev_err(&si4702_client->dev, "I2C simulate failed\n");
+		dev_err(&client->dev, "I2C simulate failed\n");
 		return -1;
 	}
 
-	if (seek_error == 0) {
-		channel = si4702_reg_data & 0x03ff;
-		seek_error = channel * SPACING + BAND;
-		dev_err(&si4702_client->dev,
-			"seek finish: channel(%d), freq(%dKHz)\n", channel,
-			seek_error);
-	}
+	channel = si4702_reg_data & SI4702_CHAN_MASK;
+	freq = channel * info->space + info->min_band;
+	dev_err(&client->dev,
+		"seek finish: channel(%d), freq(%dKHz)\n", channel, freq);
 
-	return seek_error;
+	return 0;
 }
 
-#define MORE_TIME
 static int si4702_startup(void)
 {
 	u16 magic = 0, id;
+	struct i2c_client *client;
+	struct mxc_fm_platform_data *data;
+
+	if (NULL == si4702_drvdata)
+		return -1;
 
-#ifdef MORE_TIME
+	if (si4702_drvdata->vio)
+		regulator_enable(si4702_drvdata->vio);
+	if (si4702_drvdata->vdd)
+		regulator_enable(si4702_drvdata->vdd);
+	data = si4702_drvdata->plat_data;
+	client = si4702_drvdata->client;
+
+	/* read prior to write, otherwise write op will fail */
 	si4702_read_reg(SI4702_DEVICEID, &id);
-	dev_err(&si4702_client->dev, "si4702: DEVICEID: 0x%x\n", id);
-#endif
+	dev_err(&client->dev, "si4702: DEVICEID: 0x%x\n", id);
 
-	plat_data->clock_ctl(1);
-	mdelay(100);
+	si4702_clock_en(1);
+	msleep(100);
 
 	/* disable mute, stereo, seek down, powerup */
-	si4702_write_reg(SI4702_POWERCFG, 0x4001);
-	mdelay(500);
+	si4702_write_reg(SI4702_POWERCFG, SI4702_DMUTE_BIT | SI4702_ENABLE_BIT);
+	msleep(500);
 	si4702_read_reg(SI4702_TEST1, &magic);
 	if (magic != 0x3C04)
-		dev_err(&si4702_client->dev, "magic number 0x%x.\n", magic);
+		dev_err(&client->dev, "magic number 0x%x.\n", magic);
 	/* close tune, set channel to 0 */
 	si4702_write_reg(SI4702_CHANNEL, 0);
 	/* disable interrupt, disable GPIO */
 	si4702_write_reg(SI4702_SYSCONFIG1, 0);
-	/* seek threshold, band, space select to Europe, volume to max */
-	si4702_write_reg(SI4702_SYSCONFIG2, 0x0f13);
-	si4702_write_reg(SI4702_SYSCONFIG3, 0x48);
+	/* set volume to middle level */
+	si4702_set_vol(0xf);
+
+	si4702_set_space(data->space);
+	si4702_set_band_range(data->band);
+	si4702_set_seekth(data->seekth);
+	si4702_set_skcnt(data->skcnt);
+	si4702_set_sksnr(data->sksnr);
 
 	return 0;
 }
 
 static void si4702_shutdown(void)
 {
-	si4702_write_reg(SI4702_POWERCFG, 0x4041);
-	plat_data->clock_ctl(0);
+	if (NULL == si4702_drvdata)
+		return;
+
+	si4702_write_reg(SI4702_POWERCFG, SI4702_DMUTE_BIT |
+			 SI4702_ENABLE_BIT | SI4702_DISABLE_BIT);
+	msleep(100);
+	si4702_clock_en(0);
+
+	if (si4702_drvdata->vdd)
+		regulator_disable(si4702_drvdata->vdd);
+	if (si4702_drvdata->vio)
+		regulator_disable(si4702_drvdata->vio);
 }
 
 enum {
@@ -622,6 +707,9 @@ enum {
 	FM_SEEK_DOWN,
 	FM_MUTEON,
 	FM_MUTEDIS,
+	FM_SEL,
+	FM_SEEKTH,
+	FM_DL,
 	FM_CTL_MAX
 };
 
@@ -634,35 +722,58 @@ static const char *const fm_control[FM_CTL_MAX] = {
 	[FM_SEEK_UP] = "seeku",
 	[FM_SEEK_DOWN] = "seekd",
 	[FM_MUTEON] = "mute",
-	[FM_MUTEDIS] = "muted"
+	[FM_MUTEDIS] = "muted",
+	[FM_SEL] = "select",
+	[FM_SEEKTH] = "seekth",
+	[FM_DL] = "delay"
 };
 
-static int cmd(unsigned int index)
+static int cmd(unsigned int index, int arg)
 {
+	struct i2c_client *client;
+	struct mxc_fm_platform_data *plat_data;
+
+	if (NULL == si4702_drvdata)
+		return -1;
+
+	client = si4702_drvdata->client;
+	plat_data = si4702_drvdata->plat_data;
+
 	switch (index) {
 	case FM_SHUTDOWN:
-		dev_err(&si4702_client->dev, "FM_SHUTDOWN\n");
+		dev_err(&client->dev, "FM_SHUTDOWN\n");
 		si4702_shutdown();
 		break;
 	case FM_STARTUP:
-		dev_err(&si4702_client->dev, "FM_STARTUP\n");
-		plat_data->reset();
+		dev_err(&client->dev, "FM_STARTUP\n");
+		si4702_reset();
 		si4702_startup();
 		break;
 	case FM_RESET:
-		dev_err(&si4702_client->dev, "FM_RESET\n");
-		plat_data->reset();
+		dev_err(&client->dev, "FM_RESET\n");
+		si4702_reset();
 		break;
 	case FM_SEEK_DOWN:
-		dev_err(&si4702_client->dev, "SEEK DOWN\n");
+		dev_err(&client->dev, "SEEK DOWN\n");
 		si4702_channel_seek(0);
 		break;
 	case FM_SEEK_UP:
-		dev_err(&si4702_client->dev, "SEEK UP\n");
+		dev_err(&client->dev, "SEEK UP\n");
 		si4702_channel_seek(1);
 		break;
+	case FM_SEL:
+		dev_err(&client->dev, "select %d\n", arg * 100);
+		si4702_channel_select(arg * 100);
+		break;
+	case FM_SEEKTH:
+		dev_err(&client->dev, "seekth = %d\n", arg);
+		si4702_set_seekth(arg);
+		break;
+	case FM_DL:
+		dev_err(&client->dev, "delay = %d\n", arg);
+		break;
 	default:
-		dev_err(&si4702_client->dev, "error command\n");
+		dev_err(&client->dev, "error command\n");
 		break;
 	}
 	return 0;
@@ -671,7 +782,13 @@ static int cmd(unsigned int index)
 static ssize_t si4702_show(struct device *dev,
 			   struct device_attribute *attr, char *buf)
 {
-	dev_err(&si4702_client->dev, "si4702 show\n");
+	struct si4702_drvdata *drv_data = dev_get_drvdata(dev);
+	u16 device_id;
+
+	dev_err(&(drv_data->client->dev), "si4702 show\n");
+	si4702_read_reg(SI4702_DEVICEID, &device_id);
+	pr_info("device id %x\n", device_id);
+	si4702_dump_reg();
 	return 0;
 }
 
@@ -681,27 +798,39 @@ static ssize_t si4702_store(struct device *dev,
 {
 	int state = 0;
 	const char *const *s;
-	char *p;
+	char *p = NULL;
 	int error;
-	int len;
+	int len, arg = 0;
+	struct si4702_drvdata *drv_data = dev_get_drvdata(dev);
+	struct i2c_client *client = drv_data->client;
 
-	dev_err(&si4702_client->dev, "si4702 store %d\n", count);
+	dev_err(&client->dev, "si4702 store %d\n", count);
 
-	p = memchr(buf, '\n', count);
-	len = p ? p - buf : count;
+	p = memchr(buf, ' ', count);
+	if (p) {
+		len = p - buf;
+		*p = '\0';
+	} else
+		len = count;
 
-	dev_err(&si4702_client->dev, "cmd %s\n", buf);
+	len -= 1;
+	dev_err(&client->dev, "cmd %s\n", buf);
 
 	for (s = &fm_control[state]; state < FM_CTL_MAX; s++, state++) {
 		if (*s && !strncmp(buf, *s, len)) {
-			dev_err(&si4702_client->dev, "state %d\n", state);
 			break;
 		}
 	}
-	if (state < FM_CTL_MAX && *s)
-		error = cmd(state);
-	else
+	if (state < FM_CTL_MAX && *s) {
+		if (p)
+			arg = simple_strtoul(p + 1, NULL, 0);
+		dev_err(&client->dev, "arg = %d\n", arg);
+		error = cmd(state, arg);
+	} else {
+		dev_err(&client->dev, "error cmd\n");
 		error = -EINVAL;
+	}
+
 	return error ? error : count;
 }
 
@@ -715,23 +844,30 @@ static int ioctl_si4702(struct inode *inode, struct file *file,
 	u8 volume;
 	unsigned int freq;
 	int dir;
+	struct i2c_client *client;
+	struct si4702_info *info;
+
+	if (NULL == si4702_drvdata)
+		return -1;
+
+	info = &si4702_drvdata->info;
+	client = si4702_drvdata->client;
 
-	dev_err(&si4702_client->dev,
-		"ioctl, cmd: 0x%x, arg: 0x%lx\n", cmd, arg);
+	dev_err(&client->dev, "ioctl, cmd: 0x%x, arg: 0x%lx\n", cmd, arg);
 
 	switch (cmd) {
 	case SI4702_SETVOLUME:
 		/* get volume from user */
 		if (copy_from_user(&volume, argp, sizeof(u8))) {
 
-			dev_err(&si4702_client->dev,
+			dev_err(&client->dev,
 				"ioctl, copy volume value from user failed\n");
 			return -EFAULT;
 		}
-		dev_err(&si4702_client->dev, "volume %d\n", volume);
+		dev_err(&client->dev, "volume %d\n", volume);
 		/* refill the register value */
 		volume &= 0x0f;
-		if (dev_info.mute)
+		if (info->mute)
 			error = si4702_write_reg(SI4702_POWERCFG, 0x0001);
 		else
 			error = si4702_write_reg(SI4702_POWERCFG, 0x4001);
@@ -740,19 +876,17 @@ static int ioctl_si4702(struct inode *inode, struct file *file,
 		error = si4702_write_reg(SI4702_SYSCONFIG1, 0);
 		error = si4702_write_reg(SI4702_SYSCONFIG2, 0x0f10 | volume);
 		if (error) {
-			dev_err(&si4702_client->dev,
-				"ioctl, set volume failed\n");
+			dev_err(&client->dev, "ioctl, set volume failed\n");
 			return -EFAULT;
 		}
 		/* renew the device info */
-		dev_info.volume = volume;
+		info->volume = volume;
 
 		break;
 	case SI4702_GETVOLUME:
 		/* just copy volume value to user */
-		if (copy_to_user(argp, &dev_info.volume, sizeof(unsigned int))) {
-			dev_err(&si4702_client->dev,
-				"ioctl, copy to user failed\n");
+		if (copy_to_user(argp, &(info->volume), sizeof(unsigned int))) {
+			dev_err(&client->dev, "ioctl, copy to user failed\n");
 			return -EFAULT;
 		}
 		break;
@@ -771,26 +905,25 @@ static int ioctl_si4702(struct inode *inode, struct file *file,
 			error = si4702_write_reg(SI4702_POWERCFG, data);
 		}
 		if (error) {
-			dev_err(&si4702_client->dev,
-				"ioctl, set mute failed\n");
+			dev_err(&client->dev, "ioctl, set mute failed\n");
 			return -EFAULT;
 		}
 		break;
 	case SI4702_SELECT:
 		if (copy_from_user(&freq, argp, sizeof(unsigned int))) {
 
-			dev_err(&si4702_client->dev,
+			dev_err(&client->dev,
 				"ioctl, copy frequence from user failed\n");
 			return -EFAULT;
 		}
 		/* check frequence */
-		if (freq > MAX_BAND || freq < BAND) {
-			dev_err(&si4702_client->dev,
+		if (freq > info->max_band || freq < info->min_band) {
+			dev_err(&client->dev,
 				"the frequence select is out of band\n");
 			return -EINVAL;
 		}
 		if (si4702_channel_select(freq)) {
-			dev_err(&si4702_client->dev,
+			dev_err(&client->dev,
 				"ioctl, failed to select channel\n");
 			return -EFAULT;
 		}
@@ -798,8 +931,7 @@ static int ioctl_si4702(struct inode *inode, struct file *file,
 	case SI4702_SEEK:
 		if (copy_from_user(&dir, argp, sizeof(int))) {
 
-			dev_err(&si4702_client->dev,
-				"ioctl, copy from user failed\n");
+			dev_err(&client->dev, "ioctl, copy from user failed\n");
 			return -EFAULT;
 		}
 		/* get seeked channel */
@@ -811,13 +943,13 @@ static int ioctl_si4702(struct inode *inode, struct file *file,
 		}
 		if (copy_to_user(argp, &dir, sizeof(int))) {
 
-			dev_err(&si4702_client->dev,
+			dev_err(&client->dev,
 				"ioctl, copy seek frequnce to user failed\n");
 			return -EFAULT;
 		}
 		break;
 	default:
-		dev_err(&si4702_client->dev, "SI4702: Invalid ioctl command\n");
+		dev_err(&client->dev, "SI4702: Invalid ioctl command\n");
 		return -EINVAL;
 
 	}
@@ -826,34 +958,31 @@ static int ioctl_si4702(struct inode *inode, struct file *file,
 
 static int open_si4702(struct inode *inode, struct file *file)
 {
+	struct i2c_client *client;
+
+	if (NULL == si4702_drvdata)
+		return -1;
+
+	client = si4702_drvdata->client;
+
 	spin_lock(&count_lock);
-	if (count != 0) {
-		dev_err(&si4702_client->dev, "device has been open already\n");
+	if (si4702_drvdata->count != 0) {
+		dev_err(&client->dev, "device has been open already\n");
 		spin_unlock(&count_lock);
 		return -EBUSY;
 	}
-	count++;
+	si4702_drvdata->count++;
 	spin_unlock(&count_lock);
 
-	/* detect headphone as RF */
-	if (!1) {
-		dev_err(&si4702_client->dev,
-			"Headphone has not been inserted\n");
-		spin_lock(&count_lock);
-		count--;
-		spin_unlock(&count_lock);
-		return -ENODEV;
-	}
-
 	/* request and active GPIO */
-	plat_data->gpio_get();
+	si4702_gpio_get();
 	/* reset the si4702 from it's reset pin */
-	plat_data->reset();
+	si4702_reset();
 
 	/* startup si4702 */
 	if (si4702_startup()) {
 		spin_lock(&count_lock);
-		count--;
+		si4702_drvdata->count--;
 		spin_unlock(&count_lock);
 		return -ENODEV;
 	}
@@ -863,57 +992,218 @@ static int open_si4702(struct inode *inode, struct file *file)
 
 static int release_si4702(struct inode *inode, struct file *file)
 {
-	dev_err(&si4702_client->dev, "release\n");
+	struct i2c_client *client;
+
+	if (NULL == si4702_drvdata)
+		return -1;
+
+	client = si4702_drvdata->client;
+
+	dev_err(&client->dev, "release\n");
 	/* software shutdown */
 	si4702_shutdown();
 	/* inactive, free GPIO, cut power */
-	plat_data->gpio_put();
+	si4702_gpio_put();
 
 	spin_lock(&count_lock);
-	count--;
+	si4702_drvdata->count--;
 	spin_unlock(&count_lock);
 
 	return 0;
 }
 
-#ifdef DEBUG
-static void si4702_dump_reg()
+static int si4702_suspend(struct i2c_client *client, pm_message_t state)
 {
-	int i;
+	return 0;
+}
 
-	for (i = 0; i < SI4702_REG_BYTE; i += 2)
-		printk(KERN_INFO "reg[%02d] = %04x\n", i / 2,
-		       ((reg_rw_buf[i] << 8) & 0xFF00) +
-		       (reg_rw_buf[i + 1] & 0x00FF));
+static int si4702_resume(struct i2c_client *client)
+{
+	return 0;
 }
 
-static void test(void)
+static struct device_attribute si4702_dev_attr = {
+	.attr = {
+		 .name = "si4702_ctl",
+		 .mode = S_IRUSR | S_IWUSR,
+		 },
+	.show = si4702_show,
+	.store = si4702_store,
+};
+
+static struct file_operations si4702_fops = {
+	.owner = THIS_MODULE,
+	.open = open_si4702,
+	.release = release_si4702,
+	.ioctl = ioctl_si4702,
+};
+
+static int __devinit si4702_probe(struct i2c_client *client,
+				  const struct i2c_device_id *id)
 {
-	u16 device_id, power_conf;
+	int ret = 0;
+	struct mxc_fm_platform_data *plat_data;
+	struct si4702_drvdata *drv_data;
+	struct device *dev;
 
-	plat_data->gpio_get();
-	plat_data->reset();
+	dev_info(&client->dev, "si4702 device probe process start.\n");
 
-	si4702_read_reg(SI4702_DEVICEID, &device_id);
-	printk(KERN_INFO "device id %x\n", device_id);
-	si4702_read_reg(SI4702_POWERCFG, &power_conf);
-	printk(KERN_INFO "power config %x\n", power_conf);
-	si4702_dump_reg();
-	si4702_write_reg(SI4702_POWERCFG, 0x01);
-	si4702_dump_reg();
-	si4702_read_reg(SI4702_POWERCFG, &power_conf);
-	printk(KERN_INFO "power config after %x\n", power_conf);
+	plat_data = (struct mxc_fm_platform_data *)client->dev.platform_data;
+	if (plat_data == NULL) {
+		dev_err(&client->dev, "lack of platform data!\n");
+		return -ENODEV;
+	}
 
-	plat_data->gpio_put();
+	drv_data = kmalloc(sizeof(struct si4702_drvdata), GFP_KERNEL);
+	if (drv_data == NULL) {
+		dev_err(&client->dev, "lack of kernel memory!\n");
+		return -ENOMEM;
+	}
+	memset(drv_data, 0, sizeof(struct si4702_drvdata));
+	drv_data->plat_data = plat_data;
+	drv_data->major = DEV_MAJOR;
+	drv_data->minor = DEV_MINOR;
+	drv_data->count = 0;
 
-	si4702_dump_reg();
+	/*enable power supply */
+	if (plat_data->reg_vio != NULL) {
+		drv_data->vio = regulator_get(&client->dev, plat_data->reg_vio);
+		if (drv_data->vio == ERR_PTR(-ENOENT))
+			goto free_drv_data;
+		regulator_enable(drv_data->vio);
+	}
+
+	/* here, we assume that vio and vdd are not the same */
+	if (plat_data->reg_vdd != NULL) {
+		drv_data->vdd = regulator_get(&client->dev, plat_data->reg_vdd);
+		if (drv_data->vdd == ERR_PTR(-ENOENT))
+			goto disable_vio;
+		regulator_enable(drv_data->vdd);
+	}
+
+	/*attach client and check device id */
+	if (SI4702_DEVICE_ID != si4702_id_detect(client)) {
+		dev_err(&client->dev, "id wrong.\n");
+		goto disable_vdd;
+	}
+	dev_info(&client->dev, "chip id %x detect.\n", SI4702_DEVICE_ID);
+	drv_data->client = client;
+
+	/*user interface begain */
+	/*create device file in sysfs as a user interface,
+	 * also for debug support */
+	ret = device_create_file(&client->dev, &si4702_dev_attr);
+	if (ret) {
+		dev_err(&client->dev, "create device file failed!\n");
+		goto gpio_put;	/* shall i use some meanful error code? */
+	}
+
+	/*create a char dev for application code access */
+	if (drv_data->major) {
+		ret = register_chrdev(drv_data->major, "si4702", &si4702_fops);;
+	} else {
+		ret = register_chrdev(0, "si4702", &si4702_fops);
+	}
+
+	if (drv_data->major == 0)
+		drv_data->major = ret;
+
+	/* create class and device for udev information */
+	drv_data->radio_class = class_create(THIS_MODULE, "radio");
+	if (IS_ERR(drv_data->radio_class)) {
+		dev_err(&client->dev, "SI4702: failed to create radio class\n");
+		goto char_dev_remove;
+	}
+
+	dev = device_create(drv_data->radio_class, NULL,
+			    MKDEV(drv_data->major, drv_data->minor), "si4702");
+	if (IS_ERR(dev)) {
+		dev_err(&client->dev,
+			"SI4702: failed to create radio class device\n");
+		goto class_remove;
+	}
+	/*User interface end */
+	dev_set_drvdata(&client->dev, drv_data);
+	si4702_drvdata = drv_data;
+
+	si4702_gpio_get();
+	dev_info(&client->dev, "si4702 device probe successfully.\n");
+	si4702_shutdown();
+
+	return 0;
+
+class_remove:
+	class_destroy(drv_data->radio_class);
+char_dev_remove:
+	unregister_chrdev(drv_data->major, "si4702");
+	device_remove_file(&client->dev, &si4702_dev_attr);
+gpio_put:
+	si4702_gpio_put();
+disable_vdd:
+	if (plat_data->reg_vdd) {
+		regulator_disable(drv_data->vdd);
+		regulator_put(drv_data->vdd, &client->dev);
+	}
+disable_vio:
+	if (plat_data->reg_vio) {
+		regulator_disable(drv_data->vio);
+		regulator_put(drv_data->vio, &client->dev);
+	}
+
+free_drv_data:
+	kfree(drv_data);
+
+	return -ENODEV;
 }
-#endif				/* DEBUG */
+
+static int __devexit si4702_remove(struct i2c_client *client)
+{
+	struct mxc_fm_platform_data *plat_data;
+	struct si4702_drvdata *drv_data = dev_get_drvdata(&client->dev);
+
+	plat_data = (struct mxc_fm_platform_data *)client->dev.platform_data;
+
+	device_destroy(drv_data->radio_class, MKDEV(drv_data->major, 0));
+	class_destroy(drv_data->radio_class);
+
+	unregister_chrdev(drv_data->major, "si4702");
+	device_remove_file(&client->dev, &si4702_dev_attr);
+	si4702_gpio_put();
+
+	if (plat_data->reg_vdd)
+		regulator_put(drv_data->vdd, &client->dev);
+
+	if (plat_data->reg_vio)
+		regulator_put(drv_data->vio, &client->dev);
+
+	kfree(si4702_drvdata);
+	si4702_drvdata = NULL;
+
+	return 0;
+}
+
+static const struct i2c_device_id si4702_id[] = {
+	{"si4702", 0},
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, si4702_id);
+
+static struct i2c_driver i2c_si4702_driver = {
+	.driver = {
+		   .name = "si4702",
+		   },
+	.probe = si4702_probe,
+	.remove = si4702_remove,
+	.suspend = si4702_suspend,
+	.resume = si4702_resume,
+	.id_table = si4702_id,
+};
 
 static int __init init_si4702(void)
 {
 	/*add to i2c driver */
-	printk(KERN_INFO "add si4702 i2c driver\n");
+	pr_info("add si4702 i2c driver\n");
 	return i2c_add_driver(&i2c_si4702_driver);
 }
 
diff --git a/include/asm-arm/arch-mxc/mxc.h b/include/asm-arm/arch-mxc/mxc.h
index 787de3e..33dd015 100644
--- a/include/asm-arm/arch-mxc/mxc.h
+++ b/include/asm-arm/arch-mxc/mxc.h
@@ -222,6 +222,22 @@ struct mxc_fm_platform_data {
 	void (*gpio_put) (void);
 	void (*reset) (void);
 	void (*clock_ctl) (int flag);
+	u8	sksnr; /*0,disable;1,most stop;0xf,fewest stop*/
+	u8	skcnt; /*0,disable;1,most stop;0xf,fewest stop*/
+	/*
+	00 = 87.5-108 MHz (USA,Europe) (Default).
+	01 = 76-108 MHz (Japan wide band).
+	10 = 76-90 MHz (Japan).
+	11 = Reserved.
+	*/
+	u8	band;
+	/*
+	00 = 200 kHz (USA, Australia) (default).
+	01 = 100 kHz (Europe, Japan).
+	10 = 50 kHz.
+	*/
+	u8	space;
+	u8	seekth;
 };
 
 struct mxc_mma7450_platform_data {
-- 
1.5.4.4

