From 9f76503764534db19cd595c93245a9a46e50d088 Mon Sep 17 00:00:00 2001
From: Rob Herring <r.herring@freescale.com>
Date: Fri, 6 Feb 2009 12:59:08 -0600
Subject: [PATCH] ENGR00107392 Move asm/arch headers to linux inc dir

Architecture specific headers moved and are not accessible to userspace in
2.6.28. So they are moved to linux include directory.

Signed-off-by: Rob Herring <r.herring@freescale.com>
---
 arch/arm/mach-mx27/devices.c                       |    4 +-
 arch/arm/mach-mx3/devices.c                        |    6 +-
 arch/arm/mach-mx3/dvfs_v2.c                        |    6 +-
 arch/arm/mach-mx3/mx3_3stack_gpio.c                |    2 +-
 arch/arm/mach-mx35/mx35_3stack.c                   |    2 +-
 arch/arm/mach-mx37/devices.c                       |    2 +-
 arch/arm/mach-mx51/devices.c                       |    2 +-
 arch/arm/mach-mx51/mx51_3stack.c                   |    4 +-
 arch/arm/plat-mxc/utmixc.c                         |    2 +-
 drivers/input/touchscreen/mxc_ts.c                 |    6 +-
 drivers/leds/leds-mc13892.c                        |    5 +-
 drivers/media/video/mxc/capture/ipu_prp_enc.c      |    4 +-
 drivers/media/video/mxc/capture/ipu_prp_vf_sdc.c   |    4 +-
 .../media/video/mxc/capture/ipu_prp_vf_sdc_bg.c    |    6 +-
 drivers/media/video/mxc/capture/ipu_still.c        |    4 +-
 drivers/media/video/mxc/capture/mxc_v4l2_capture.c |    6 +-
 drivers/media/video/mxc/capture/mxc_v4l2_capture.h |    6 +-
 drivers/media/video/mxc/output/mxc_v4l2_output.c   |    9 +-
 drivers/media/video/mxc/output/mxc_v4l2_output.h   |    6 +-
 drivers/mxc/asrc/mxc_asrc.c                        |    4 +-
 drivers/mxc/ipu/ipu_adc.c                          |    6 +-
 drivers/mxc/ipu/ipu_common.c                       |    6 +-
 drivers/mxc/ipu/ipu_csi.c                          |    4 +-
 drivers/mxc/ipu/ipu_device.c                       |    6 +-
 drivers/mxc/ipu/ipu_ic.c                           |    6 +-
 drivers/mxc/ipu/ipu_sdc.c                          |    6 +-
 drivers/mxc/ipu/pf/mxc_pf.c                        |    6 +-
 drivers/mxc/ipu3/ipu_capture.c                     |    6 +-
 drivers/mxc/ipu3/ipu_common.c                      |    6 +-
 drivers/mxc/ipu3/ipu_device.c                      |    6 +-
 drivers/mxc/ipu3/ipu_disp.c                        |    4 +-
 drivers/mxc/ipu3/ipu_ic.c                          |    4 +-
 drivers/mxc/mcu_pmic/mcu_pmic_gpio.c               |    6 +-
 drivers/mxc/mlb/mxc_mlb.c                          |    4 +-
 drivers/mxc/pmic/core/mc13783.c                    |    7 +-
 drivers/mxc/pmic/core/mc13892.c                    |    5 +-
 drivers/mxc/pmic/core/mc34704.c                    |    9 +-
 drivers/mxc/pmic/core/pmic-dev.c                   |    4 +-
 drivers/mxc/pmic/core/pmic_core_i2c.c              |    5 +-
 drivers/mxc/pmic/core/pmic_core_spi.c              |    7 +-
 drivers/mxc/pmic/core/pmic_event.c                 |    6 +-
 drivers/mxc/pmic/core/pmic_external.c              |    8 +-
 drivers/mxc/pmic/mc13783/pmic_adc.c                |    6 +-
 drivers/mxc/pmic/mc13783/pmic_audio.c              |    6 +-
 drivers/mxc/pmic/mc13783/pmic_battery.c            |    8 +-
 drivers/mxc/pmic/mc13783/pmic_convity.c            |    6 +-
 drivers/mxc/pmic/mc13783/pmic_light.c              |    6 +-
 drivers/mxc/pmic/mc13783/pmic_power.c              |    6 +-
 drivers/mxc/pmic/mc13783/pmic_rtc.c                |    6 +-
 drivers/mxc/pmic/mc13892/pmic_adc.c                |    6 +-
 drivers/mxc/pmic/mc13892/pmic_light.c              |    4 +-
 drivers/mxc/security/mxc_scc_internals.h           |    4 +-
 drivers/mxc/security/rng/fsl_shw_sym.c             |    2 +-
 drivers/mxc/security/rng/fsl_shw_wrap.c            |    2 +-
 drivers/mxc/security/rng/rng_driver.c              |    4 +-
 drivers/mxc/security/rng/shw_driver.c              |    4 +-
 drivers/mxc/security/sahara2/fsl_shw_keystore.c    |    2 +-
 drivers/mxc/security/sahara2/km_adaptor.c          |    4 +-
 .../mxc/security/sahara2/sah_driver_interface.c    |    4 +-
 drivers/mxc/security/sahara2/sah_memory_mapper.c   |    6 +-
 drivers/mxc/security/scc2_internals.h              |    6 +-
 drivers/regulator/max8660/reg-max8660.c            |    6 +-
 drivers/regulator/mc13783/reg-mc13783.c            |    8 +-
 drivers/regulator/mc13892/reg-mc13892.c            |    6 +-
 drivers/regulator/mc34704/reg-mc34704.c            |    6 +-
 drivers/regulator/mc9sdz60/reg-mc9sdz60.c          |    6 +-
 drivers/rtc/rtc-mc13892.c                          |    6 +-
 drivers/rtc/rtc-mxc.c                              |    4 +-
 drivers/video/backlight/mxc_ipu_bl.c               |    5 +-
 drivers/video/backlight/mxc_mc13892_bl.c           |    2 +-
 drivers/video/backlight/mxc_pmic_bl.c              |    4 +-
 drivers/video/mxc/ch7024.c                         |    4 +-
 drivers/video/mxc/mx2fb.c                          |    4 +-
 drivers/video/mxc/mxc_ipuv3_fb.c                   |    8 +-
 drivers/video/mxc/mxcfb.c                          |    8 +-
 drivers/video/mxc/mxcfb_claa_wvga.c                |    4 +-
 drivers/video/mxc/mxcfb_epson_vga.c                |    6 +-
 drivers/video/mxc/mxcfb_modedb.c                   |    4 +-
 drivers/video/mxc/tve.c                            |    4 +-
 include/asm-arm/arch-mxc/ipu.h                     | 1162 --------------------
 include/asm-arm/arch-mxc/mxc_asrc.h                |  198 ----
 include/asm-arm/arch-mxc/mxc_mlb.h                 |   51 -
 include/asm-arm/arch-mxc/mxc_pf.h                  |  125 ---
 include/asm-arm/arch-mxc/mxc_scc2_driver.h         |  973 ----------------
 include/asm-arm/arch-mxc/mxc_scc_driver.h          | 1031 -----------------
 include/asm-arm/arch-mxc/mxc_v4l2.h                |   42 -
 include/asm-arm/arch-mxc/mxcfb.h                   |   75 --
 include/asm-arm/arch-mxc/pmic_adc.h                |  455 --------
 include/asm-arm/arch-mxc/pmic_audio.h              |    6 +-
 include/asm-arm/arch-mxc/pmic_battery.h            |  419 -------
 include/asm-arm/arch-mxc/pmic_convity.h            |    6 +-
 include/asm-arm/arch-mxc/pmic_external.h           | 1131 -------------------
 include/asm-arm/arch-mxc/pmic_light.h              | 1082 ------------------
 include/asm-arm/arch-mxc/pmic_power.h              |    8 +-
 include/asm-arm/arch-mxc/pmic_rtc.h                |  153 ---
 include/asm-arm/arch-mxc/pmic_status.h             |   82 --
 include/linux/ipu.h                                | 1162 ++++++++++++++++++++
 include/linux/mxc_asrc.h                           |  198 ++++
 include/linux/mxc_mlb.h                            |   51 +
 include/linux/mxc_pf.h                             |  125 +++
 include/linux/mxc_scc2_driver.h                    |  973 ++++++++++++++++
 include/linux/mxc_scc_driver.h                     | 1031 +++++++++++++++++
 include/linux/mxc_v4l2.h                           |   42 +
 include/linux/mxcfb.h                              |   75 ++
 include/linux/pmic_adc.h                           |  455 ++++++++
 include/linux/pmic_battery.h                       |  419 +++++++
 include/linux/pmic_external.h                      | 1131 +++++++++++++++++++
 include/linux/pmic_light.h                         | 1082 ++++++++++++++++++
 include/linux/pmic_rtc.h                           |  153 +++
 include/linux/pmic_status.h                        |   82 ++
 sound/arm/mxc-alsa-pmic.c                          |   21 +-
 sound/soc/imx/imx-3stack-bt.c                      |    5 +-
 112 files changed, 7197 insertions(+), 7211 deletions(-)

diff --git a/arch/arm/mach-mx27/devices.c b/arch/arm/mach-mx27/devices.c
index 2e1387b..f430bed 100644
--- a/arch/arm/mach-mx27/devices.c
+++ b/arch/arm/mach-mx27/devices.c
@@ -9,18 +9,18 @@
  * licensed "as is" without any warranty of any kind, whether express
  * or implied.
  *
- * Copyright 2006-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2006-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/platform_device.h>
 #include <linux/clk.h>
+#include <linux/pmic_external.h>
 
 #include <linux/spi/spi.h>
 
 #include <asm/hardware.h>
-#include <asm/arch/pmic_external.h>
 #include <asm/arch/pmic_power.h>
 #include <asm/arch/mmc.h>
 #include <asm/arch/mxc_dptc.h>
diff --git a/arch/arm/mach-mx3/devices.c b/arch/arm/mach-mx3/devices.c
index 45119b3..ee1f8ff 100644
--- a/arch/arm/mach-mx3/devices.c
+++ b/arch/arm/mach-mx3/devices.c
@@ -9,23 +9,23 @@
  * licensed "as is" without any warranty of any kind, whether express
  * or implied.
  *
- * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/platform_device.h>
 #include <linux/clk.h>
+#include <linux/pmic_external.h>
 
 #include <linux/spi/spi.h>
 
 #include <asm/hardware.h>
 #include <asm/mach-types.h>
-#include <asm/arch/pmic_external.h>
-#include <asm/arch/pmic_power.h>
 
 #include <asm/arch/spba.h>
 #include <asm/arch/mxc_dptc.h>
+#include <asm/arch/pmic_power.h>
 #include "iomux.h"
 #include "crm_regs.h"
 #include <asm/arch/sdma.h>
diff --git a/arch/arm/mach-mx3/dvfs_v2.c b/arch/arm/mach-mx3/dvfs_v2.c
index 027aa11..d7e1753 100644
--- a/arch/arm/mach-mx3/dvfs_v2.c
+++ b/arch/arm/mach-mx3/dvfs_v2.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2007-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2007-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -35,9 +35,7 @@
 #include <linux/sysdev.h>
 #include <linux/delay.h>
 #include <linux/clk.h>
-
-#include <asm/arch/gpio.h>
-#include <asm/arch/pmic_external.h>
+#include <linux/pmic_external.h>
 #include <asm/arch/pmic_power.h>
 
 #include "iomux.h"
diff --git a/arch/arm/mach-mx3/mx3_3stack_gpio.c b/arch/arm/mach-mx3/mx3_3stack_gpio.c
index 2d1014e..76b82ab 100644
--- a/arch/arm/mach-mx3/mx3_3stack_gpio.c
+++ b/arch/arm/mach-mx3/mx3_3stack_gpio.c
@@ -16,10 +16,10 @@
 #include <linux/platform_device.h>
 #include <linux/delay.h>
 #include <linux/irq.h>
+#include <linux/pmic_adc.h>
 #include <asm/io.h>
 #include <asm/hardware.h>
 #include <asm/arch/gpio.h>
-#include <asm/arch/pmic_adc.h>
 #include "board-mx3_3stack.h"
 #include "iomux.h"
 
diff --git a/arch/arm/mach-mx35/mx35_3stack.c b/arch/arm/mach-mx35/mx35_3stack.c
index e542ed9..bec5bca 100644
--- a/arch/arm/mach-mx35/mx35_3stack.c
+++ b/arch/arm/mach-mx35/mx35_3stack.c
@@ -23,6 +23,7 @@
 #include <linux/platform_device.h>
 #include <linux/fsl_devices.h>
 #include <linux/ata.h>
+#include <linux/pmic_external.h>
 #if defined(CONFIG_MTD) || defined(CONFIG_MTD_MODULE)
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/map.h>
@@ -43,7 +44,6 @@
 #include <asm/arch/memory.h>
 #include <asm/arch/gpio.h>
 #include <asm/arch/mmc.h>
-#include <asm/arch/pmic_external.h>
 
 #include "board-mx35_3stack.h"
 #include "crm_regs.h"
diff --git a/arch/arm/mach-mx37/devices.c b/arch/arm/mach-mx37/devices.c
index 0325abf..a0e0c27 100644
--- a/arch/arm/mach-mx37/devices.c
+++ b/arch/arm/mach-mx37/devices.c
@@ -16,6 +16,7 @@
 #include <linux/init.h>
 #include <linux/platform_device.h>
 #include <linux/clk.h>
+#include <linux/mxc_scc2_driver.h>
 
 #include <linux/spi/spi.h>
 
@@ -26,7 +27,6 @@
 #include "iomux.h"
 #include <asm/arch/sdma.h>
 #include "sdma_script_code.h"
-#include <asm/arch/mxc_scc2_driver.h>
 #include "crm_regs.h"
 
 extern struct dptc_wp dptc_gp_wp_allfreq[DPTC_GP_WP_SUPPORTED];
diff --git a/arch/arm/mach-mx51/devices.c b/arch/arm/mach-mx51/devices.c
index 07beb89..3e3993a 100644
--- a/arch/arm/mach-mx51/devices.c
+++ b/arch/arm/mach-mx51/devices.c
@@ -19,13 +19,13 @@
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/spi/spi.h>
+#include <linux/mxc_scc2_driver.h>
 #include <asm/hardware.h>
 #include <asm/arch/spba.h>
 #include "iomux.h"
 #include "crm_regs.h"
 #include <asm/arch/sdma.h>
 #include "sdma_script_code.h"
-#include <asm/arch/mxc_scc2_driver.h>
 
 /* Flag used to indicate when IRAM has been initialized */
 int iram_ready;
diff --git a/arch/arm/mach-mx51/mx51_3stack.c b/arch/arm/mach-mx51/mx51_3stack.c
index 340f44e..c77edd1 100644
--- a/arch/arm/mach-mx51/mx51_3stack.c
+++ b/arch/arm/mach-mx51/mx51_3stack.c
@@ -26,6 +26,8 @@
 #include <linux/spi/spi.h>
 #include <linux/i2c.h>
 #include <linux/ata.h>
+#include <linux/pmic_external.h>
+#include <linux/ipu.h>
 #if defined(CONFIG_MTD) || defined(CONFIG_MTD_MODULE)
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/map.h>
@@ -44,8 +46,6 @@
 #include <asm/arch/memory.h>
 #include <asm/arch/gpio.h>
 #include <asm/arch/mmc.h>
-#include <asm/arch/pmic_external.h>
-#include <asm/arch/ipu.h>
 
 #include "board-mx51_3stack.h"
 #include "iomux.h"
diff --git a/arch/arm/plat-mxc/utmixc.c b/arch/arm/plat-mxc/utmixc.c
index 16da8e1..99d7796 100644
--- a/arch/arm/plat-mxc/utmixc.c
+++ b/arch/arm/plat-mxc/utmixc.c
@@ -21,11 +21,11 @@
 #include <linux/platform_device.h>
 #include <linux/fsl_devices.h>
 #include <linux/usb/fsl_xcvr.h>
+#include <linux/pmic_external.h>
 
 #include <asm/hardware.h>
 #include <asm/arch/arc_otg.h>
 #include <asm/mach-types.h>
-#include <asm/arch/pmic_external.h>
 
 static void usb_utmi_init(struct fsl_xcvr_ops *this)
 {
diff --git a/drivers/input/touchscreen/mxc_ts.c b/drivers/input/touchscreen/mxc_ts.c
index 6f1c510..b354d81 100644
--- a/drivers/input/touchscreen/mxc_ts.c
+++ b/drivers/input/touchscreen/mxc_ts.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2007-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2007-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -33,8 +33,8 @@
 #include <linux/init.h>
 #include <linux/delay.h>
 #include <linux/freezer.h>
-#include <asm/arch/pmic_external.h>
-#include <asm/arch/pmic_adc.h>
+#include <linux/pmic_external.h>
+#include <linux/pmic_adc.h>
 
 #define MXC_TS_NAME	"mxc_ts"
 
diff --git a/drivers/leds/leds-mc13892.c b/drivers/leds/leds-mc13892.c
index c277f1f..9edd204 100644
--- a/drivers/leds/leds-mc13892.c
+++ b/drivers/leds/leds-mc13892.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -15,8 +15,7 @@
 #include <linux/init.h>
 #include <linux/platform_device.h>
 #include <linux/leds.h>
-
-#include <asm/arch/pmic_light.h>
+#include <linux/pmic_light.h>
 
 static void mc13892_led_set(struct led_classdev *led_cdev,
 			    enum led_brightness value)
diff --git a/drivers/media/video/mxc/capture/ipu_prp_enc.c b/drivers/media/video/mxc/capture/ipu_prp_enc.c
index fb1d019..79eb8a6 100644
--- a/drivers/media/video/mxc/capture/ipu_prp_enc.c
+++ b/drivers/media/video/mxc/capture/ipu_prp_enc.c
@@ -19,10 +19,10 @@
  * @ingroup IPU
  */
 
+#include <linux/dma-mapping.h>
+#include <linux/ipu.h>
 #include "mxc_v4l2_capture.h"
-#include <asm/arch/ipu.h>
 #include "ipu_prp_sw.h"
-#include <linux/dma-mapping.h>
 
 #ifdef CAMERA_DBG
 	#define CAMERA_TRACE(x) (printk)x
diff --git a/drivers/media/video/mxc/capture/ipu_prp_vf_sdc.c b/drivers/media/video/mxc/capture/ipu_prp_vf_sdc.c
index 6c67bfc..6c2596f 100644
--- a/drivers/media/video/mxc/capture/ipu_prp_vf_sdc.c
+++ b/drivers/media/video/mxc/capture/ipu_prp_vf_sdc.c
@@ -19,10 +19,10 @@
  * @ingroup IPU
  */
 
+#include <linux/dma-mapping.h>
+#include <linux/ipu.h>
 #include "mxc_v4l2_capture.h"
-#include <asm/arch/ipu.h>
 #include "ipu_prp_sw.h"
-#include <linux/dma-mapping.h>
 
 /*
  * Function definitions
diff --git a/drivers/media/video/mxc/capture/ipu_prp_vf_sdc_bg.c b/drivers/media/video/mxc/capture/ipu_prp_vf_sdc_bg.c
index 59b1f40..f23565b 100644
--- a/drivers/media/video/mxc/capture/ipu_prp_vf_sdc_bg.c
+++ b/drivers/media/video/mxc/capture/ipu_prp_vf_sdc_bg.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -18,11 +18,11 @@
  *
  * @ingroup IPU
  */
+#include <linux/dma-mapping.h>
 #include <linux/fb.h>
+#include <linux/ipu.h>
 #include "mxc_v4l2_capture.h"
-#include <asm/arch/ipu.h>
 #include "ipu_prp_sw.h"
-#include <linux/dma-mapping.h>
 
 static int buffer_num = 0;
 static int buffer_ready = 0;
diff --git a/drivers/media/video/mxc/capture/ipu_still.c b/drivers/media/video/mxc/capture/ipu_still.c
index 101e3bf..af6bb59 100644
--- a/drivers/media/video/mxc/capture/ipu_still.c
+++ b/drivers/media/video/mxc/capture/ipu_still.c
@@ -19,9 +19,9 @@
  * @ingroup IPU
  */
 
-#include <asm/semaphore.h>
+#include <linux/ipu.h>
+#include <linux/semaphore.h>
 #include "mxc_v4l2_capture.h"
-#include <asm/arch/ipu.h>
 #include "ipu_prp_sw.h"
 
 static int callback_eof_flag;
diff --git a/drivers/media/video/mxc/capture/mxc_v4l2_capture.c b/drivers/media/video/mxc/capture/mxc_v4l2_capture.c
index 146fa2f..2ffb7be 100644
--- a/drivers/media/video/mxc/capture/mxc_v4l2_capture.c
+++ b/drivers/media/video/mxc/capture/mxc_v4l2_capture.c
@@ -25,15 +25,15 @@
 #include <linux/fs.h>
 #include <linux/slab.h>
 #include <linux/ctype.h>
-#include <asm/io.h>
-#include <asm/semaphore.h>
+#include <linux/io.h>
+#include <linux/semaphore.h>
 #include <linux/pagemap.h>
 #include <linux/vmalloc.h>
 #include <linux/types.h>
 #include <linux/fb.h>
 #include <linux/dma-mapping.h>
+#include <linux/mxcfb.h>
 #include <media/v4l2-int-device.h>
-#include <asm/arch/mxcfb.h>
 #include "mxc_v4l2_capture.h"
 #include "ipu_prp_sw.h"
 
diff --git a/drivers/media/video/mxc/capture/mxc_v4l2_capture.h b/drivers/media/video/mxc/capture/mxc_v4l2_capture.h
index 2c7c549..4fac4ee 100644
--- a/drivers/media/video/mxc/capture/mxc_v4l2_capture.h
+++ b/drivers/media/video/mxc/capture/mxc_v4l2_capture.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -32,8 +32,8 @@
 #include <linux/smp_lock.h>
 
 #include <media/v4l2-dev.h>
-#include <asm/arch/ipu.h>
-#include <asm/arch/mxc_v4l2.h>
+#include <linux/ipu.h>
+#include <linux/mxc_v4l2.h>
 
 #define FRAME_NUM 3
 
diff --git a/drivers/media/video/mxc/output/mxc_v4l2_output.c b/drivers/media/video/mxc/output/mxc_v4l2_output.c
index 2fc0623..d17bef4 100644
--- a/drivers/media/video/mxc/output/mxc_v4l2_output.c
+++ b/drivers/media/video/mxc/output/mxc_v4l2_output.c
@@ -22,16 +22,17 @@
  */
 #include <linux/module.h>
 #include <linux/init.h>
+#include <linux/io.h>
+#include <linux/semaphore.h>
 #include <linux/console.h>
 #include <linux/fs.h>
 #include <linux/delay.h>
 #include <linux/platform_device.h>
-#include <asm/cacheflush.h>
-#include <asm/io.h>
-#include <asm/semaphore.h>
 #include <linux/dma-mapping.h>
+#include <linux/mxcfb.h>
+
+#include <asm/cacheflush.h>
 
-#include <asm/arch/mxcfb.h>
 #include "mxc_v4l2_output.h"
 
 vout_data *g_vout;
diff --git a/drivers/media/video/mxc/output/mxc_v4l2_output.h b/drivers/media/video/mxc/output/mxc_v4l2_output.h
index a514989..27e5a0a 100644
--- a/drivers/media/video/mxc/output/mxc_v4l2_output.h
+++ b/drivers/media/video/mxc/output/mxc_v4l2_output.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -30,8 +30,8 @@
 
 #ifdef __KERNEL__
 
-#include <asm/arch/ipu.h>
-#include <asm/arch/mxc_v4l2.h>
+#include <linux/ipu.h>
+#include <linux/mxc_v4l2.h>
 
 #define MIN_FRAME_NUM 2
 #define MAX_FRAME_NUM 30
diff --git a/drivers/mxc/asrc/mxc_asrc.c b/drivers/mxc/asrc/mxc_asrc.c
index 0e37721..8853fda 100644
--- a/drivers/mxc/asrc/mxc_asrc.c
+++ b/drivers/mxc/asrc/mxc_asrc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -34,10 +34,10 @@
 #include <linux/interrupt.h>
 #include <linux/proc_fs.h>
 #include <linux/dma-mapping.h>
+#include <linux/mxc_asrc.h>
 #include <asm/irq.h>
 #include <asm/memory.h>
 #include <asm/arch/dma.h>
-#include <asm/arch/mxc_asrc.h>
 
 static int asrc_major;
 static struct class *asrc_class;
diff --git a/drivers/mxc/ipu/ipu_adc.c b/drivers/mxc/ipu/ipu_adc.c
index 1b2911d..a66087d 100644
--- a/drivers/mxc/ipu/ipu_adc.c
+++ b/drivers/mxc/ipu/ipu_adc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -24,8 +24,8 @@
 #include <linux/errno.h>
 #include <linux/spinlock.h>
 #include <linux/delay.h>
-#include <asm/io.h>
-#include <asm/arch/ipu.h>
+#include <linux/io.h>
+#include <linux/ipu.h>
 
 #include "ipu_prv.h"
 #include "ipu_regs.h"
diff --git a/drivers/mxc/ipu/ipu_common.c b/drivers/mxc/ipu/ipu_common.c
index f083a34..555e045 100644
--- a/drivers/mxc/ipu/ipu_common.c
+++ b/drivers/mxc/ipu/ipu_common.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -26,8 +26,8 @@
 #include <linux/spinlock.h>
 #include <linux/delay.h>
 #include <linux/clk.h>
-#include <asm/io.h>
-#include <asm/arch/ipu.h>
+#include <linux/io.h>
+#include <linux/ipu.h>
 
 #include "ipu_prv.h"
 #include "ipu_regs.h"
diff --git a/drivers/mxc/ipu/ipu_csi.c b/drivers/mxc/ipu/ipu_csi.c
index e9f0549..74f5bd9 100644
--- a/drivers/mxc/ipu/ipu_csi.c
+++ b/drivers/mxc/ipu/ipu_csi.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -23,7 +23,7 @@
 #include <linux/errno.h>
 #include <linux/spinlock.h>
 #include <linux/delay.h>
-#include <asm/arch/ipu.h>
+#include <linux/ipu.h>
 
 #include "ipu_prv.h"
 #include "ipu_regs.h"
diff --git a/drivers/mxc/ipu/ipu_device.c b/drivers/mxc/ipu/ipu_device.c
index 51a4547..3c6ca0f 100644
--- a/drivers/mxc/ipu/ipu_device.c
+++ b/drivers/mxc/ipu/ipu_device.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -31,8 +31,8 @@
 #include <linux/time.h>
 #include <linux/wait.h>
 #include <linux/dma-mapping.h>
-#include <asm/io.h>
-#include <asm/arch/ipu.h>
+#include <linux/io.h>
+#include <linux/ipu.h>
 
 #include "ipu_prv.h"
 #include "ipu_regs.h"
diff --git a/drivers/mxc/ipu/ipu_ic.c b/drivers/mxc/ipu/ipu_ic.c
index 70f4108..cdf823a 100644
--- a/drivers/mxc/ipu/ipu_ic.c
+++ b/drivers/mxc/ipu/ipu_ic.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -22,8 +22,8 @@
 #include <linux/init.h>
 #include <linux/errno.h>
 #include <linux/spinlock.h>
-#include <asm/io.h>
-#include <asm/arch/ipu.h>
+#include <linux/io.h>
+#include <linux/ipu.h>
 
 #include "ipu_prv.h"
 #include "ipu_regs.h"
diff --git a/drivers/mxc/ipu/ipu_sdc.c b/drivers/mxc/ipu/ipu_sdc.c
index b552611..a36eb6d 100644
--- a/drivers/mxc/ipu/ipu_sdc.c
+++ b/drivers/mxc/ipu/ipu_sdc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -21,8 +21,8 @@
 #include <linux/types.h>
 #include <linux/errno.h>
 #include <linux/spinlock.h>
-#include <asm/io.h>
-#include <asm/arch/ipu.h>
+#include <linux/io.h>
+#include <linux/ipu.h>
 #include "ipu_prv.h"
 #include "ipu_regs.h"
 #include "ipu_param_mem.h"
diff --git a/drivers/mxc/ipu/pf/mxc_pf.c b/drivers/mxc/ipu/pf/mxc_pf.c
index d796a4c..241149b 100644
--- a/drivers/mxc/ipu/pf/mxc_pf.c
+++ b/drivers/mxc/ipu/pf/mxc_pf.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -29,8 +29,8 @@
 #include <linux/poll.h>
 #include <linux/delay.h>
 #include <linux/dma-mapping.h>
-#include <asm/arch/ipu.h>
-#include <asm/arch/mxc_pf.h>
+#include <linux/ipu.h>
+#include <linux/mxc_pf.h>
 
 struct mxc_pf_data {
 	pf_operation_t mode;
diff --git a/drivers/mxc/ipu3/ipu_capture.c b/drivers/mxc/ipu3/ipu_capture.c
index efc3fa4..f520a96 100755
--- a/drivers/mxc/ipu3/ipu_capture.c
+++ b/drivers/mxc/ipu3/ipu_capture.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -23,8 +23,8 @@
 #include <linux/errno.h>
 #include <linux/spinlock.h>
 #include <linux/delay.h>
-#include <asm/arch/ipu.h>
-#include <asm/arch/clock.h>
+#include <linux/ipu.h>
+#include <linux/clk.h>
 
 #include "ipu_prv.h"
 #include "ipu_regs.h"
diff --git a/drivers/mxc/ipu3/ipu_common.c b/drivers/mxc/ipu3/ipu_common.c
index 072d624..a6e5c99 100644
--- a/drivers/mxc/ipu3/ipu_common.c
+++ b/drivers/mxc/ipu3/ipu_common.c
@@ -25,9 +25,9 @@
 #include <linux/spinlock.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
-#include <asm/io.h>
-#include <asm/arch/ipu.h>
-#include <asm/arch/clock.h>
+#include <linux/io.h>
+#include <linux/ipu.h>
+#include <linux/clk.h>
 
 #include "ipu_prv.h"
 #include "ipu_regs.h"
diff --git a/drivers/mxc/ipu3/ipu_device.c b/drivers/mxc/ipu3/ipu_device.c
index ddaaf15..04756ae 100644
--- a/drivers/mxc/ipu3/ipu_device.c
+++ b/drivers/mxc/ipu3/ipu_device.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -31,9 +31,9 @@
 #include <linux/time.h>
 #include <linux/wait.h>
 #include <linux/dma-mapping.h>
-#include <asm/io.h>
+#include <linux/io.h>
+#include <linux/ipu.h>
 #include <asm/cacheflush.h>
-#include <asm/arch/ipu.h>
 
 #include "ipu_prv.h"
 #include "ipu_regs.h"
diff --git a/drivers/mxc/ipu3/ipu_disp.c b/drivers/mxc/ipu3/ipu_disp.c
index 61558a4..c652fb2 100644
--- a/drivers/mxc/ipu3/ipu_disp.c
+++ b/drivers/mxc/ipu3/ipu_disp.c
@@ -22,9 +22,9 @@
 #include <linux/errno.h>
 #include <linux/delay.h>
 #include <linux/spinlock.h>
+#include <linux/io.h>
+#include <linux/ipu.h>
 #include <asm/atomic.h>
-#include <asm/io.h>
-#include <asm/arch/ipu.h>
 #include "ipu_prv.h"
 #include "ipu_regs.h"
 #include "ipu_param_mem.h"
diff --git a/drivers/mxc/ipu3/ipu_ic.c b/drivers/mxc/ipu3/ipu_ic.c
index f43b920..7191f75 100644
--- a/drivers/mxc/ipu3/ipu_ic.c
+++ b/drivers/mxc/ipu3/ipu_ic.c
@@ -22,8 +22,8 @@
 #include <linux/init.h>
 #include <linux/errno.h>
 #include <linux/spinlock.h>
-#include <asm/io.h>
-#include <asm/arch/ipu.h>
+#include <linux/io.h>
+#include <linux/ipu.h>
 
 #include "ipu_prv.h"
 #include "ipu_regs.h"
diff --git a/drivers/mxc/mcu_pmic/mcu_pmic_gpio.c b/drivers/mxc/mcu_pmic/mcu_pmic_gpio.c
index 69718ac..037fc25 100644
--- a/drivers/mxc/mcu_pmic/mcu_pmic_gpio.c
+++ b/drivers/mxc/mcu_pmic/mcu_pmic_gpio.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -23,8 +23,8 @@
  */
 #include <linux/platform_device.h>
 #include <linux/regulator/mcu_max8660-bus.h>
-#include <asm/arch-mxc/pmic_status.h>
-#include <asm/ioctl.h>
+#include <linux/pmic_status.h>
+#include <linux/ioctl.h>
 
 #define SET_BIT_IN_BYTE(byte, pos) (byte |= (0x01 << pos))
 #define CLEAR_BIT_IN_BYTE(byte, pos) (byte &= ~(0x01 << pos))
diff --git a/drivers/mxc/mlb/mxc_mlb.c b/drivers/mxc/mlb/mxc_mlb.c
index a10e87b..31a3cc1 100644
--- a/drivers/mxc/mlb/mxc_mlb.c
+++ b/drivers/mxc/mlb/mxc_mlb.c
@@ -1,7 +1,7 @@
 /*
  * linux/drivers/mxc/mlb/mxc_mlb.c
  *
- * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -24,10 +24,10 @@
 #include <linux/interrupt.h>
 #include <linux/platform_device.h>
 #include <linux/regulator/regulator.h>
+#include <linux/mxc_mlb.h>
 
 #include <asm/irq.h>
 #include <asm/uaccess.h>
-#include <asm/arch/mxc_mlb.h>
 
 /*!
  * MLB module memory map registers define
diff --git a/drivers/mxc/pmic/core/mc13783.c b/drivers/mxc/pmic/core/mc13783.c
index 64ec266..dbd904d 100644
--- a/drivers/mxc/pmic/core/mc13783.c
+++ b/drivers/mxc/pmic/core/mc13783.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -27,12 +27,11 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/device.h>
+#include <linux/pmic_external.h>
+#include <linux/pmic_status.h>
 #include <linux/spi/spi.h>
 
 #include <asm/uaccess.h>
-#include <asm/arch/gpio.h>
-#include <asm/arch/pmic_external.h>
-#include <asm/arch/pmic_status.h>
 
 #include "pmic.h"
 
diff --git a/drivers/mxc/pmic/core/mc13892.c b/drivers/mxc/pmic/core/mc13892.c
index f5c2fae..44ae3de 100644
--- a/drivers/mxc/pmic/core/mc13892.c
+++ b/drivers/mxc/pmic/core/mc13892.c
@@ -30,12 +30,11 @@
 #include <linux/spi/spi.h>
 #include <linux/i2c.h>
 #include <linux/delay.h>
+#include <linux/pmic_external.h>
+#include <linux/pmic_status.h>
 
 #include <asm/mach-types.h>
 #include <asm/uaccess.h>
-#include <asm/arch/gpio.h>
-#include <asm/arch/pmic_external.h>
-#include <asm/arch/pmic_status.h>
 
 #include "pmic.h"
 
diff --git a/drivers/mxc/pmic/core/mc34704.c b/drivers/mxc/pmic/core/mc34704.c
index b695775..b6b18ad 100644
--- a/drivers/mxc/pmic/core/mc34704.c
+++ b/drivers/mxc/pmic/core/mc34704.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -29,11 +29,8 @@
 #include <linux/interrupt.h>
 #include <linux/i2c.h>
 #include <linux/uaccess.h>
-
-#include <asm/mach-types.h>
-#include <asm/arch/gpio.h>
-#include <asm/arch/pmic_external.h>
-#include <asm/arch/pmic_status.h>
+#include <linux/pmic_external.h>
+#include <linux/pmic_status.h>
 
 #include "pmic.h"
 
diff --git a/drivers/mxc/pmic/core/pmic-dev.c b/drivers/mxc/pmic/core/pmic-dev.c
index ea4477c..2b91d04 100644
--- a/drivers/mxc/pmic/core/pmic-dev.c
+++ b/drivers/mxc/pmic/core/pmic-dev.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -31,9 +31,9 @@
 #include <linux/major.h>
 #include <linux/init.h>
 #include <linux/fs.h>
+#include <linux/pmic_external.h>
 
 #include <asm/uaccess.h>
-#include <asm/arch/pmic_external.h>
 
 #define PMIC_NAME	"pmic"
 #define CIRC_BUF_MAX	16
diff --git a/drivers/mxc/pmic/core/pmic_core_i2c.c b/drivers/mxc/pmic/core/pmic_core_i2c.c
index a1e88ab..134254d 100644
--- a/drivers/mxc/pmic/core/pmic_core_i2c.c
+++ b/drivers/mxc/pmic/core/pmic_core_i2c.c
@@ -31,12 +31,11 @@
 #include <linux/interrupt.h>
 #include <linux/irq.h>
 #include <linux/i2c.h>
+#include <linux/pmic_external.h>
+#include <linux/pmic_status.h>
 
 #include <asm/uaccess.h>
-#include <asm/arch/gpio.h>
 
-#include <asm/arch/pmic_external.h>
-#include <asm/arch/pmic_status.h>
 #include "pmic.h"
 
 #define MC13892_GENERATION_ID_LSH	6
diff --git a/drivers/mxc/pmic/core/pmic_core_spi.c b/drivers/mxc/pmic/core/pmic_core_spi.c
index 3e7b986..724c401 100644
--- a/drivers/mxc/pmic/core/pmic_core_spi.c
+++ b/drivers/mxc/pmic/core/pmic_core_spi.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -31,12 +31,11 @@
 #include <linux/interrupt.h>
 #include <linux/irq.h>
 #include <linux/spi/spi.h>
+#include <linux/pmic_external.h>
+#include <linux/pmic_status.h>
 
 #include <asm/uaccess.h>
-#include <asm/arch/gpio.h>
 
-#include <asm/arch/pmic_external.h>
-#include <asm/arch/pmic_status.h>
 #include "pmic.h"
 
 /*
diff --git a/drivers/mxc/pmic/core/pmic_event.c b/drivers/mxc/pmic/core/pmic_event.c
index e224b4c..1c664b4 100644
--- a/drivers/mxc/pmic/core/pmic_event.c
+++ b/drivers/mxc/pmic/core/pmic_event.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -32,10 +32,10 @@
 #include <linux/errno.h>
 #include <linux/interrupt.h>
 #include <linux/list.h>
+#include <linux/pmic_external.h>
+#include <linux/pmic_status.h>
 
 #include <asm/uaccess.h>
-#include <asm/arch/pmic_external.h>
-#include <asm/arch/pmic_status.h>
 #include "pmic.h"
 
 /*!
diff --git a/drivers/mxc/pmic/core/pmic_external.c b/drivers/mxc/pmic/core/pmic_external.c
index cbeada3..57a10a1 100644
--- a/drivers/mxc/pmic/core/pmic_external.c
+++ b/drivers/mxc/pmic/core/pmic_external.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -26,12 +26,12 @@
 #include <linux/wait.h>
 #include <linux/init.h>
 #include <linux/errno.h>
-#include <asm/io.h>
+#include <linux/io.h>
+#include <linux/pmic_external.h>
+#include <linux/pmic_status.h>
 #include <asm/irq.h>
 #include <asm/uaccess.h>
 
-#include <asm/arch/pmic_external.h>
-#include <asm/arch/pmic_status.h>
 
 /*
  * External Functions
diff --git a/drivers/mxc/pmic/mc13783/pmic_adc.c b/drivers/mxc/pmic/mc13783/pmic_adc.c
index 85365a4..d8fb7b4 100644
--- a/drivers/mxc/pmic/mc13783/pmic_adc.c
+++ b/drivers/mxc/pmic/mc13783/pmic_adc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -29,9 +29,9 @@
 #include <linux/delay.h>
 #include <linux/wait.h>
 
-#include <asm/arch/pmic_adc.h>
+#include <linux/pmic_adc.h>
+#include <linux/pmic_status.h>
 #include <asm/arch/pmic_power.h>
-#include <asm/arch/pmic_status.h>
 
 #include "../core/pmic.h"
 #include "pmic_adc_defs.h"
diff --git a/drivers/mxc/pmic/mc13783/pmic_audio.c b/drivers/mxc/pmic/mc13783/pmic_audio.c
index f4a4bd2..43a2903 100644
--- a/drivers/mxc/pmic/mc13783/pmic_audio.c
+++ b/drivers/mxc/pmic/mc13783/pmic_audio.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -53,9 +53,9 @@
 #include <linux/platform_device.h>	/* For kernel module interface.        */
 #include <linux/init.h>
 #include <linux/spinlock.h>	/* For spinlock interface.             */
+#include <linux/pmic_adc.h>	/* For PMIC ADC driver interface.      */
+#include <linux/pmic_status.h>
 #include <asm/arch/pmic_audio.h>	/* For PMIC Audio driver interface.    */
-#include <asm/arch/pmic_adc.h>	/* For PMIC ADC driver interface.      */
-#include <asm/arch/pmic_status.h>
 
 /*
  * mc13783 PMIC Audio API
diff --git a/drivers/mxc/pmic/mc13783/pmic_battery.c b/drivers/mxc/pmic/mc13783/pmic_battery.c
index 57cb49a..a0eb0a1 100644
--- a/drivers/mxc/pmic/mc13783/pmic_battery.c
+++ b/drivers/mxc/pmic/mc13783/pmic_battery.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -28,9 +28,9 @@
 #include <linux/delay.h>
 #include <linux/wait.h>
 
-#include <asm/arch/pmic_battery.h>
-#include <asm/arch/pmic_adc.h>
-#include <asm/arch/pmic_status.h>
+#include <linux/pmic_battery.h>
+#include <linux/pmic_adc.h>
+#include <linux/pmic_status.h>
 
 #include "pmic_battery_defs.h"
 
diff --git a/drivers/mxc/pmic/mc13783/pmic_convity.c b/drivers/mxc/pmic/mc13783/pmic_convity.c
index 1213832..36fce74 100644
--- a/drivers/mxc/pmic/mc13783/pmic_convity.c
+++ b/drivers/mxc/pmic/mc13783/pmic_convity.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -37,9 +37,9 @@
 #include <linux/interrupt.h>	/* For tasklet interface.                  */
 #include <linux/platform_device.h>	/* For kernel module interface.            */
 #include <linux/spinlock.h>	/* For spinlock interface.                 */
+#include <linux/pmic_adc.h>	/* For PMIC ADC driver interface.          */
+#include <linux/pmic_status.h>
 #include <asm/arch/pmic_convity.h>	/* For PMIC Connectivity driver interface. */
-#include <asm/arch/pmic_adc.h>	/* For PMIC ADC driver interface.          */
-#include <asm/arch/pmic_status.h>
 
 /*
  * mc13783 Connectivity API
diff --git a/drivers/mxc/pmic/mc13783/pmic_light.c b/drivers/mxc/pmic/mc13783/pmic_light.c
index c4772b2..7260e5e 100644
--- a/drivers/mxc/pmic/mc13783/pmic_light.c
+++ b/drivers/mxc/pmic/mc13783/pmic_light.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -24,8 +24,8 @@
 #include <linux/platform_device.h>
 #include <linux/delay.h>
 #include <linux/fs.h>
-#include <asm/arch/pmic_light.h>
-#include <asm/arch/pmic_status.h>
+#include <linux/pmic_light.h>
+#include <linux/pmic_status.h>
 #include "pmic_light_defs.h"
 
 #define NB_LIGHT_REG      6
diff --git a/drivers/mxc/pmic/mc13783/pmic_power.c b/drivers/mxc/pmic/mc13783/pmic_power.c
index 1a3208e..294df36 100644
--- a/drivers/mxc/pmic/mc13783/pmic_power.c
+++ b/drivers/mxc/pmic/mc13783/pmic_power.c
@@ -23,12 +23,12 @@
  */
 
 #include <linux/platform_device.h>
-#include <asm/ioctl.h>
-#include <asm/arch/pmic_power.h>
-#include <asm/arch/pmic_status.h>
+#include <linux/ioctl.h>
+#include <linux/pmic_status.h>
 #include <linux/irq.h>
 #include <linux/interrupt.h>
 #include <linux/kernel.h>
+#include <asm/arch/pmic_power.h>
 
 #include "pmic_power_defs.h"
 
diff --git a/drivers/mxc/pmic/mc13783/pmic_rtc.c b/drivers/mxc/pmic/mc13783/pmic_rtc.c
index 5383fce..0a19922 100644
--- a/drivers/mxc/pmic/mc13783/pmic_rtc.c
+++ b/drivers/mxc/pmic/mc13783/pmic_rtc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -24,8 +24,8 @@
 #include <linux/wait.h>
 #include <linux/poll.h>
 #include <linux/platform_device.h>
-#include <asm/arch/pmic_rtc.h>
-#include <asm/arch/pmic_status.h>
+#include <linux/pmic_rtc.h>
+#include <linux/pmic_status.h>
 
 #include "pmic_rtc_defs.h"
 
diff --git a/drivers/mxc/pmic/mc13892/pmic_adc.c b/drivers/mxc/pmic/mc13892/pmic_adc.c
index 82dab3a..d75f7a6 100644
--- a/drivers/mxc/pmic/mc13892/pmic_adc.c
+++ b/drivers/mxc/pmic/mc13892/pmic_adc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -18,9 +18,9 @@
 #include <linux/wait.h>
 #include <linux/device.h>
 
-#include <asm/arch/pmic_adc.h>
+#include <linux/pmic_adc.h>
+#include <linux/pmic_status.h>
 #include <asm/arch/pmic_power.h>
-#include <asm/arch/pmic_status.h>
 
 #include "../core/pmic.h"
 
diff --git a/drivers/mxc/pmic/mc13892/pmic_light.c b/drivers/mxc/pmic/mc13892/pmic_light.c
index cd07b71..ae02430 100644
--- a/drivers/mxc/pmic/mc13892/pmic_light.c
+++ b/drivers/mxc/pmic/mc13892/pmic_light.c
@@ -25,8 +25,8 @@
 #include <linux/platform_device.h>
 #include <linux/delay.h>
 #include <linux/fs.h>
-#include <asm/arch/pmic_light.h>
-#include <asm/arch/pmic_status.h>
+#include <linux/pmic_light.h>
+#include <linux/pmic_status.h>
 
 #define BIT_CL_MAIN_LSH		9
 #define BIT_CL_AUX_LSH		21
diff --git a/drivers/mxc/security/mxc_scc_internals.h b/drivers/mxc/security/mxc_scc_internals.h
index ce583cd..f3dadf5 100644
--- a/drivers/mxc/security/mxc_scc_internals.h
+++ b/drivers/mxc/security/mxc_scc_internals.h
@@ -41,9 +41,9 @@
 #include <linux/sched.h>	/* for interrupt.h */
 #include <linux/spinlock.h>
 #include <linux/interrupt.h>	/* IRQ / interrupt definitions */
-#include <asm/io.h>		/* ioremap() */
+#include <linux/io.h>		/* ioremap() */
 #endif
-#include <asm/arch/mxc_scc_driver.h>
+#include <linux/mxc_scc_driver.h>
 
 /* Get handle on certain per-platform symbols */
 #ifdef TAHITI
diff --git a/drivers/mxc/security/rng/fsl_shw_sym.c b/drivers/mxc/security/rng/fsl_shw_sym.c
index 60885cb..e844e3a 100644
--- a/drivers/mxc/security/rng/fsl_shw_sym.c
+++ b/drivers/mxc/security/rng/fsl_shw_sym.c
@@ -25,7 +25,7 @@
 #if defined(__KERNEL__) && defined(FSL_HAVE_DRYICE)
 
 #include "../dryice.h"
-#include <asm/arch/mxc_scc_driver.h>
+#include <linux/mxc_scc_driver.h>
 #ifdef DIAG_SECURITY_FUNC
 #include "apihelp.h"
 #endif
diff --git a/drivers/mxc/security/rng/fsl_shw_wrap.c b/drivers/mxc/security/rng/fsl_shw_wrap.c
index 369e05b..90e241e 100644
--- a/drivers/mxc/security/rng/fsl_shw_wrap.c
+++ b/drivers/mxc/security/rng/fsl_shw_wrap.c
@@ -101,7 +101,7 @@
 #if defined(__KERNEL__) && defined(FSL_HAVE_DRYICE)
 
 #include "../dryice.h"
-#include <asm/arch/mxc_scc_driver.h>
+#include <linux/mxc_scc_driver.h>
 
 #include "portable_os.h"
 #include "fsl_shw_keystore.h"
diff --git a/drivers/mxc/security/rng/rng_driver.c b/drivers/mxc/security/rng/rng_driver.c
index d346639..d6a6bf6 100644
--- a/drivers/mxc/security/rng/rng_driver.c
+++ b/drivers/mxc/security/rng/rng_driver.c
@@ -53,9 +53,9 @@
 #include "rng_internals.h"
 
 #ifdef FSL_HAVE_SCC2
-#include <asm/arch/mxc_scc2_driver.h>
+#include <linux/mxc_scc2_driver.h>
 #else
-#include <asm/arch/mxc_scc_driver.h>
+#include <linux/mxc_scc_driver.h>
 #endif
 
 #if defined(RNG_DEBUG) || defined(RNG_ENTROPY_DEBUG) ||                     \
diff --git a/drivers/mxc/security/rng/shw_driver.c b/drivers/mxc/security/rng/shw_driver.c
index e552dc7..81212e5 100644
--- a/drivers/mxc/security/rng/shw_driver.c
+++ b/drivers/mxc/security/rng/shw_driver.c
@@ -64,9 +64,9 @@
 #include "shw_internals.h"
 
 #ifdef FSL_HAVE_SCC2
-#include <asm/arch/mxc_scc2_driver.h>
+#include <linux/mxc_scc2_driver.h>
 #else
-#include <asm/arch/mxc_scc_driver.h>
+#include <linux/mxc_scc_driver.h>
 #endif
 
 #ifdef SHW_DEBUG
diff --git a/drivers/mxc/security/sahara2/fsl_shw_keystore.c b/drivers/mxc/security/sahara2/fsl_shw_keystore.c
index 1fb69ae..3a8a22a 100644
--- a/drivers/mxc/security/sahara2/fsl_shw_keystore.c
+++ b/drivers/mxc/security/sahara2/fsl_shw_keystore.c
@@ -26,7 +26,7 @@
 #endif
 
 #if !defined(FSL_HAVE_SCC2) && defined(__KERNEL__)
-#include <asm/arch/mxc_scc_driver.h>
+#include <linux/mxc_scc_driver.h>
 #endif
 
 /* Define a semaphore to protect the keystore data */
diff --git a/drivers/mxc/security/sahara2/km_adaptor.c b/drivers/mxc/security/sahara2/km_adaptor.c
index 0ec50ab..2cec1b8 100644
--- a/drivers/mxc/security/sahara2/km_adaptor.c
+++ b/drivers/mxc/security/sahara2/km_adaptor.c
@@ -24,9 +24,9 @@
 #include <sah_memory_mapper.h>
 #include <fsl_shw_keystore.h>
 #ifdef FSL_HAVE_SCC
-#include <asm/arch/mxc_scc_driver.h>
+#include <linux/mxc_scc_driver.h>
 #elif defined (FSL_HAVE_SCC2)
-#include <asm/arch/mxc_scc2_driver.h>
+#include <linux/mxc_scc2_driver.h>
 #endif
 
 
diff --git a/drivers/mxc/security/sahara2/sah_driver_interface.c b/drivers/mxc/security/sahara2/sah_driver_interface.c
index 16db154..b789179 100644
--- a/drivers/mxc/security/sahara2/sah_driver_interface.c
+++ b/drivers/mxc/security/sahara2/sah_driver_interface.c
@@ -29,9 +29,9 @@
 #include <fsl_shw_keystore.h>
 #include <adaptor.h>
 #ifdef FSL_HAVE_SCC
-#include <asm/arch/mxc_scc_driver.h>
+#include <linux/mxc_scc_driver.h>
 #else
-#include <asm/arch/mxc_scc2_driver.h>
+#include <linux/mxc_scc2_driver.h>
 #endif
 
 #ifdef DIAG_DRV_IF
diff --git a/drivers/mxc/security/sahara2/sah_memory_mapper.c b/drivers/mxc/security/sahara2/sah_memory_mapper.c
index 057a5fe..d239a34 100644
--- a/drivers/mxc/security/sahara2/sah_memory_mapper.c
+++ b/drivers/mxc/security/sahara2/sah_memory_mapper.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -40,9 +40,9 @@
 #include <sah_queue_manager.h>
 #include <sah_memory_mapper.h>
 #ifdef FSL_HAVE_SCC2
-#include <asm/arch/mxc_scc2_driver.h>
+#include <linux/mxc_scc2_driver.h>
 #else
-#include <asm/arch/mxc_scc_driver.h>
+#include <linux/mxc_scc_driver.h>
 #endif
 
 #if defined(DIAG_DRV_IF) || defined(DIAG_MEM) || defined(DO_DBG)
diff --git a/drivers/mxc/security/scc2_internals.h b/drivers/mxc/security/scc2_internals.h
index 6bf0872..dae4a31 100644
--- a/drivers/mxc/security/scc2_internals.h
+++ b/drivers/mxc/security/scc2_internals.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -39,11 +39,11 @@
 #include <linux/sched.h>            /* for interrupt.h */
 #include <linux/spinlock.h>
 
-#include <asm/io.h>                 /* ioremap() */
+#include <linux/io.h>               /* ioremap() */
 #include <linux/interrupt.h>        /* IRQ / interrupt definitions */
 
 
-#include <asm/arch/mxc_scc2_driver.h>
+#include <linux/mxc_scc2_driver.h>
 
 #if defined(MXC)
 
diff --git a/drivers/regulator/max8660/reg-max8660.c b/drivers/regulator/max8660/reg-max8660.c
index 54fe758..df76fc6 100644
--- a/drivers/regulator/max8660/reg-max8660.c
+++ b/drivers/regulator/max8660/reg-max8660.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -20,8 +20,8 @@
 #include <linux/err.h>
 #include <linux/regulator/regulator-platform.h>
 #include <linux/regulator/regulator-drv.h>
-#include <asm/ioctl.h>
-#include <asm/arch-mxc/pmic_status.h>
+#include <linux/ioctl.h>
+#include <linux/pmic_status.h>
 #include <linux/platform_device.h>
 #include <linux/regulator/mcu_max8660-bus.h>
 
diff --git a/drivers/regulator/mc13783/reg-mc13783.c b/drivers/regulator/mc13783/reg-mc13783.c
index 536366f..eff37db 100644
--- a/drivers/regulator/mc13783/reg-mc13783.c
+++ b/drivers/regulator/mc13783/reg-mc13783.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -20,10 +20,10 @@
 #include <linux/err.h>
 #include <linux/regulator/regulator-platform.h>
 #include <linux/regulator/regulator-drv.h>
-#include <asm/ioctl.h>
+#include <linux/ioctl.h>
 #include <linux/platform_device.h>
-#include <asm/arch/pmic_status.h>
-#include <asm/arch/pmic_external.h>
+#include <linux/pmic_status.h>
+#include <linux/pmic_external.h>
 
 /*!
  * brief PMIC regulators.
diff --git a/drivers/regulator/mc13892/reg-mc13892.c b/drivers/regulator/mc13892/reg-mc13892.c
index f480abe..74fbc78 100644
--- a/drivers/regulator/mc13892/reg-mc13892.c
+++ b/drivers/regulator/mc13892/reg-mc13892.c
@@ -20,10 +20,10 @@
 #include <linux/err.h>
 #include <linux/regulator/regulator-platform.h>
 #include <linux/regulator/regulator-drv.h>
-#include <asm/ioctl.h>
+#include <linux/ioctl.h>
 #include <linux/platform_device.h>
-#include <asm/arch/pmic_status.h>
-#include <asm/arch/pmic_external.h>
+#include <linux/pmic_status.h>
+#include <linux/pmic_external.h>
 
 enum {
 	MC13892_SW1 = 0,
diff --git a/drivers/regulator/mc34704/reg-mc34704.c b/drivers/regulator/mc34704/reg-mc34704.c
index 99971bf..1001bf7 100644
--- a/drivers/regulator/mc34704/reg-mc34704.c
+++ b/drivers/regulator/mc34704/reg-mc34704.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -22,8 +22,8 @@
 #include <linux/regulator/regulator-platform.h>
 #include <linux/regulator/regulator-drv.h>
 #include <linux/platform_device.h>
-#include <asm/arch/pmic_status.h>
-#include <asm/arch/pmic_external.h>
+#include <linux/pmic_status.h>
+#include <linux/pmic_external.h>
 
 #define MC34704_ONOFFA	0x8
 #define MC34704_ONOFFC	0x4
diff --git a/drivers/regulator/mc9sdz60/reg-mc9sdz60.c b/drivers/regulator/mc9sdz60/reg-mc9sdz60.c
index 809b01a..92eaa6e 100644
--- a/drivers/regulator/mc9sdz60/reg-mc9sdz60.c
+++ b/drivers/regulator/mc9sdz60/reg-mc9sdz60.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -20,8 +20,8 @@
 #include <linux/err.h>
 #include <linux/regulator/regulator-platform.h>
 #include <linux/regulator/regulator-drv.h>
-#include <asm/ioctl.h>
-#include <asm/arch-mxc/pmic_status.h>
+#include <linux/ioctl.h>
+#include <linux/pmic_status.h>
 #include <linux/platform_device.h>
 #include <linux/regulator/mcu_max8660-bus.h>
 
diff --git a/drivers/rtc/rtc-mc13892.c b/drivers/rtc/rtc-mc13892.c
index d6b67ae..e579c18 100644
--- a/drivers/rtc/rtc-mc13892.c
+++ b/drivers/rtc/rtc-mc13892.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -15,8 +15,8 @@
 #include <linux/module.h>
 #include <linux/platform_device.h>
 
-#include <asm/arch/pmic_status.h>
-#include <asm/arch/pmic_external.h>
+#include <linux/pmic_status.h>
+#include <linux/pmic_external.h>
 
 #define RTC_TIME_LSH		0
 #define RTC_DAY_LSH		0
diff --git a/drivers/rtc/rtc-mxc.c b/drivers/rtc/rtc-mxc.c
index 35ab9be..d88c2b5 100644
--- a/drivers/rtc/rtc-mxc.c
+++ b/drivers/rtc/rtc-mxc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -122,7 +122,7 @@ struct rtc_plat_data {
 
 #if defined(CONFIG_MXC_PMIC_SC55112_RTC) || defined(CONFIG_MXC_MC13783_RTC) ||\
     defined(CONFIG_MXC_MC9SDZ60_RTC)
-#include <asm/arch/pmic_rtc.h>
+#include <linux/pmic_rtc.h>
 #else
 #define pmic_rtc_get_time(args)	MXC_EXTERNAL_RTC_NONE
 #define pmic_rtc_set_time(args)	MXC_EXTERNAL_RTC_NONE
diff --git a/drivers/video/backlight/mxc_ipu_bl.c b/drivers/video/backlight/mxc_ipu_bl.c
index 666831a..a11c2d5 100644
--- a/drivers/video/backlight/mxc_ipu_bl.c
+++ b/drivers/video/backlight/mxc_ipu_bl.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2007-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2007-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -33,8 +33,7 @@
 #include <linux/spinlock.h>
 #include <linux/fb.h>
 #include <linux/backlight.h>
-
-#include <asm/arch/ipu.h>
+#include <linux/ipu.h>
 
 #define MXC_MAX_INTENSITY 	255
 #define MXC_DEFAULT_INTENSITY 	127
diff --git a/drivers/video/backlight/mxc_mc13892_bl.c b/drivers/video/backlight/mxc_mc13892_bl.c
index 57e8813..f8d112e 100644
--- a/drivers/video/backlight/mxc_mc13892_bl.c
+++ b/drivers/video/backlight/mxc_mc13892_bl.c
@@ -19,7 +19,7 @@
 #include <linux/fb.h>
 #include <linux/backlight.h>
 
-#include <asm/arch/pmic_light.h>
+#include <linux/pmic_light.h>
 
 /*
 #define MXC_MAX_INTENSITY 	255
diff --git a/drivers/video/backlight/mxc_pmic_bl.c b/drivers/video/backlight/mxc_pmic_bl.c
index 82e3236..9a61d4b 100644
--- a/drivers/video/backlight/mxc_pmic_bl.c
+++ b/drivers/video/backlight/mxc_pmic_bl.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2007-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -33,9 +33,9 @@
 #include <linux/spinlock.h>
 #include <linux/fb.h>
 #include <linux/backlight.h>
+#include <linux/pmic_light.h>
 
 #include <asm/arch/pmic_power.h>
-#include <asm/arch/pmic_light.h>
 
 #define MXC_MAX_INTENSITY 	255
 #define MXC_DEFAULT_INTENSITY 	127
diff --git a/drivers/video/mxc/ch7024.c b/drivers/video/mxc/ch7024.c
index 01be1c4..6253276 100644
--- a/drivers/video/mxc/ch7024.c
+++ b/drivers/video/mxc/ch7024.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2007-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2007-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -28,10 +28,10 @@
 #include <linux/irq.h>
 #include <linux/sysfs.h>
 #include <linux/regulator/regulator.h>
+#include <linux/mxcfb.h>
 #include <asm/uaccess.h>
 #include <asm/atomic.h>
 #include <asm/arch/gpio.h>
-#include <asm/arch/mxcfb.h>
 #include <asm/arch/hw_events.h>
 
 /*!
diff --git a/drivers/video/mxc/mx2fb.c b/drivers/video/mxc/mx2fb.c
index fbb5b93..35e7e96 100644
--- a/drivers/video/mxc/mx2fb.c
+++ b/drivers/video/mxc/mx2fb.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -34,8 +34,8 @@
 #include <linux/platform_device.h>
 #include <linux/interrupt.h>
 #include <linux/clk.h>
+#include <linux/mxcfb.h>
 #include <asm/uaccess.h>
-#include <asm/arch/mxcfb.h>
 
 #include "mx2fb.h"
 
diff --git a/drivers/video/mxc/mxc_ipuv3_fb.c b/drivers/video/mxc/mxc_ipuv3_fb.c
index 2bfb264..b5b0533 100644
--- a/drivers/video/mxc/mxc_ipuv3_fb.c
+++ b/drivers/video/mxc/mxc_ipuv3_fb.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -41,12 +41,12 @@
 #include <linux/dma-mapping.h>
 #include <linux/clk.h>
 #include <linux/console.h>
+#include <linux/io.h>
+#include <linux/ipu.h>
+#include <linux/mxcfb.h>
 #include <asm/hardware.h>
-#include <asm/io.h>
 #include <asm/mach-types.h>
 #include <asm/uaccess.h>
-#include <asm/arch/ipu.h>
-#include <asm/arch/mxcfb.h>
 
 /*
  * Driver name
diff --git a/drivers/video/mxc/mxcfb.c b/drivers/video/mxc/mxcfb.c
index 7efd5f8..b9e7114 100644
--- a/drivers/video/mxc/mxcfb.c
+++ b/drivers/video/mxc/mxcfb.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -41,12 +41,12 @@
 #include <linux/dma-mapping.h>
 #include <linux/clk.h>
 #include <linux/console.h>
+#include <linux/io.h>
+#include <linux/ipu.h>
+#include <linux/mxcfb.h>
 #include <asm/hardware.h>
-#include <asm/io.h>
 #include <asm/mach-types.h>
 #include <asm/uaccess.h>
-#include <asm/arch/ipu.h>
-#include <asm/arch/mxcfb.h>
 
 /*
  * Driver name
diff --git a/drivers/video/mxc/mxcfb_claa_wvga.c b/drivers/video/mxc/mxcfb_claa_wvga.c
index b4543b7..0ea2067 100644
--- a/drivers/video/mxc/mxcfb_claa_wvga.c
+++ b/drivers/video/mxc/mxcfb_claa_wvga.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -35,7 +35,7 @@
 #include <linux/init.h>
 #include <linux/platform_device.h>
 #include <linux/regulator/regulator.h>
-#include <asm/arch/mxcfb.h>
+#include <linux/mxcfb.h>
 
 static void lcd_poweron(void);
 static void lcd_poweroff(void);
diff --git a/drivers/video/mxc/mxcfb_epson_vga.c b/drivers/video/mxc/mxcfb_epson_vga.c
index bbc6a62..c434d38 100644
--- a/drivers/video/mxc/mxcfb_epson_vga.c
+++ b/drivers/video/mxc/mxcfb_epson_vga.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2007-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2007-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -36,8 +36,8 @@
 #include <linux/platform_device.h>
 #include <linux/regulator/regulator.h>
 #include <linux/spi/spi.h>
-#include <asm/arch/mxcfb.h>
-#include <asm/arch/ipu.h>
+#include <linux/mxcfb.h>
+#include <linux/ipu.h>
 #include <asm/mach-types.h>
 
 static struct spi_device *lcd_spi;
diff --git a/drivers/video/mxc/mxcfb_modedb.c b/drivers/video/mxc/mxcfb_modedb.c
index d7cb1aa..5fd4602 100644
--- a/drivers/video/mxc/mxcfb_modedb.c
+++ b/drivers/video/mxc/mxcfb_modedb.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2007-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2007-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -12,7 +12,7 @@
  */
 
 #include <linux/kernel.h>
-#include <asm/arch/mxcfb.h>
+#include <linux/mxcfb.h>
 
 struct fb_videomode mxcfb_modedb[] = {
 	{
diff --git a/drivers/video/mxc/tve.c b/drivers/video/mxc/tve.c
index d8c6314..2e2d1c1 100644
--- a/drivers/video/mxc/tve.c
+++ b/drivers/video/mxc/tve.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -30,10 +30,10 @@
 #include <linux/sysfs.h>
 #include <linux/platform_device.h>
 #include <linux/regulator/regulator.h>
+#include <linux/mxcfb.h>
 #include <asm/uaccess.h>
 #include <asm/atomic.h>
 #include <asm/arch/gpio.h>
-#include <asm/arch/mxcfb.h>
 
 #define TVE_COM_CONF_REG	0
 #define TVE_CD_CONT_REG		0x14
diff --git a/include/asm-arm/arch-mxc/ipu.h b/include/asm-arm/arch-mxc/ipu.h
deleted file mode 100644
index a28d44e..0000000
--- a/include/asm-arm/arch-mxc/ipu.h
+++ /dev/null
@@ -1,1162 +0,0 @@
-/*
- * Copyright 2005-2009 Freescale Semiconductor, Inc.
- */
-
-/*
- * The code contained herein is licensed under the GNU Lesser General
- * Public License.  You may obtain a copy of the GNU Lesser General
- * Public License Version 2.1 or later at the following locations:
- *
- * http://www.opensource.org/licenses/lgpl-license.html
- * http://www.gnu.org/copyleft/lgpl.html
- */
-
-/*!
- * @defgroup IPU MXC Image Processing Unit (IPU) Driver
- */
-/*!
- * @file arch-mxc/ipu.h
- *
- * @brief This file contains the IPU driver API declarations.
- *
- * @ingroup IPU
- */
-
-#ifndef __ASM_ARCH_IPU_H__
-#define __ASM_ARCH_IPU_H__
-
-#include <linux/types.h>
-#ifdef __KERNEL__
-#include <linux/interrupt.h>
-#else
-#define bool char
-#define irqreturn_t int
-#define dma_addr_t int
-#define u32 unsigned int
-#define __u32 u32
-#endif
-
-/*!
- * Enumeration of IPU rotation modes
- */
-typedef enum {
-	/* Note the enum values correspond to BAM value */
-	IPU_ROTATE_NONE = 0,
-	IPU_ROTATE_VERT_FLIP = 1,
-	IPU_ROTATE_HORIZ_FLIP = 2,
-	IPU_ROTATE_180 = 3,
-	IPU_ROTATE_90_RIGHT = 4,
-	IPU_ROTATE_90_RIGHT_VFLIP = 5,
-	IPU_ROTATE_90_RIGHT_HFLIP = 6,
-	IPU_ROTATE_90_LEFT = 7,
-} ipu_rotate_mode_t;
-
-/*!
- * Enumeration of Post Filter modes
- */
-typedef enum {
-	PF_DISABLE_ALL = 0,
-	PF_MPEG4_DEBLOCK = 1,
-	PF_MPEG4_DERING = 2,
-	PF_MPEG4_DEBLOCK_DERING = 3,
-	PF_H264_DEBLOCK = 4,
-} pf_operation_t;
-
-/*!
- * Enumeration of Synchronous (Memory-less) panel types
- */
-typedef enum {
-	IPU_PANEL_SHARP_TFT,
-	IPU_PANEL_TFT,
-} ipu_panel_t;
-
-/*  IPU Pixel format definitions */
-/*  Four-character-code (FOURCC) */
-#define fourcc(a, b, c, d)\
-        (((__u32)(a)<<0)|((__u32)(b)<<8)|((__u32)(c)<<16)|((__u32)(d)<<24))
-
-/*!
- * @name IPU Pixel Formats
- *
- * Pixel formats are defined with ASCII FOURCC code. The pixel format codes are
- * the same used by V4L2 API.
- */
-
-/*! @{ */
-/*! @name Generic or Raw Data Formats */
-/*! @{ */
-#define IPU_PIX_FMT_GENERIC fourcc('I', 'P', 'U', '0')	/*!< IPU Generic Data */
-#define IPU_PIX_FMT_GENERIC_32 fourcc('I', 'P', 'U', '1')	/*!< IPU Generic Data */
-/*! @} */
-/*! @name RGB Formats */
-/*! @{ */
-#define IPU_PIX_FMT_RGB332  fourcc('R', 'G', 'B', '1')	/*!<  8  RGB-3-3-2    */
-#define IPU_PIX_FMT_RGB555  fourcc('R', 'G', 'B', 'O')	/*!< 16  RGB-5-5-5    */
-#define IPU_PIX_FMT_RGB565  fourcc('R', 'G', 'B', 'P')	/*!< 1 6  RGB-5-6-5   */
-#define IPU_PIX_FMT_RGB666  fourcc('R', 'G', 'B', '6')	/*!< 18  RGB-6-6-6    */
-#define IPU_PIX_FMT_BGR666  fourcc('B', 'G', 'R', '6')	/*!< 18  BGR-6-6-6    */
-#define IPU_PIX_FMT_BGR24   fourcc('B', 'G', 'R', '3')	/*!< 24  BGR-8-8-8    */
-#define IPU_PIX_FMT_RGB24   fourcc('R', 'G', 'B', '3')	/*!< 24  RGB-8-8-8    */
-#define IPU_PIX_FMT_BGR32   fourcc('B', 'G', 'R', '4')	/*!< 32  BGR-8-8-8-8  */
-#define IPU_PIX_FMT_BGRA32  fourcc('B', 'G', 'R', 'A')	/*!< 32  BGR-8-8-8-8  */
-#define IPU_PIX_FMT_RGB32   fourcc('R', 'G', 'B', '4')	/*!< 32  RGB-8-8-8-8  */
-#define IPU_PIX_FMT_RGBA32  fourcc('R', 'G', 'B', 'A')	/*!< 32  RGB-8-8-8-8  */
-#define IPU_PIX_FMT_ABGR32  fourcc('A', 'B', 'G', 'R')	/*!< 32  ABGR-8-8-8-8 */
-/*! @} */
-/*! @name YUV Interleaved Formats */
-/*! @{ */
-#define IPU_PIX_FMT_YUYV    fourcc('Y', 'U', 'Y', 'V')	/*!< 16 YUV 4:2:2 */
-#define IPU_PIX_FMT_UYVY    fourcc('U', 'Y', 'V', 'Y')	/*!< 16 YUV 4:2:2 */
-#define IPU_PIX_FMT_Y41P    fourcc('Y', '4', '1', 'P')	/*!< 12 YUV 4:1:1 */
-#define IPU_PIX_FMT_YUV444  fourcc('Y', '4', '4', '4')	/*!< 24 YUV 4:4:4 */
-/* two planes -- one Y, one Cb + Cr interleaved  */
-#define IPU_PIX_FMT_NV12    fourcc('N', 'V', '1', '2') /* 12  Y/CbCr 4:2:0  */
-/*! @} */
-/*! @name YUV Planar Formats */
-/*! @{ */
-#define IPU_PIX_FMT_GREY    fourcc('G', 'R', 'E', 'Y')	/*!< 8  Greyscale */
-#define IPU_PIX_FMT_YVU410P fourcc('Y', 'V', 'U', '9')	/*!< 9  YVU 4:1:0 */
-#define IPU_PIX_FMT_YUV410P fourcc('Y', 'U', 'V', '9')	/*!< 9  YUV 4:1:0 */
-#define IPU_PIX_FMT_YVU420P fourcc('Y', 'V', '1', '2')	/*!< 12 YVU 4:2:0 */
-#define IPU_PIX_FMT_YUV420P fourcc('I', '4', '2', '0')	/*!< 12 YUV 4:2:0 */
-#define IPU_PIX_FMT_YUV420P2 fourcc('Y', 'U', '1', '2')	/*!< 12 YUV 4:2:0 */
-#define IPU_PIX_FMT_YVU422P fourcc('Y', 'V', '1', '6')	/*!< 16 YVU 4:2:2 */
-#define IPU_PIX_FMT_YUV422P fourcc('4', '2', '2', 'P')	/*!< 16 YUV 4:2:2 */
-/*! @} */
-
-/* IPU Driver channels definitions.	*/
-/* Note these are different from IDMA channels */
-#ifdef CONFIG_MXC_IPU_V1
-#define _MAKE_CHAN(num, in, out, sec)    ((num << 24) | (sec << 16) | (out << 8) | in)
-#define IPU_CHAN_ID(ch)         (ch >> 24)
-#define IPU_CHAN_SEC_DMA(ch)    ((uint32_t) (ch >> 16) & 0xFF)
-#define IPU_CHAN_OUT_DMA(ch)    ((uint32_t) (ch >> 8) & 0xFF)
-#define IPU_CHAN_IN_DMA(ch)     ((uint32_t) (ch & 0xFF))
-
-#else
-#define IPU_MAX_CH	32
-#define _MAKE_CHAN(num, v_in, g_in, a_in, out) \
-	((num << 24) | (v_in << 18) | (g_in << 12) | (a_in << 6) | out)
-#define _MAKE_ALT_CHAN(ch)		(ch | (IPU_MAX_CH << 24))
-#define IPU_CHAN_ID(ch)			(ch >> 24)
-#define IPU_CHAN_ALT(ch)		(ch & 0x02000000)
-#define IPU_CHAN_ALPHA_IN_DMA(ch)	((uint32_t) (ch >> 6) & 0x3F)
-#define IPU_CHAN_GRAPH_IN_DMA(ch)	((uint32_t) (ch >> 12) & 0x3F)
-#define IPU_CHAN_VIDEO_IN_DMA(ch)	((uint32_t) (ch >> 18) & 0x3F)
-#define IPU_CHAN_OUT_DMA(ch)		((uint32_t) (ch & 0x3F))
-#define NO_DMA 0x3F
-#define ALT	1
-#endif
-/*!
- * Enumeration of IPU logical channels. An IPU logical channel is defined as a
- * combination of an input (memory to IPU), output (IPU to memory), and/or
- * secondary input IDMA channels and in some cases an Image Converter task.
- * Some channels consist of only an input or output.
- */
-typedef enum {
-	CHAN_NONE = -1,
-#ifdef CONFIG_MXC_IPU_V1
-	CSI_MEM = _MAKE_CHAN(1, 0xFF, 7, 0xFF),	/*!< CSI raw sensor data to memory */
-
-	CSI_PRP_ENC_MEM = _MAKE_CHAN(2, 0xFF, 0, 0xFF),	/*!< CSI to IC Encoder PreProcessing to Memory */
-	MEM_PRP_ENC_MEM = _MAKE_CHAN(3, 6, 0, 0xFF),	/*!< Memory to IC Encoder PreProcessing to Memory */
-	MEM_ROT_ENC_MEM = _MAKE_CHAN(4, 10, 8, 0xFF),	/*!< Memory to IC Encoder Rotation to Memory */
-
-	CSI_PRP_VF_MEM = _MAKE_CHAN(5, 0xFF, 1, 0xFF),	/*!< CSI to IC Viewfinder PreProcessing to Memory */
-	CSI_PRP_VF_ADC = _MAKE_CHAN(6, 0xFF, 1, 0xFF),	/*!< CSI to IC Viewfinder PreProcessing to ADC */
-	MEM_PRP_VF_MEM = _MAKE_CHAN(7, 6, 1, 3),	/*!< Memory to IC Viewfinder PreProcessing to Memory */
-	MEM_PRP_VF_ADC = _MAKE_CHAN(8, 6, 1, 3),	/*!< Memory to IC Viewfinder PreProcessing to ADC */
-	MEM_ROT_VF_MEM = _MAKE_CHAN(9, 11, 9, 0xFF),	/*!< Memory to IC Viewfinder Rotation to Memory */
-
-	MEM_PP_MEM = _MAKE_CHAN(10, 5, 2, 4),	/*!< Memory to IC PostProcessing to Memory */
-	MEM_ROT_PP_MEM = _MAKE_CHAN(11, 13, 12, 0xFF),	/*!< Memory to IC PostProcessing Rotation to Memory */
-	MEM_PP_ADC = _MAKE_CHAN(12, 5, 2, 4),	/*!< Memory to IC PostProcessing to ADC */
-
-	MEM_SDC_BG = _MAKE_CHAN(14, 14, 0xFF, 0xFF),	/*!< Memory to SDC Background plane */
-	MEM_SDC_FG = _MAKE_CHAN(15, 15, 0xFF, 0xFF),	/*!< Memory to SDC Foreground plane */
-	MEM_SDC_MASK = _MAKE_CHAN(16, 16, 0xFF, 0xFF),	/*!< Memory to SDC Mask */
-
-	MEM_BG_SYNC = MEM_SDC_BG,
-	MEM_FG_SYNC = MEM_SDC_FG,
-
-	ADC_SYS1 = _MAKE_CHAN(17, 18, 22, 20),	/*!< Memory to ADC System Channel 1 */
-	ADC_SYS2 = _MAKE_CHAN(18, 19, 23, 21),	/*!< Memory to ADC System Channel 2 */
-
-	MEM_PF_Y_MEM = _MAKE_CHAN(19, 26, 29, 24),	/*!< Y and PF Memory to Post-filter to Y Memory */
-	MEM_PF_U_MEM = _MAKE_CHAN(20, 27, 30, 25),	/*!< U and PF Memory to Post-filter to U Memory */
-	MEM_PF_V_MEM = _MAKE_CHAN(21, 28, 31, 0xFF),	/*!< V Memory to Post-filter to V Memory */
-
-	MEM_DC_SYNC = CHAN_NONE,
-	DIRECT_ASYNC0 = CHAN_NONE,
-	DIRECT_ASYNC1 = CHAN_NONE,
-#else
-	MEM_ROT_ENC_MEM = _MAKE_CHAN(1, 45, NO_DMA, NO_DMA, 48),
-	MEM_ROT_VF_MEM = _MAKE_CHAN(2, 46, NO_DMA, NO_DMA, 49),
-	MEM_ROT_PP_MEM = _MAKE_CHAN(3, 47, NO_DMA, NO_DMA, 50),
-
-	MEM_PRP_ENC_MEM = _MAKE_CHAN(4, 12, 14, 17, 20),
-	MEM_PRP_VF_MEM = _MAKE_CHAN(5, 12, 14, 17, 21),
-	MEM_PP_MEM = _MAKE_CHAN(6, 11, 15, 18, 22),
-
-	MEM_DC_SYNC = _MAKE_CHAN(7, 28, NO_DMA, NO_DMA, NO_DMA),
-	MEM_DC_ASYNC = _MAKE_CHAN(8, 41, NO_DMA, NO_DMA, NO_DMA),
-	MEM_BG_SYNC = _MAKE_CHAN(9, 23, NO_DMA, 51, NO_DMA),
-	MEM_FG_SYNC = _MAKE_CHAN(10, 27, NO_DMA, 31, NO_DMA),
-
-	MEM_BG_ASYNC0 = _MAKE_CHAN(11, 24, NO_DMA, 52, NO_DMA),
-	MEM_FG_ASYNC0 = _MAKE_CHAN(12, 29, NO_DMA, 33, NO_DMA),
-	MEM_BG_ASYNC1 = _MAKE_ALT_CHAN(MEM_BG_ASYNC0),
-	MEM_FG_ASYNC1 = _MAKE_ALT_CHAN(MEM_FG_ASYNC0),
-
-	DIRECT_ASYNC0 = _MAKE_CHAN(13, NO_DMA, NO_DMA, NO_DMA, NO_DMA),
-	DIRECT_ASYNC1 = _MAKE_CHAN(14, NO_DMA, NO_DMA, NO_DMA, NO_DMA),
-
-	CSI_MEM0 = _MAKE_CHAN(15, NO_DMA, NO_DMA, NO_DMA, 0),
-	CSI_MEM1 = _MAKE_CHAN(16, NO_DMA, NO_DMA, NO_DMA, 1),
-	CSI_MEM2 = _MAKE_CHAN(17, NO_DMA, NO_DMA, NO_DMA, 2),
-	CSI_MEM3 = _MAKE_CHAN(18, NO_DMA, NO_DMA, NO_DMA, 3),
-
-	CSI_MEM = CSI_MEM0,
-
-	CSI_PRP_ENC_MEM = _MAKE_CHAN(19, NO_DMA, NO_DMA, NO_DMA, 20),
-	CSI_PRP_VF_MEM = _MAKE_CHAN(20, NO_DMA, NO_DMA, NO_DMA, 21),
-
-	MEM_PP_ADC = CHAN_NONE,
-	ADC_SYS2 = CHAN_NONE,
-#endif
-
-} ipu_channel_t;
-
-/*!
- * Enumeration of types of buffers for a logical channel.
- */
-typedef enum {
-	IPU_OUTPUT_BUFFER = 0,	/*!< Buffer for output from IPU */
-	IPU_ALPHA_IN_BUFFER = 1,	/*!< Buffer for input to IPU */
-	IPU_GRAPH_IN_BUFFER = 2,	/*!< Buffer for input to IPU */
-	IPU_VIDEO_IN_BUFFER = 3,	/*!< Buffer for input to IPU */
-	IPU_INPUT_BUFFER = IPU_VIDEO_IN_BUFFER,
-	IPU_SEC_INPUT_BUFFER = IPU_GRAPH_IN_BUFFER,
-} ipu_buffer_t;
-
-#define IPU_PANEL_SERIAL		1
-#define IPU_PANEL_PARALLEL		2
-
-/*!
- * Enumeration of DI ports for ADC.
- */
-typedef enum {
-	DISP0,
-	DISP1,
-	DISP2,
-	DISP3
-} display_port_t;
-
-/*!
- * Enumeration of ADC channel operation mode.
- */
-typedef enum {
-	Disable,
-	WriteTemplateNonSeq,
-	ReadTemplateNonSeq,
-	WriteTemplateUnCon,
-	ReadTemplateUnCon,
-	WriteDataWithRS,
-	WriteDataWoRS,
-	WriteCmd
-} mcu_mode_t;
-
-/*!
- * Enumeration of ADC channel addressing mode.
- */
-typedef enum {
-	FullWoBE,
-	FullWithBE,
-	XY
-} display_addressing_t;
-
-/*!
- * Union of initialization parameters for a logical channel.
- */
-typedef union {
-	struct {
-		uint32_t csi;
-		bool mipi_en;
-		uint32_t mipi_id;
-	} csi_mem;
-	struct {
-		uint32_t in_width;
-		uint32_t in_height;
-		uint32_t in_pixel_fmt;
-		uint32_t out_width;
-		uint32_t out_height;
-		uint32_t out_pixel_fmt;
-		uint32_t csi;
-	} csi_prp_enc_mem;
-	struct {
-		uint32_t in_width;
-		uint32_t in_height;
-		uint32_t in_pixel_fmt;
-		uint32_t out_width;
-		uint32_t out_height;
-		uint32_t out_pixel_fmt;
-	} mem_prp_enc_mem;
-	struct {
-		uint32_t in_width;
-		uint32_t in_height;
-		uint32_t in_pixel_fmt;
-		uint32_t out_width;
-		uint32_t out_height;
-		uint32_t out_pixel_fmt;
-	} mem_rot_enc_mem;
-	struct {
-		uint32_t in_width;
-		uint32_t in_height;
-		uint32_t in_pixel_fmt;
-		uint32_t out_width;
-		uint32_t out_height;
-		uint32_t out_pixel_fmt;
-		bool graphics_combine_en;
-		bool global_alpha_en;
-		bool key_color_en;
-		uint32_t csi;
-	} csi_prp_vf_mem;
-	struct {
-		uint32_t in_width;
-		uint32_t in_height;
-		uint32_t in_pixel_fmt;
-		uint32_t out_width;
-		uint32_t out_height;
-		uint32_t out_pixel_fmt;
-		bool graphics_combine_en;
-		bool global_alpha_en;
-		bool key_color_en;
-		display_port_t disp;
-		uint32_t out_left;
-		uint32_t out_top;
-	} csi_prp_vf_adc;
-	struct {
-		uint32_t in_width;
-		uint32_t in_height;
-		uint32_t in_pixel_fmt;
-		uint32_t out_width;
-		uint32_t out_height;
-		uint32_t out_pixel_fmt;
-		bool graphics_combine_en;
-		bool global_alpha_en;
-		bool key_color_en;
-	} mem_prp_vf_mem;
-	struct {
-		uint32_t temp;
-	} mem_prp_vf_adc;
-	struct {
-		uint32_t temp;
-	} mem_rot_vf_mem;
-	struct {
-		uint32_t in_width;
-		uint32_t in_height;
-		uint32_t in_pixel_fmt;
-		uint32_t out_width;
-		uint32_t out_height;
-		uint32_t out_pixel_fmt;
-		bool graphics_combine_en;
-		bool global_alpha_en;
-		bool key_color_en;
-	} mem_pp_mem;
-	struct {
-		uint32_t temp;
-	} mem_rot_mem;
-	struct {
-		uint32_t in_width;
-		uint32_t in_height;
-		uint32_t in_pixel_fmt;
-		uint32_t out_width;
-		uint32_t out_height;
-		uint32_t out_pixel_fmt;
-		bool graphics_combine_en;
-		bool global_alpha_en;
-		bool key_color_en;
-		display_port_t disp;
-		uint32_t out_left;
-		uint32_t out_top;
-	} mem_pp_adc;
-	struct {
-		pf_operation_t operation;
-	} mem_pf_mem;
-	struct {
-		uint32_t di;
-		bool interlaced;
-	} mem_dc_sync;
-	struct {
-		uint32_t temp;
-	} mem_sdc_fg;
-	struct {
-		uint32_t di;
-		bool interlaced;
-		uint32_t in_pixel_fmt;
-		uint32_t out_pixel_fmt;
-	} mem_dp_bg_sync;
-	struct {
-		uint32_t temp;
-	} mem_sdc_bg;
-	struct {
-		uint32_t di;
-		bool interlaced;
-		uint32_t in_pixel_fmt;
-		uint32_t out_pixel_fmt;
-	} mem_dp_fg_sync;
-	struct {
-		uint32_t di;
-	} direct_async;
-	struct {
-		display_port_t disp;
-		mcu_mode_t ch_mode;
-		uint32_t out_left;
-		uint32_t out_top;
-	} adc_sys1;
-	struct {
-		display_port_t disp;
-		mcu_mode_t ch_mode;
-		uint32_t out_left;
-		uint32_t out_top;
-	} adc_sys2;
-} ipu_channel_params_t;
-
-/*!
- * Enumeration of IPU interrupt sources.
- */
-enum ipu_irq_line {
-#ifdef CONFIG_MXC_IPU_V1
-	IPU_IRQ_DC_FC_1 = -1,
-
-	IPU_IRQ_PRP_ENC_OUT_EOF = 0,
-	IPU_IRQ_PRP_VF_OUT_EOF = 1,
-	IPU_IRQ_PP_OUT_EOF = 2,
-	IPU_IRQ_PRP_GRAPH_IN_EOF = 3,
-	IPU_IRQ_PP_GRAPH_IN_EOF = 4,
-	IPU_IRQ_PP_IN_EOF = 5,
-	IPU_IRQ_PRP_IN_EOF = 6,
-	IPU_IRQ_SENSOR_OUT_EOF = 7,
-	IPU_IRQ_PRP_ENC_ROT_OUT_EOF = 8,
-	IPU_IRQ_PRP_VF_ROT_OUT_EOF = 9,
-	IPU_IRQ_PRP_ENC_ROT_IN_EOF = 10,
-	IPU_IRQ_PRP_VF_ROT_IN_EOF = 11,
-	IPU_IRQ_PP_ROT_OUT_EOF = 12,
-	IPU_IRQ_PP_ROT_IN_EOF = 13,
-	IPU_IRQ_BG_SYNC_EOF = 14,
-	IPU_IRQ_SDC_BG_EOF = IPU_IRQ_BG_SYNC_EOF,
-	IPU_IRQ_FG_SYNC_EOF = 15,
-	IPU_IRQ_SDC_FG_EOF = IPU_IRQ_FG_SYNC_EOF,
-	IPU_IRQ_SDC_MASK_EOF = 16,
-	IPU_IRQ_SDC_BG_PART_EOF = 17,
-	IPU_IRQ_ADC_SYS1_WR_EOF = 18,
-	IPU_IRQ_ADC_SYS2_WR_EOF = 19,
-	IPU_IRQ_ADC_SYS1_CMD_EOF = 20,
-	IPU_IRQ_ADC_SYS2_CMD_EOF = 21,
-	IPU_IRQ_ADC_SYS1_RD_EOF = 22,
-	IPU_IRQ_ADC_SYS2_RD_EOF = 23,
-	IPU_IRQ_PF_QP_IN_EOF = 24,
-	IPU_IRQ_PF_BSP_IN_EOF = 25,
-	IPU_IRQ_PF_Y_IN_EOF = 26,
-	IPU_IRQ_PF_U_IN_EOF = 27,
-	IPU_IRQ_PF_V_IN_EOF = 28,
-	IPU_IRQ_PF_Y_OUT_EOF = 29,
-	IPU_IRQ_PF_U_OUT_EOF = 30,
-	IPU_IRQ_PF_V_OUT_EOF = 31,
-
-	IPU_IRQ_PRP_ENC_OUT_NF = 32,
-	IPU_IRQ_PRP_VF_OUT_NF = 33,
-	IPU_IRQ_PP_OUT_NF = 34,
-	IPU_IRQ_PRP_GRAPH_IN_NF = 35,
-	IPU_IRQ_PP_GRAPH_IN_NF = 36,
-	IPU_IRQ_PP_IN_NF = 37,
-	IPU_IRQ_PRP_IN_NF = 38,
-	IPU_IRQ_SENSOR_OUT_NF = 39,
-	IPU_IRQ_PRP_ENC_ROT_OUT_NF = 40,
-	IPU_IRQ_PRP_VF_ROT_OUT_NF = 41,
-	IPU_IRQ_PRP_ENC_ROT_IN_NF = 42,
-	IPU_IRQ_PRP_VF_ROT_IN_NF = 43,
-	IPU_IRQ_PP_ROT_OUT_NF = 44,
-	IPU_IRQ_PP_ROT_IN_NF = 45,
-	IPU_IRQ_SDC_FG_NF = 46,
-	IPU_IRQ_SDC_BG_NF = 47,
-	IPU_IRQ_SDC_MASK_NF = 48,
-	IPU_IRQ_SDC_BG_PART_NF = 49,
-	IPU_IRQ_ADC_SYS1_WR_NF = 50,
-	IPU_IRQ_ADC_SYS2_WR_NF = 51,
-	IPU_IRQ_ADC_SYS1_CMD_NF = 52,
-	IPU_IRQ_ADC_SYS2_CMD_NF = 53,
-	IPU_IRQ_ADC_SYS1_RD_NF = 54,
-	IPU_IRQ_ADC_SYS2_RD_NF = 55,
-	IPU_IRQ_PF_QP_IN_NF = 56,
-	IPU_IRQ_PF_BSP_IN_NF = 57,
-	IPU_IRQ_PF_Y_IN_NF = 58,
-	IPU_IRQ_PF_U_IN_NF = 59,
-	IPU_IRQ_PF_V_IN_NF = 60,
-	IPU_IRQ_PF_Y_OUT_NF = 61,
-	IPU_IRQ_PF_U_OUT_NF = 62,
-	IPU_IRQ_PF_V_OUT_NF = 63,
-
-	IPU_IRQ_BREAKRQ = 64,
-	IPU_IRQ_SDC_BG_OUT_EOF = 65,
-	IPU_IRQ_BG_SF_END = IPU_IRQ_SDC_BG_OUT_EOF,
-	IPU_IRQ_SDC_FG_OUT_EOF = 66,
-	IPU_IRQ_SDC_MASK_OUT_EOF = 67,
-	IPU_IRQ_ADC_SERIAL_DATA_OUT = 68,
-	IPU_IRQ_SENSOR_NF = 69,
-	IPU_IRQ_SENSOR_EOF = 70,
-	IPU_IRQ_SDC_DISP3_VSYNC = 80,
-	IPU_IRQ_ADC_DISP0_VSYNC = 81,
-	IPU_IRQ_ADC_DISP12_VSYNC = 82,
-	IPU_IRQ_ADC_PRP_EOF = 83,
-	IPU_IRQ_ADC_PP_EOF = 84,
-	IPU_IRQ_ADC_SYS1_EOF = 85,
-	IPU_IRQ_ADC_SYS2_EOF = 86,
-
-	IPU_IRQ_PRP_ENC_OUT_NFB4EOF_ERR = 96,
-	IPU_IRQ_PRP_VF_OUT_NFB4EOF_ERR = 97,
-	IPU_IRQ_PP_OUT_NFB4EOF_ERR = 98,
-	IPU_IRQ_PRP_GRAPH_IN_NFB4EOF_ERR = 99,
-	IPU_IRQ_PP_GRAPH_IN_NFB4EOF_ERR = 100,
-	IPU_IRQ_PP_IN_NFB4EOF_ERR = 101,
-	IPU_IRQ_PRP_IN_NFB4EOF_ERR = 102,
-	IPU_IRQ_SENSOR_OUT_NFB4EOF_ERR = 103,
-	IPU_IRQ_PRP_ENC_ROT_OUT_NFB4EOF_ERR = 104,
-	IPU_IRQ_PRP_VF_ROT_OUT_NFB4EOF_ERR = 105,
-	IPU_IRQ_PRP_ENC_ROT_IN_NFB4EOF_ERR = 106,
-	IPU_IRQ_PRP_VF_ROT_IN_NFB4EOF_ERR = 107,
-	IPU_IRQ_PP_ROT_OUT_NFB4EOF_ERR = 108,
-	IPU_IRQ_PP_ROT_IN_NFB4EOF_ERR = 109,
-	IPU_IRQ_SDC_FG_NFB4EOF_ERR = 110,
-	IPU_IRQ_SDC_BG_NFB4EOF_ERR = 111,
-	IPU_IRQ_SDC_MASK_NFB4EOF_ERR = 112,
-	IPU_IRQ_SDC_BG_PART_NFB4EOF_ERR = 113,
-	IPU_IRQ_ADC_SYS1_WR_NFB4EOF_ERR = 114,
-	IPU_IRQ_ADC_SYS2_WR_NFB4EOF_ERR = 115,
-	IPU_IRQ_ADC_SYS1_CMD_NFB4EOF_ERR = 116,
-	IPU_IRQ_ADC_SYS2_CMD_NFB4EOF_ERR = 117,
-	IPU_IRQ_ADC_SYS1_RD_NFB4EOF_ERR = 118,
-	IPU_IRQ_ADC_SYS2_RD_NFB4EOF_ERR = 119,
-	IPU_IRQ_PF_QP_IN_NFB4EOF_ERR = 120,
-	IPU_IRQ_PF_BSP_IN_NFB4EOF_ERR = 121,
-	IPU_IRQ_PF_Y_IN_NFB4EOF_ERR = 122,
-	IPU_IRQ_PF_U_IN_NFB4EOF_ERR = 123,
-	IPU_IRQ_PF_V_IN_NFB4EOF_ERR = 124,
-	IPU_IRQ_PF_Y_OUT_NFB4EOF_ERR = 125,
-	IPU_IRQ_PF_U_OUT_NFB4EOF_ERR = 126,
-	IPU_IRQ_PF_V_OUT_NFB4EOF_ERR = 127,
-
-	IPU_IRQ_BAYER_BUFOVF_ERR = 128,
-	IPU_IRQ_ENC_BUFOVF_ERR = 129,
-	IPU_IRQ_VF_BUFOVF_ERR = 130,
-	IPU_IRQ_ADC_PP_TEAR_ERR = 131,
-	IPU_IRQ_ADC_SYS1_TEAR_ERR = 132,
-	IPU_IRQ_ADC_SYS2_TEAR_ERR = 133,
-	IPU_IRQ_SDC_BGD_ERR = 134,
-	IPU_IRQ_SDC_FGD_ERR = 135,
-	IPU_IRQ_SDC_MASKD_ERR = 136,
-	IPU_IRQ_BAYER_FRM_LOST_ERR = 137,
-	IPU_IRQ_ENC_FRM_LOST_ERR = 138,
-	IPU_IRQ_VF_FRM_LOST_ERR = 139,
-	IPU_IRQ_ADC_LOCK_ERR = 140,
-	IPU_IRQ_DI_LLA_LOCK_ERR = 141,
-	IPU_IRQ_AHB_M1_ERR = 142,
-	IPU_IRQ_AHB_M12_ERR = 143,
-#else
-	IPU_IRQ_CSI0_OUT_EOF = 0,
-	IPU_IRQ_CSI1_OUT_EOF = 1,
-	IPU_IRQ_CSI2_OUT_EOF = 2,
-	IPU_IRQ_CSI3_OUT_EOF = 3,
-	IPU_IRQ_PP_IN_EOF = 11,
-	IPU_IRQ_PRP_IN_EOF = 12,
-	IPU_IRQ_PRP_GRAPH_IN_EOF = 14,
-	IPU_IRQ_PP_GRAPH_IN_EOF = 15,
-	IPU_IRQ_PRP_ALPHA_IN_EOF = 17,
-	IPU_IRQ_PP_ALPHA_IN_EOF = 18,
-	IPU_IRQ_PRP_ENC_OUT_EOF = 20,
-	IPU_IRQ_PRP_VF_OUT_EOF = 21,
-	IPU_IRQ_PP_OUT_EOF = 22,
-	IPU_IRQ_BG_SYNC_EOF = 23,
-	IPU_IRQ_BG_ASYNC_EOF = 24,
-	IPU_IRQ_FG_SYNC_EOF = 27,
-	IPU_IRQ_DC_SYNC_EOF = 28,
-	IPU_IRQ_FG_ASYNC_EOF = 29,
-	IPU_IRQ_FG_ALPHA_SYNC_EOF = 31,
-
-	IPU_IRQ_FG_ALPHA_ASYNC_EOF = 33,
-	IPU_IRQ_DC_READ_EOF = 40,
-	IPU_IRQ_DC_ASYNC_EOF = 41,
-	IPU_IRQ_DC_CMD1_EOF = 42,
-	IPU_IRQ_DC_CMD2_EOF = 43,
-	IPU_IRQ_DC_MASK_EOF = 44,
-	IPU_IRQ_PRP_ENC_ROT_OUT_EOF = 45,
-	IPU_IRQ_PRP_VF_ROT_OUT_EOF = 46,
-	IPU_IRQ_PP_ROT_OUT_EOF = 47,
-	IPU_IRQ_PRP_ENC_ROT_IN_EOF = 48,
-	IPU_IRQ_PRP_VF_ROT_IN_EOF = 49,
-	IPU_IRQ_PP_ROT_IN_EOF = 50,
-	IPU_IRQ_BG_ALPHA_SYNC_EOF = 51,
-	IPU_IRQ_BG_ALPHA_ASYNC_EOF = 52,
-
-	IPU_IRQ_DP_SF_START = 448 + 2,
-	IPU_IRQ_DP_SF_END = 448 + 3,
-	IPU_IRQ_BG_SF_END = IPU_IRQ_DP_SF_END,
-	IPU_IRQ_DC_FC_0 = 448 + 8,
-	IPU_IRQ_DC_FC_1 = 448 + 9,
-	IPU_IRQ_DC_FC_2 = 448 + 10,
-	IPU_IRQ_DC_FC_3 = 448 + 11,
-	IPU_IRQ_DC_FC_4 = 448 + 12,
-	IPU_IRQ_DC_FC_6 = 448 + 13,
-	IPU_IRQ_VSYNC_PRE_0 = 448 + 14,
-	IPU_IRQ_VSYNC_PRE_1 = 448 + 15,
-#endif
-
-	IPU_IRQ_COUNT
-};
-
-/*!
- * Bitfield of Display Interface signal polarities.
- */
-typedef struct {
-	unsigned datamask_en:1;
-	unsigned ext_clk:1;
-	unsigned interlaced:1;
-	unsigned odd_field_first:1;
-	unsigned clksel_en:1;
-	unsigned clkidle_en:1;
-	unsigned data_pol:1;	/* true = inverted */
-	unsigned clk_pol:1;	/* true = rising edge */
-	unsigned enable_pol:1;
-	unsigned Hsync_pol:1;	/* true = active high */
-	unsigned Vsync_pol:1;
-} ipu_di_signal_cfg_t;
-
-/*!
- * Bitfield of CSI signal polarities and modes.
- */
-
-typedef struct {
-	unsigned data_width:4;
-	unsigned clk_mode:3;
-	unsigned ext_vsync:1;
-	unsigned Vsync_pol:1;
-	unsigned Hsync_pol:1;
-	unsigned pixclk_pol:1;
-	unsigned data_pol:1;
-	unsigned sens_clksrc:1;
-	unsigned pack_tight:1;
-	unsigned force_eof:1;
-	unsigned data_en_pol:1;
-	unsigned data_fmt;
-	unsigned csi;
-	unsigned mclk;
-} ipu_csi_signal_cfg_t;
-
-/*!
- * Enumeration of CSI data bus widths.
- */
-enum {
-	IPU_CSI_DATA_WIDTH_4,
-	IPU_CSI_DATA_WIDTH_8,
-	IPU_CSI_DATA_WIDTH_10,
-	IPU_CSI_DATA_WIDTH_16,
-};
-
-/*!
- * Enumeration of CSI clock modes.
- */
-enum {
-	IPU_CSI_CLK_MODE_GATED_CLK,
-	IPU_CSI_CLK_MODE_NONGATED_CLK,
-	IPU_CSI_CLK_MODE_CCIR656_PROGRESSIVE,
-	IPU_CSI_CLK_MODE_CCIR656_INTERLACED,
-	IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_DDR,
-	IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_SDR,
-	IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_DDR,
-	IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_SDR,
-};
-
-enum {
-	IPU_CSI_MIPI_DI0,
-	IPU_CSI_MIPI_DI1,
-	IPU_CSI_MIPI_DI2,
-	IPU_CSI_MIPI_DI3,
-};
-
-typedef enum {
-	RGB,
-	YCbCr,
-	YUV
-} ipu_color_space_t;
-
-/*!
- * Enumeration of ADC vertical sync mode.
- */
-typedef enum {
-	VsyncNone,
-	VsyncInternal,
-	VsyncCSI,
-	VsyncExternal
-} vsync_t;
-
-typedef enum {
-	DAT,
-	CMD
-} cmddata_t;
-
-/*!
- * Enumeration of ADC display update mode.
- */
-typedef enum {
-	IPU_ADC_REFRESH_NONE,
-	IPU_ADC_AUTO_REFRESH,
-	IPU_ADC_AUTO_REFRESH_SNOOP,
-	IPU_ADC_SNOOPING,
-} ipu_adc_update_mode_t;
-
-/*!
- * Enumeration of ADC display interface types (serial or parallel).
- */
-enum {
-	IPU_ADC_IFC_MODE_SYS80_TYPE1,
-	IPU_ADC_IFC_MODE_SYS80_TYPE2,
-	IPU_ADC_IFC_MODE_SYS68K_TYPE1,
-	IPU_ADC_IFC_MODE_SYS68K_TYPE2,
-	IPU_ADC_IFC_MODE_3WIRE_SERIAL,
-	IPU_ADC_IFC_MODE_4WIRE_SERIAL,
-	IPU_ADC_IFC_MODE_5WIRE_SERIAL_CLK,
-	IPU_ADC_IFC_MODE_5WIRE_SERIAL_CS,
-};
-
-enum {
-	IPU_ADC_IFC_WIDTH_8,
-	IPU_ADC_IFC_WIDTH_16,
-};
-
-/*!
- * Enumeration of ADC display interface burst mode.
- */
-enum {
-	IPU_ADC_BURST_WCS,
-	IPU_ADC_BURST_WBLCK,
-	IPU_ADC_BURST_NONE,
-	IPU_ADC_BURST_SERIAL,
-};
-
-/*!
- * Enumeration of ADC display interface RW signal timing modes.
- */
-enum {
-	IPU_ADC_SER_NO_RW,
-	IPU_ADC_SER_RW_BEFORE_RS,
-	IPU_ADC_SER_RW_AFTER_RS,
-};
-
-/*!
- * Bitfield of ADC signal polarities and modes.
- */
-typedef struct {
-	unsigned data_pol:1;
-	unsigned clk_pol:1;
-	unsigned cs_pol:1;
-	unsigned rs_pol:1;
-	unsigned addr_pol:1;
-	unsigned read_pol:1;
-	unsigned write_pol:1;
-	unsigned Vsync_pol:1;
-	unsigned burst_pol:1;
-	unsigned burst_mode:2;
-	unsigned ifc_mode:3;
-	unsigned ifc_width:5;
-	unsigned ser_preamble_len:4;
-	unsigned ser_preamble:8;
-	unsigned ser_rw_mode:2;
-} ipu_adc_sig_cfg_t;
-
-/*!
- * Enumeration of ADC template commands.
- */
-enum {
-	RD_DATA,
-	RD_ACK,
-	RD_WAIT,
-	WR_XADDR,
-	WR_YADDR,
-	WR_ADDR,
-	WR_CMND,
-	WR_DATA,
-};
-
-/*!
- * Enumeration of ADC template command flow control.
- */
-enum {
-	SINGLE_STEP,
-	PAUSE,
-	STOP,
-};
-
-/*Define template constants*/
-#define     ATM_ADDR_RANGE      0x20	/*offset address of DISP */
-#define     TEMPLATE_BUF_SIZE   0x20	/*size of template */
-
-/*!
- * Define to create ADC template command entry.
- */
-#define ipu_adc_template_gen(oc, rs, fc, dat) ( ((rs) << 29) | ((fc) << 27) | \
-                                                ((oc) << 24) | (dat) )
-
-typedef struct {
-	u32 reg;
-	u32 value;
-} ipu_lpmc_reg_t;
-
-#define IPU_LPMC_REG_READ       0x80000000L
-
-#define CSI_MCLK_VF  1
-#define CSI_MCLK_ENC 2
-#define CSI_MCLK_RAW 4
-#define CSI_MCLK_I2C 8
-
-/* Common IPU API */
-int32_t ipu_init_channel(ipu_channel_t channel, ipu_channel_params_t * params);
-void ipu_uninit_channel(ipu_channel_t channel);
-
-static inline bool ipu_can_rotate_in_place(ipu_rotate_mode_t rot)
-{
-#ifdef CONFIG_MXC_IPU_V3D
-	return (rot < IPU_ROTATE_HORIZ_FLIP);
-#else
-	return (rot < IPU_ROTATE_90_RIGHT);
-#endif
-}
-
-int32_t ipu_init_channel_buffer(ipu_channel_t channel, ipu_buffer_t type,
-				uint32_t pixel_fmt,
-				uint16_t width, uint16_t height,
-				uint32_t stride,
-				ipu_rotate_mode_t rot_mode,
-				dma_addr_t phyaddr_0, dma_addr_t phyaddr_1,
-				uint32_t u_offset, uint32_t v_offset);
-
-int32_t ipu_update_channel_buffer(ipu_channel_t channel, ipu_buffer_t type,
-				  uint32_t bufNum, dma_addr_t phyaddr);
-
-int32_t ipu_select_buffer(ipu_channel_t channel,
-			  ipu_buffer_t type, uint32_t bufNum);
-
-int32_t ipu_link_channels(ipu_channel_t src_ch, ipu_channel_t dest_ch);
-int32_t ipu_unlink_channels(ipu_channel_t src_ch, ipu_channel_t dest_ch);
-
-int32_t ipu_enable_channel(ipu_channel_t channel);
-int32_t ipu_disable_channel(ipu_channel_t channel, bool wait_for_stop);
-
-int ipu_lowpwr_display_enable(void);
-int ipu_lowpwr_display_disable(void);
-
-void ipu_enable_irq(uint32_t irq);
-void ipu_disable_irq(uint32_t irq);
-void ipu_clear_irq(uint32_t irq);
-int ipu_request_irq(uint32_t irq,
-		    irqreturn_t(*handler) (int, void *),
-		    uint32_t irq_flags, const char *devname, void *dev_id);
-void ipu_free_irq(uint32_t irq, void *dev_id);
-bool ipu_get_irq_status(uint32_t irq);
-void ipu_set_csc_coefficients(ipu_channel_t channel, int32_t param[][3]);
-
-/* SDC API */
-int32_t ipu_sdc_init_panel(ipu_panel_t panel,
-			   uint32_t pixel_clk,
-			   uint16_t width, uint16_t height,
-			   uint32_t pixel_fmt,
-			   uint16_t hStartWidth, uint16_t hSyncWidth,
-			   uint16_t hEndWidth, uint16_t vStartWidth,
-			   uint16_t vSyncWidth, uint16_t vEndWidth,
-			   ipu_di_signal_cfg_t sig);
-
-int32_t ipu_sdc_set_global_alpha(bool enable, uint8_t alpha);
-int32_t ipu_sdc_set_color_key(ipu_channel_t channel, bool enable,
-			      uint32_t colorKey);
-int32_t ipu_sdc_set_brightness(uint8_t value);
-
-int32_t ipu_init_sync_panel(int disp,
-			    uint32_t pixel_clk,
-			    uint16_t width, uint16_t height,
-			    uint32_t pixel_fmt,
-			    uint16_t h_start_width, uint16_t h_sync_width,
-			    uint16_t h_end_width, uint16_t v_start_width,
-			    uint16_t v_sync_width, uint16_t v_end_width,
-			    uint32_t v_to_h_sync, ipu_di_signal_cfg_t sig);
-
-int32_t ipu_disp_set_window_pos(ipu_channel_t channel, int16_t x_pos,
-				int16_t y_pos);
-int32_t ipu_disp_set_global_alpha(ipu_channel_t channel, bool enable,
-				  uint8_t alpha);
-int32_t ipu_disp_set_color_key(ipu_channel_t channel, bool enable,
-			       uint32_t colorKey);
-
-int ipu_init_async_panel(int disp, int type, uint32_t cycle_time,
-			 uint32_t pixel_fmt, ipu_adc_sig_cfg_t sig);
-void ipu_disp_direct_write(ipu_channel_t channel, u32 value, u32 offset);
-void ipu_reset_disp_panel(void);
-
-/* ADC API */
-int32_t ipu_adc_write_template(display_port_t disp, uint32_t * pCmd,
-			       bool write);
-
-int32_t ipu_adc_set_update_mode(ipu_channel_t channel,
-				ipu_adc_update_mode_t mode,
-				uint32_t refresh_rate, unsigned long addr,
-				uint32_t * size);
-
-int32_t ipu_adc_get_snooping_status(uint32_t * statl, uint32_t * stath);
-
-int32_t ipu_adc_write_cmd(display_port_t disp, cmddata_t type,
-			  uint32_t cmd, const uint32_t * params,
-			  uint16_t numParams);
-
-int32_t ipu_adc_init_panel(display_port_t disp,
-			   uint16_t width, uint16_t height,
-			   uint32_t pixel_fmt,
-			   uint32_t stride,
-			   ipu_adc_sig_cfg_t sig,
-			   display_addressing_t addr,
-			   uint32_t vsync_width, vsync_t mode);
-
-int32_t ipu_adc_init_ifc_timing(display_port_t disp, bool read,
-				uint32_t cycle_time,
-				uint32_t up_time,
-				uint32_t down_time,
-				uint32_t read_latch_time, uint32_t pixel_clk);
-
-/* CMOS Sensor Interface API */
-int32_t ipu_csi_init_interface(uint16_t width, uint16_t height,
-			       uint32_t pixel_fmt, ipu_csi_signal_cfg_t sig);
-
-int32_t ipu_csi_enable_mclk(int src, bool flag, bool wait);
-
-static inline int32_t ipu_csi_enable_mclk_if(int src, uint32_t csi,
-		bool flag, bool wait)
-{
-#ifdef CONFIG_MXC_IPU_V1
-	return ipu_csi_enable_mclk(src, flag, wait);
-#else
-	return ipu_csi_enable_mclk(csi, flag, wait);
-#endif
-}
-
-int ipu_csi_read_mclk_flag(void);
-
-void ipu_csi_flash_strobe(bool flag);
-
-void ipu_csi_get_window_size(uint32_t *width, uint32_t *height, uint32_t csi);
-
-void ipu_csi_set_window_size(uint32_t width, uint32_t height, uint32_t csi);
-
-void ipu_csi_set_window_pos(uint32_t left, uint32_t top, uint32_t csi);
-
-/* Post Filter functions */
-int32_t ipu_pf_set_pause_row(uint32_t pause_row);
-
-uint32_t bytes_per_pixel(uint32_t fmt);
-
-/* New added for IPU-lib functionality*/
-int ipu_open(void);
-int ipu_register_generic_isr(int irq, void *dev);
-void ipu_close(void);
-
-typedef struct _ipu_channel_parm {
-	ipu_channel_t channel;
-	ipu_channel_params_t params;
-	bool flag;
-} ipu_channel_parm;
-
-typedef struct _ipu_channel_buf_parm {
-	ipu_channel_t channel;
-	ipu_buffer_t type;
-	uint32_t pixel_fmt;
-	uint16_t width;
-	uint16_t height;
-	uint16_t stride;
-	ipu_rotate_mode_t rot_mode;
-	dma_addr_t phyaddr_0;
-	dma_addr_t phyaddr_1;
-	uint32_t u_offset;
-	uint32_t v_offset;
-	uint32_t bufNum;
-} ipu_channel_buf_parm;
-
-typedef struct _ipu_channel_link {
-	ipu_channel_t src_ch;
-	ipu_channel_t dest_ch;
-} ipu_channel_link;
-
-typedef struct _ipu_channel_info {
-	ipu_channel_t channel;
-	bool stop;
-} ipu_channel_info;
-
-typedef struct ipu_irq_info {
-	uint32_t irq;
-	 irqreturn_t(*handler) (int, void *);
-	uint32_t irq_flags;
-	char *devname;
-	void *dev_id;
-} ipu_irq_info;
-
-typedef struct _ipu_sdc_panel_info {
-	ipu_panel_t panel;
-	uint32_t pixel_clk;
-	uint16_t width;
-	uint16_t height;
-	uint32_t pixel_fmt;
-	uint16_t hStartWidth;
-	uint16_t hSyncWidth;
-	uint16_t hEndWidth;
-	uint16_t vStartWidth;
-	uint16_t vSyncWidth;
-	uint16_t vEndWidth;
-	ipu_di_signal_cfg_t signal;
-} ipu_sdc_panel_info;
-
-typedef struct _ipu_sdc_window_pos {
-	ipu_channel_t channel;
-	int16_t x_pos;
-	int16_t y_pos;
-} ipu_sdc_window_pos;
-
-typedef struct _ipu_sdc_global_alpha {
-	bool enable;
-	uint8_t alpha;
-} ipu_sdc_global_alpha;
-
-typedef struct _ipu_sdc_color_key {
-	ipu_channel_t channel;
-	bool enable;
-	uint32_t colorKey;
-} ipu_sdc_color_key;
-
-typedef struct _ipu_adc_template {
-	display_port_t disp;
-	uint32_t *pCmd;
-	bool write;
-} ipu_adc_template;
-
-typedef struct _ipu_adc_update {
-	ipu_channel_t channel;
-	ipu_adc_update_mode_t mode;
-	uint32_t refresh_rate;
-	unsigned long addr;
-	uint32_t *size;
-} ipu_adc_update;
-
-typedef struct _ipu_adc_snoop {
-	uint32_t *statl;
-	uint32_t *stath;
-} ipu_adc_snoop;
-
-typedef struct _ipu_adc_cmd {
-	display_port_t disp;
-	cmddata_t type;
-	uint32_t cmd;
-	uint32_t *params;
-	uint16_t numParams;
-} ipu_adc_cmd;
-
-typedef struct _ipu_adc_panel {
-	display_port_t disp;
-	uint16_t width;
-	uint16_t height;
-	uint32_t pixel_fmt;
-	uint32_t stride;
-	ipu_adc_sig_cfg_t signal;
-	display_addressing_t addr;
-	uint32_t vsync_width;
-	vsync_t mode;
-} ipu_adc_panel;
-
-typedef struct _ipu_adc_ifc_timing {
-	display_port_t disp;
-	bool read;
-	uint32_t cycle_time;
-	uint32_t up_time;
-	uint32_t down_time;
-	uint32_t read_latch_time;
-	uint32_t pixel_clk;
-} ipu_adc_ifc_timing;
-
-typedef struct _ipu_csi_interface {
-	uint16_t width;
-	uint16_t height;
-	uint16_t pixel_fmt;
-	ipu_csi_signal_cfg_t signal;
-} ipu_csi_interface;
-
-typedef struct _ipu_csi_mclk {
-	int src;
-	bool flag;
-	bool wait;
-} ipu_csi_mclk;
-
-typedef struct _ipu_csi_window {
-	uint32_t left;
-	uint32_t top;
-} ipu_csi_window;
-
-typedef struct _ipu_csi_window_size {
-	uint32_t width;
-	uint32_t height;
-} ipu_csi_window_size;
-
-typedef struct _ipu_event_info {
-	int irq;
-	void *dev;
-} ipu_event_info;
-
-typedef struct _ipu_mem_info {
-	dma_addr_t paddr;
-	void *vaddr;
-	int size;
-} ipu_mem_info;
-
-/* IOCTL commands */
-
-#define IPU_INIT_CHANNEL              _IOW('I',0x1,ipu_channel_parm)
-#define IPU_UNINIT_CHANNEL            _IOW('I',0x2,ipu_channel_t)
-#define IPU_INIT_CHANNEL_BUFFER       _IOW('I',0x3,ipu_channel_buf_parm)
-#define IPU_UPDATE_CHANNEL_BUFFER     _IOW('I',0x4,ipu_channel_buf_parm)
-#define IPU_SELECT_CHANNEL_BUFFER     _IOW('I',0x5,ipu_channel_buf_parm)
-#define IPU_LINK_CHANNELS             _IOW('I',0x6,ipu_channel_link)
-#define IPU_UNLINK_CHANNELS           _IOW('I',0x7,ipu_channel_link)
-#define IPU_ENABLE_CHANNEL            _IOW('I',0x8,ipu_channel_t)
-#define IPU_DISABLE_CHANNEL           _IOW('I',0x9,ipu_channel_info)
-#define IPU_ENABLE_IRQ                _IOW('I',0xA,int)
-#define IPU_DISABLE_IRQ               _IOW('I',0xB,int)
-#define IPU_CLEAR_IRQ                 _IOW('I',0xC,int)
-#define IPU_FREE_IRQ                  _IOW('I',0xD,ipu_irq_info)
-#define IPU_REQUEST_IRQ_STATUS        _IOW('I',0xE,int)
-#define IPU_SDC_INIT_PANEL            _IOW('I',0xF,ipu_sdc_panel_info)
-#define IPU_SDC_SET_WIN_POS           _IOW('I',0x10,ipu_sdc_window_pos)
-#define IPU_SDC_SET_GLOBAL_ALPHA      _IOW('I',0x11,ipu_sdc_global_alpha)
-#define IPU_SDC_SET_COLOR_KEY         _IOW('I',0x12,ipu_sdc_color_key)
-#define IPU_SDC_SET_BRIGHTNESS        _IOW('I',0x13,int)
-#define IPU_ADC_WRITE_TEMPLATE        _IOW('I',0x14,ipu_adc_template)
-#define IPU_ADC_UPDATE                _IOW('I',0x15,ipu_adc_update)
-#define IPU_ADC_SNOOP                 _IOW('I',0x16,ipu_adc_snoop)
-#define IPU_ADC_CMD                   _IOW('I',0x17,ipu_adc_cmd)
-#define IPU_ADC_INIT_PANEL            _IOW('I',0x18,ipu_adc_panel)
-#define IPU_ADC_IFC_TIMING            _IOW('I',0x19,ipu_adc_ifc_timing)
-#define IPU_CSI_INIT_INTERFACE        _IOW('I',0x1A,ipu_csi_interface)
-#define IPU_CSI_ENABLE_MCLK           _IOW('I',0x1B,ipu_csi_mclk)
-#define IPU_CSI_READ_MCLK_FLAG        _IOR('I',0x1C,ipu_csi_mclk)
-#define IPU_CSI_FLASH_STROBE          _IOW('I',0x1D,ipu_csi_mclk)
-#define IPU_CSI_GET_WIN_SIZE          _IOR('I',0x1E,ipu_csi_window_size)
-#define IPU_CSI_SET_WIN_SIZE          _IOW('I',0x1F,ipu_csi_window_size)
-#define IPU_CSI_SET_WINDOW            _IOW('I',0x20,ipu_csi_window)
-#define IPU_PF_SET_PAUSE_ROW          _IOW('I',0x21, uint32_t)
-#define IPU_REGISTER_GENERIC_ISR      _IOW('I',0x22,ipu_event_info)
-#define IPU_GET_EVENT                 _IOR('I',0x23,ipu_event_info)
-#define IPU_ALOC_MEM		      _IOWR('I', 0x24, ipu_mem_info)
-#define IPU_FREE_MEM		      _IOW('I', 0x25, ipu_mem_info)
-
-#endif
diff --git a/include/asm-arm/arch-mxc/mxc_asrc.h b/include/asm-arm/arch-mxc/mxc_asrc.h
deleted file mode 100644
index 5a47691..0000000
--- a/include/asm-arm/arch-mxc/mxc_asrc.h
+++ /dev/null
@@ -1,198 +0,0 @@
-/*
- * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-
-/*!
- * @file mx35_asrc.h
- *
- * @brief MX35 Asynchronous Sample Rate Converter
- *
- * @ingroup ??
- */
-
-#ifndef __MXC_ASRC_H__
-#define __MXC_ASRC_H__
-
-#define ASRC_IOC_MAGIC	'C'
-
-#define ASRC_REQ_PAIR	_IOWR(ASRC_IOC_MAGIC, 0, struct asrc_req)
-#define ASRC_CONIFG_PAIR	_IOWR(ASRC_IOC_MAGIC, 1, struct asrc_config)
-#define ASRC_RELEASE_PAIR	_IOW(ASRC_IOC_MAGIC, 2, enum asrc_pair_index)
-#define ASRC_QUERYBUF	_IOWR(ASRC_IOC_MAGIC, 3, struct asrc_buffer)
-#define ASRC_Q_INBUF	_IOW(ASRC_IOC_MAGIC, 4, struct asrc_buffer)
-#define ASRC_DQ_INBUF	_IOW(ASRC_IOC_MAGIC, 5, struct asrc_buffer)
-#define ASRC_Q_OUTBUF	_IOW(ASRC_IOC_MAGIC, 6, struct asrc_buffer)
-#define ASRC_DQ_OUTBUF	_IOW(ASRC_IOC_MAGIC, 7, struct asrc_buffer)
-#define ASRC_START_CONV	_IOW(ASRC_IOC_MAGIC, 8, enum asrc_pair_index)
-#define ASRC_STOP_CONV	_IOW(ASRC_IOC_MAGIC, 9, enum asrc_pair_index)
-
-enum asrc_pair_index {
-	ASRC_PAIR_A,
-	ASRC_PAIR_B,
-	ASRC_PAIR_C
-};
-
-enum asrc_inclk {
-	INCLK_NONE = 0x03,
-	INCLK_ESAI_RX = 0x00,
-	INCLK_SSI1_RX = 0x01,
-	INCLK_SSI2_RX = 0x02,
-	INCLK_SPDIF_RX = 0x04,
-	INCLK_MLB_CLK = 0x05,
-	INCLK_ESAI_TX = 0x08,
-	INCLK_SSI1_TX = 0x09,
-	INCLK_SSI2_TX = 0x0a,
-	INCLK_SPDIF_TX = 0x0c,
-	INCLK_ASRCK1_CLK = 0x0f,
-};
-
-enum asrc_outclk {
-	OUTCLK_NONE = 0x03,
-	OUTCLK_ESAI_TX = 0x00,
-	OUTCLK_SSI1_TX = 0x01,
-	OUTCLK_SSI2_TX = 0x02,
-	OUTCLK_SPDIF_TX = 0x04,
-	OUTCLK_MLB_CLK = 0x05,
-	OUTCLK_ESAI_RX = 0x08,
-	OUTCLK_SSI1_RX = 0x09,
-	OUTCLK_SSI2_RX = 0x0a,
-	OUTCLK_SPDIF_RX = 0x0c,
-	OUTCLK_ASRCK1_CLK = 0x0f,
-};
-
-struct asrc_config {
-	enum asrc_pair_index pair;
-	unsigned int channel_num;
-	unsigned int buffer_num;
-	unsigned int dma_buffer_size;
-	unsigned int input_sample_rate;
-	unsigned int output_sample_rate;
-	enum asrc_inclk inclk;
-	enum asrc_outclk outclk;
-};
-
-struct asrc_pair {
-	unsigned int start_channel;
-	unsigned int chn_num;
-	unsigned int chn_max;
-	unsigned int active;
-};
-
-struct asrc_req {
-	unsigned int chn_num;
-	enum asrc_pair_index index;
-};
-
-struct asrc_querybuf {
-	unsigned int buffer_index;
-	unsigned int input_length;
-	unsigned int output_length;
-	unsigned long input_offset;
-	unsigned long output_offset;
-};
-
-struct asrc_buffer {
-	unsigned int index;
-	unsigned int length;
-};
-
-#ifdef __KERNEL__
-
-#define ASRC_DMA_BUFFER_NUM 8
-
-#define ASRC_ASRCTR_REG 	0x00
-#define ASRC_ASRIER_REG 	0x04
-#define ASRC_ASRCNCR_REG 	0x0C
-#define ASRC_ASRCFG_REG 	0x10
-#define ASRC_ASRCSR_REG 	0x14
-#define ASRC_ASRCDR1_REG 	0x18
-#define ASRC_ASRCDR2_REG 	0x1C
-#define ASRC_ASRSTR_REG 	0x20
-#define ASRC_ASRRA_REG 		0x24
-#define ASRC_ASRRB_REG 		0x28
-#define ASRC_ASRRC_REG 		0x2C
-#define ASRC_ASRPM1_REG 	0x40
-#define ASRC_ASRPM2_REG 	0x44
-#define ASRC_ASRPM3_REG 	0x48
-#define ASRC_ASRPM4_REG 	0x4C
-#define ASRC_ASRPM5_REG 	0x50
-#define ASRC_ASRTFR1		0x54
-#define ASRC_ASRCCR_REG 	0x5C
-#define ASRC_ASRDIA_REG 	0x60
-#define ASRC_ASRDOA_REG 	0x64
-#define ASRC_ASRDIB_REG 	0x68
-#define ASRC_ASRDOB_REG 	0x6C
-#define ASRC_ASRDIC_REG 	0x70
-#define ASRC_ASRDOC_REG 	0x74
-#define ASRC_ASRIDRHA_REG 	0x80
-#define ASRC_ASRIDRLA_REG 	0x84
-#define ASRC_ASRIDRHB_REG 	0x88
-#define ASRC_ASRIDRLB_REG 	0x8C
-#define ASRC_ASRIDRHC_REG 	0x90
-#define ASRC_ASRIDRLC_REG 	0x94
-#define ASRC_ASR76K_REG 	0x98
-#define ASRC_ASR56K_REG 	0x9C
-
-struct dma_block {
-	unsigned int index;
-	unsigned int length;
-	unsigned char *dma_vaddr;
-	dma_addr_t dma_paddr;
-	struct list_head queue;
-};
-
-struct asrc_pair_params {
-	enum asrc_pair_index index;
-	struct list_head input_queue;
-	struct list_head input_done_queue;
-	struct list_head output_queue;
-	struct list_head output_done_queue;
-	wait_queue_head_t input_wait_queue;
-	wait_queue_head_t output_wait_queue;
-	unsigned int input_counter;
-	unsigned int output_counter;
-	unsigned int input_queue_empty;
-	unsigned int output_queue_empty;
-	unsigned int input_dma_channel;
-	unsigned int output_dma_channel;
-	unsigned int input_buffer_size;
-	unsigned int output_buffer_size;
-	unsigned int buffer_num;
-	unsigned int pair_hold;
-	unsigned int asrc_active;
-	struct dma_block input_dma[ASRC_DMA_BUFFER_NUM];
-	struct dma_block output_dma[ASRC_DMA_BUFFER_NUM];
-	struct semaphore busy_lock;
-};
-
-struct asrc_data {
-	struct asrc_pair asrc_pair[3];
-};
-
-char *asrc_pair_id[] = {
-	[0] = "ASRC RX PAIR A",
-	[1] = "ASRC TX PAIR A",
-	[2] = "ASRC RX PAIR B",
-	[3] = "ASRC TX PAIR B",
-	[4] = "ASRC RX PAIR C",
-	[5] = "ASRC TX PAIR C",
-};
-
-extern int asrc_req_pair(int chn_num, enum asrc_pair_index *index);
-extern void asrc_release_pair(enum asrc_pair_index index);
-extern int asrc_config_pair(struct asrc_config *config);
-extern void asrc_start_conv(enum asrc_pair_index index);
-extern void asrc_stop_conv(enum asrc_pair_index index);
-
-#endif				/* __kERNEL__ */
-
-#endif				/* __MXC_ASRC_H__ */
diff --git a/include/asm-arm/arch-mxc/mxc_mlb.h b/include/asm-arm/arch-mxc/mxc_mlb.h
deleted file mode 100644
index b91294d..0000000
--- a/include/asm-arm/arch-mxc/mxc_mlb.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * mxc_mlb.h
- *
- * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-
-#ifndef _MXC_MLB_H
-#define _MXC_MLB_H
-
-/* define IOCTL command */
-#define MLB_SET_FPS		_IOW('S', 0x10, unsigned int)
-#define MLB_GET_VER		_IOR('S', 0x11, unsigned long)
-#define MLB_SET_DEVADDR		_IOR('S', 0x12, unsigned char)
-/*!
- * set channel address for each logical channel
- * the MSB 16bits is for tx channel, the left LSB is for rx channel
- */
-#define MLB_CHAN_SETADDR	_IOW('S', 0x13, unsigned int)
-#define MLB_CHAN_STARTUP	_IO('S', 0x14)
-#define MLB_CHAN_SHUTDOWN	_IO('S', 0x15)
-#define MLB_CHAN_GETEVENT	_IOR('S', 0x16, unsigned long)
-
-/*!
- * MLB event define
- */
-enum {
-	MLB_EVT_TX_PROTO_ERR_CUR = 1 << 0,
-	MLB_EVT_TX_BRK_DETECT_CUR = 1 << 1,
-	MLB_EVT_TX_PROTO_ERR_PREV = 1 << 8,
-	MLB_EVT_TX_BRK_DETECT_PREV = 1 << 9,
-	MLB_EVT_RX_PROTO_ERR_CUR = 1 << 16,
-	MLB_EVT_RX_BRK_DETECT_CUR = 1 << 17,
-	MLB_EVT_RX_PROTO_ERR_PREV = 1 << 24,
-	MLB_EVT_RX_BRK_DETECT_PREV = 1 << 25,
-};
-
-#ifdef __KERNEL__
-extern void gpio_mlb_active(void);
-extern void gpio_mlb_inactive(void);
-#endif
-
-#endif				/* _MXC_MLB_H */
diff --git a/include/asm-arm/arch-mxc/mxc_pf.h b/include/asm-arm/arch-mxc/mxc_pf.h
deleted file mode 100644
index 990b12d..0000000
--- a/include/asm-arm/arch-mxc/mxc_pf.h
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU Lesser General
- * Public License.  You may obtain a copy of the GNU Lesser General
- * Public License Version 2.1 or later at the following locations:
- *
- * http://www.opensource.org/licenses/lgpl-license.html
- * http://www.gnu.org/copyleft/lgpl.html
- */
-
-/*!
- * @defgroup MXC_PF MPEG4/H.264 Post Filter Driver
- */
-/*!
- * @file arch-mxc/mxc_pf.h
- *
- * @brief MXC IPU MPEG4/H.264 Post-filtering driver
- *
- * User-level API for IPU Hardware MPEG4/H.264 Post-filtering.
- *
- * @ingroup MXC_PF
- */
-#ifndef __INCLUDED_MXC_PF_H__
-#define __INCLUDED_MXC_PF_H__
-
-#define PF_MAX_BUFFER_CNT       17
-
-#define PF_WAIT_Y	0x0001
-#define PF_WAIT_U	0x0002
-#define PF_WAIT_V	0x0004
-#define PF_WAIT_ALL	(PF_WAIT_Y|PF_WAIT_U|PF_WAIT_V)
-
-/*!
- * Structure for Post Filter initialization parameters.
- */
-typedef struct {
-	uint16_t pf_mode;	/*!< Post filter operation mode */
-	uint16_t width;		/*!< Width of frame in pixels */
-	uint16_t height;	/*!< Height of frame in pixels */
-	uint16_t stride;	/*!< Stride of Y plane in pixels. Stride for U and V planes is half Y stride */
-	uint32_t qp_size;
-	unsigned long qp_paddr;
-} pf_init_params;
-
-/*!
- * Structure for Post Filter buffer request parameters.
- */
-typedef struct {
-	int count;		/*!< Number of buffers requested */
-	__u32 req_size;
-} pf_reqbufs_params;
-
-/*!
- * Structure for Post Filter buffer request parameters.
- */
-typedef struct {
-	int index;
-	int size;		/*!< Size of buffer allocated */
-	__u32 offset;		/*!< Buffer offset in driver memory. Set by QUERYBUF */
-	__u32 y_offset;		/*!< Optional starting relative offset of Y data
-				   from beginning of buffer. Set to 0 to use default
-				   calculated based on height and stride */
-	__u32 u_offset;		/*!< Optional starting relative offset of U data
-				   from beginning of buffer. Set to 0 to use default
-				   calculated based on height and stride */
-	__u32 v_offset;		/*!< Optional starting relative offset of V data
-				   from beginning of buffer. Set to 0 to use default
-				   calculated based on height and stride */
-} pf_buf;
-
-/*!
- * Structure for Post Filter start parameters.
- */
-typedef struct {
-	pf_buf in;		/*!< Input buffer address and offsets */
-	pf_buf out;		/*!< Output buffer address and offsets */
-	int qp_buf;
-	int wait;
-	uint32_t h264_pause_row;	/*!< Row to pause at for H.264 mode. 0 to disable pause */
-} pf_start_params;
-
-/*! @name User Client Ioctl Interface */
-/*! @{ */
-
-/*!
- * IOCTL to Initialize the Post Filter.
- */
-#define PF_IOCTL_INIT           _IOW('F',0x0, pf_init_params)
-
-/*!
- * IOCTL to Uninitialize the Post Filter.
- */
-#define PF_IOCTL_UNINIT         _IO('F',0x1)
-
-/*!
- * IOCTL to set the buffer mode and allocate buffers if driver allocated.
- */
-#define PF_IOCTL_REQBUFS        _IOWR('F',0x2, pf_reqbufs_params)
-
-/*!
- * IOCTL to set the buffer mode and allocate buffers if driver allocated.
- */
-#define PF_IOCTL_QUERYBUF       _IOR('F',0x2, pf_buf)
-
-/*!
- * IOCTL to start post filtering on a frame of data. This ioctl may block until
- * processing is done or return immediately.
- */
-#define PF_IOCTL_START          _IOWR('F',0x3, pf_start_params)
-
-/*!
- * IOCTL to resume post-filtering after an intra frame pause in H.264 mode.
- */
-#define PF_IOCTL_RESUME         _IOW('F',0x4, int)
-
-/*!
- * IOCTL to wait for post-filtering to complete.
- */
-#define PF_IOCTL_WAIT           _IOW('F',0x5, int)
-/*! @} */
-
-#endif				/* __INCLUDED_MXC_PF_H__ */
diff --git a/include/asm-arm/arch-mxc/mxc_scc2_driver.h b/include/asm-arm/arch-mxc/mxc_scc2_driver.h
deleted file mode 100644
index f8a24f2..0000000
--- a/include/asm-arm/arch-mxc/mxc_scc2_driver.h
+++ /dev/null
@@ -1,973 +0,0 @@
-
-/*
- * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-
-#ifndef SCC_DRIVER_H
-#define SCC_DRIVER_H
-
-/*
- * NAMING CONVENTIONS
- * ==================
- * (A note to maintainers and other interested parties)
- *
- * Use scc_ or SCC_ prefix for 'high-level' interface routines and the types
- * passed to those routines.  Try to avoid #defines in these interfaces.
- *
- * Use SMN_ or SCM_ prefix for the #defines used with scc_read_register() and
- * scc_write_register, or values passed/retrieved from those routines.
- */
-
-/*! @file mxc_scc2_driver.h
- *
- * @brief (Header file to use the SCC2 driver.)
- *
- * The SCC2 driver is available to other kernel modules directly.  Secure
- * Partition functionality is extended to users through the SHW API.  Other
- * functionality of the SCC2 is limited to kernel-space users.
- *
- * With the exception of #scc_monitor_security_failure(), all routines are
- * 'synchronous', i.e. they will not return to their caller until the requested
- * action is complete, or fails to complete.  Some of these functions could
- * take quite a while to perform, depending upon the request.
- *
- * Routines are provided to:
- * @li trigger a security-violation alarm - #scc_set_sw_alarm()
- * @li get configuration and version information - #scc_get_configuration()
- * @li zeroize memory - #scc_zeroize_memories()
- * @li Work with secure partitions: #scc_allocate_partition()
- *     #scc_engage_partition() #scc_diminish_permissions() 
- *     #scc_release_partition()
- * @li Encrypt or decrypt regions of data: #scc_encrypt_region()
- *     #scc_decrypt_region()
- * @li monitor the Security Failure alarm - #scc_monitor_security_failure()
- * @li stop monitoring Security Failure alarm -
- *     #scc_stop_monitoring_security_failure()
- * @li write registers of the SCC - #scc_write_register()
- * @li read registers of the SCC - #scc_read_register()
- *
- * The SCC2 encrypts and decrypts using Triple DES with an internally stored
- * key.  When the SCC2 is in Secure mode, it uses its secret, unique-per-chip
- * key.  When it is in Non-Secure mode, it uses a default key.  This ensures
- * that secrets stay secret if the SCC2 is not in Secure mode.
- *
- * Not all functions that could be provided in a 'high level' manner have been
- * implemented.  Among the missing are interfaces to the ASC/AIC components and
- * the timer functions.  These and other features must be accessed through
- * #scc_read_register() and #scc_write_register(), using the @c \#define values
- * provided.
- *
- * Here is a glossary of acronyms used in the SCC2 driver documentation:
- * - CBC - Cipher Block Chaining.  A method of performing a block cipher.
- *    Each block is encrypted using some part of the result of the previous
- *    block's encryption.  It needs an 'initialization vector' to seed the
- *    operation.
- * - ECB - Electronic Code Book.  A method of performing a block cipher.
- *    With a given key, a given block will always encrypt to the same value.
- * - DES - Data Encryption Standard.  (8-byte) Block cipher algorithm which
- *    uses 56-bit keys.  In SCC2, this key is constant and unique to the device.
- *    SCC uses the "triple DES" form of this algorithm.
- * - AIC - Algorithm Integrity Checker.
- * - ASC - Algorithm Sequence Checker.
- * - SMN - Security Monitor.  The part of the SCC2 responsible for monitoring
- *    for security problems and notifying the CPU and other PISA components.
- * - SCM - Secure Memory.  The part of the SCC2 which handles the cryptography.
- * - SCC - Security Controller.  Central security mechanism for PISA.
- * - PISA - Platform-Independent Security Architecture.
- */
-
-/* Temporarily define compile-time flags to make Doxygen happy. */
-#ifdef DOXYGEN_HACK
-/** @defgroup scccompileflags SCC Driver compile-time flags
- *
- * These preprocessor flags should be set, if desired, in a makefile so
- * that they show up on the compiler command line.
- */
-/** @addtogroup scccompileflags */
-
-/** @{ */
-/**
- * Compile-time flag to change @ref smnregs and @ref scmregs
- * offset values for the SCC's implementation on the MX.21 board.
- *
- * This must also be set properly for any code which calls the
- * scc_read_register() or scc_write_register() functions or references the
- * register offsets.
- */
-#define TAHITI
-/** @} */
-#undef TAHITI
-
-#endif				/* DOXYGEN_HACK */
-
-/*! Major Version of the driver.  Used for
-    scc_configuration->driver_major_version */
-#define SCC_DRIVER_MAJOR_VERSION    2
-/*! Old Minor Version of the driver. */
-#define SCC_DRIVER_MINOR_VERSION_0    0
-/*! Minor Version of the driver.  Used for
-    scc_configuration->driver_minor_version */
-#define SCC_DRIVER_MINOR_VERSION_2    2
-
-
-/*!
- *  Interrupt line number of SCM interrupt.
- */
-#define INT_SCC_SCM         MXC_INT_SCC_SCM
-
-/*!
- *  Interrupt line number of the SMN interrupt.
- */
-#define INT_SCC_SMN         MXC_INT_SCC_SMN
-
-/**
- * @typedef scc_return_t
- */
-/** Common status return values from SCC driver functions. */
-	typedef enum scc_return_t {
-		SCC_RET_OK = 0,	 /**< Function succeeded  */
-		SCC_RET_FAIL,	 /**< Non-specific failure */
-		SCC_RET_VERIFICATION_FAILED,
-				 /**< Decrypt validation failed */
-		SCC_RET_TOO_MANY_FUNCTIONS,
-				 /**< At maximum registered functions */
-		SCC_RET_BUSY,	 /**< SCC is busy and cannot handle request */
-		/**< Encryption or decryption failed because@c count_out_bytes
-			says that @c data_out is too small to hold the value. */
-		SCC_RET_INSUFFICIENT_SPACE,
-	} scc_return_t;
-
-/**
- * @typedef scc_partition_status_t
- */
-/** Partition status information. */
-	typedef enum scc_partition_status_t {
-		SCC_PART_S_UNUSABLE,
-				  /**< Partition not implemented */
-		SCC_PART_S_UNAVAILABLE,
-				  /**< Partition owned by other host */
-		SCC_PART_S_AVAILABLE,
-				  /**< Partition available */
-		SCC_PART_S_ALLOCATED,
-				  /**< Partition owned by host but not engaged*/
-		SCC_PART_S_ENGAGED,
-				  /**< Partition owned by host and engaged */
-	} scc_partition_status_t;
-
-/**
- * Configuration information about SCC and the driver.
- *
- * This struct/typedef contains information from the SCC and the driver to
- * allow the user of the driver to determine the size of the SCC's memories and
- * the version of the SCC and the driver.
- */
-	typedef struct scc_config_t {
-		int driver_major_version;
-				/**< Major version of the SCC driver code  */
-		int driver_minor_version;
-				/**< Minor version of the SCC driver code  */
-		int scm_version; /**< Version from SCM Configuration register */
-		int smn_version; /**< Version from SMN Status register */
-		/**< Number of bytes per block of RAM; also
-			block size of the crypto algorithm. */
-		int block_size_bytes;
-		int partition_size_bytes;
-				/**< Number of bytes in each partition */
-		int partition_count;
-				/**< Number of partitions on this platform */
-	} scc_config_t;
-
-/**
- * @typedef scc_enc_dec_t
- */
-/**
- * Determine whether SCC will run its cryptographic
- * function as an encryption or decryption.
- */
-	typedef enum scc_enc_dec_t {
-		SCC_ENCRYPT,	/**< Encrypt (from Red to Black) */
-		SCC_DECRYPT	/**< Decrypt (from Black to Red) */
-	} scc_enc_dec_t;
-
-/**
- * @typedef scc_verify_t
- */
-/**
- * Tell the driver whether it is responsible for verifying the integrity of a
- * secret.  During an encryption, using other than #SCC_VERIFY_MODE_NONE will
- * cause a check value to be generated and appended to the plaintext before
- * encryption.  During decryption, the check value will be verified after
- * decryption, and then stripped from the message.
- */
-	typedef enum scc_verify_t {
-    /** No verification value added or checked.  Input plaintext data must be
-     *  be a multiple of the blocksize (#scc_get_configuration()).  */
-		SCC_VERIFY_MODE_NONE,
-    /** Driver will generate/validate a 2-byte CCITT CRC.  Input plaintext
-    		will be padded to a multiple of the blocksize, adding 3-10 bytes
-    		to the resulting output ciphertext.  Upon decryption, this padding
-    		will be stripped, and the CRC will be verified. */
-		SCC_VERIFY_MODE_CCITT_CRC
-	} scc_verify_t;
-
-/**
- * @typedef scc_cypher_mode_t
- */
-/**
- * Select the cypher mode to use for partition cover/uncover operations.
- */
-
-	typedef enum scc_cypher_mode_t {
-		SCC_CYPHER_MODE_ECB = 1,
-				   /**< ECB mode */
-		SCC_CYPHER_MODE_CBC = 2,
-				   /**< CBC mode */
-	} scc_cypher_mode_t;
-
-/**
- * Allocate a partition of secure memory
- *
- * @param       smid_value  Value to use for the SMID register.  Must be 0 for
- *                          kernel mode ownership.
- * @param[out]  part_no     (If successful) Assigned partition number.
- * @param[out]  part_base   Kernel virtual address of the partition.
- * @param[out]  part_phys   Physical address of the partition.
- *
- * @return      SCC_RET_OK if successful.
- */
-	extern scc_return_t
-	    scc_allocate_partition(uint32_t smid_value,
-				   int *part_no,
-				   void **part_base, uint32_t *part_phys);
-
-/* Note: This function has to be run in the same context (userspace or kernel
- * mode) as the process that will be using the partition.  Because the SCC2 API
- * is not accessible in user mode, this function is also provided as a macro in
- * in fsl_shw.h.  Kernel-mode users that include this file are able to use this
- * version of the function without having to include the whole SHW API.  If the
- * macro definition was defined before we got here, un-define it so this
- * version will be used instead.
- */
-
-#ifdef scc_engage_partition
-#undef scc_engage_partition
-#endif
-
-/**
- * Engage partition of secure memory
- *
- * @param part_base (kernel) Virtual
- * @param UMID NULL, or 16-byte UMID for partition security
- * @param permissions ORed values of the type SCM_PERM_* which will be used as
- *                    initial partition permissions.  SHW API users should use
- *                    the FSL_PERM_* definitions instead.
- *
- * @return SCC_RET_OK if successful.
- */
-	extern scc_return_t
-	    scc_engage_partition(void *part_base,
-				 const uint8_t *UMID, uint32_t permissions);
-
-/**
- * Release a partition of secure memory
- *
- * @param   part_base   Kernel virtual address of the partition to be released.
- *
- * @return  SCC_RET_OK if successful.
- */
-	extern scc_return_t scc_release_partition(void *part_base);
-
-/**
- * Diminish the permissions on a partition of secure memory
- *
- * @param part_base   Kernel virtual address of the partition.
- *
- * @param permissions ORed values of the type SCM_PERM_* which will be used as
- *                    initial partition permissions.  SHW API users should use
- *                    the FSL_PERM_* definitions instead.
- *
- * @return  SCC_RET_OK if successful.
- */
-	extern scc_return_t
-	    scc_diminish_permissions(void *part_base, uint32_t permissions);
-
-/**
- * Query the status of a partition of secure memory
- *
- * @param part_base   Kernel virtual address of the partition.
- *
- * @return  SCC_RET_OK if successful.
- */
-	extern scc_partition_status_t scc_partition_status(void *part_base);
-
-/**
- * Calculate the physical address from the kernel virtual address.
- */
-	extern uint32_t scc_virt_to_phys(void *address);
-/*scc_return_t
-scc_verify_slot_access(uint64_t owner_id, uint32_t slot, uint32_t access_len);*/
-
-
-/**
- * Encrypt a region of secure memory.
- *
- * @param   part_base    Kernel virtual address of the partition.
- * @param   offset_bytes Offset from the start of the partition to the plaintext
- *                       data.
- * @param   byte_count   Length of the region (octets).
- * @param   black_data   Physical location to store the encrypted data.
- * @param   IV           Value to use for the Initialization Vector.
- * @param   cypher_mode  Cyphering mode to use, specified by type
- *                       #scc_cypher_mode_t
- *
- * @return  SCC_RET_OK if successful.
- */
-	extern scc_return_t
-	    scc_encrypt_region(uint32_t part_base, uint32_t offset_bytes,
-			       uint32_t byte_count, uint8_t *black_data,
-			       uint32_t *IV, scc_cypher_mode_t cypher_mode);
-
-/**
- * Decrypt a region into secure memory
- *
- * @param   part_base    Kernel virtual address of the partition.
- * @param   offset_bytes Offset from the start of the partition to store the
- *                       plaintext data.
- * @param   byte_count   Length of the region (octets).
- * @param   black_data   Physical location of the encrypted data.
- * @param   IV           Value to use for the Initialization Vector.
- * @param   cypher_mode  Cyphering mode to use, specified by type
- *                       #scc_cypher_mode_t
- *
- * @return  SCC_RET_OK if successful.
- */
-	extern scc_return_t
-	    scc_decrypt_region(uint32_t part_base, uint32_t offset_bytes,
-			       uint32_t byte_count, uint8_t *black_data,
-			       uint32_t *IV, scc_cypher_mode_t cypher_mode);
-
-/**
- * Retrieve configuration information from the SCC.
- *
- * This function always succeeds.
- *
- * @return   A pointer to the configuration information.  This is a pointer to
- *           static memory and must not be freed.  The values never change, and
- *           the return value will never be null.
- */
-	extern scc_config_t *scc_get_configuration(void);
-
-/**
- * Zeroize Red and Black memories of the SCC.  This will start the Zeroizing
- * process.  The routine will return when the memories have zeroized or failed
- * to do so.  The driver will poll waiting for this to occur, so this
- * routine must not be called from interrupt level.  Some future version of
- * driver may elect instead to sleep.
- *
- * @return 0 or error if initialization fails.
- */
-	extern scc_return_t scc_zeroize_memories(void);
-
-/**
- * Signal a software alarm to the SCC.  This will take the SCC and other PISA
- * parts out of Secure mode and into Security Failure mode.  The SCC will stay
- * in failed mode until a reboot.
- *
- * @internal
- * If the SCC is not already in fail state, simply write the
- * #SMN_COMMAND_SET_SOFTWARE_ALARM bit in #SMN_COMMAND_REG.  Since there is no
- * reason to wait for the interrupt to bounce back, simply act as though
- * one did.
- */
-	extern void scc_set_sw_alarm(void);
-
-/**
- * This routine will register a function to be called should a Security Failure
- * be signalled by the SCC (Security Monitor).
- *
- * The callback function may be called from interrupt level, it may be called
- * from some process' task.  It should therefore not take a long time to
- * perform its operation, and it may not sleep.
- *
- * @param  callback_func  Function pointer to routine which will receive
- *                        notification of the security failure.
- * @return         0 if function was successfully registered, non-zero on
- *                 failure.  See #scc_return_t.
- *
- * @internal
- *  There is a fixed global static array which keeps track of the requests to
- *  monitor the failure.
- *
- *  Add @c callback_func to the first empty slot in #scc_callbacks[].  If there
- *  is no room, return #SCC_RET_TOO_MANY_FUNCTIONS.
- */
-	extern scc_return_t scc_monitor_security_failure(void
-							 callback_func(void));
-
-/**
- * This routine will deregister a function previously registered with
- * #scc_monitor_security_failure().
- *
- * @param callback_func Function pointer to routine previously registered with
- *                      #scc_stop_monitoring_security_failure().
- */
-	extern void scc_stop_monitoring_security_failure(void
-							 callback_func(void));
-
-/**
- * Read value from an SCC register.
- * The offset will be checked for validity (range) as well as whether it is
- * accessible (e.g. not busy, not in failed state) at the time of the call.
- *
- * @param[in]   register_offset  The (byte) offset within the SCC block
- *                               of the register to be queried.  See
- *                              @ref scmregs and @ref smnregs.
- * @param[out]  value            Pointer to where value from the register
- *                               should be placed.
- * @return      0 if OK, non-zero on error.  See #scc_return_t.
- *
- * @internal
- *  Verify that the register_offset is a) valid, b) refers to a readable
- *  register, and c) the SCC is in a state which would allow a read of this
- *  register.
- */
-	extern scc_return_t scc_read_register(int register_offset,
-					      uint32_t * value);
-
-/**
- * Write a new value into an SCC register.
- * The offset will be checked for validity (range) as well as whether it is
- * accessible (e.g. not busy, not in failed state) at the time of the call.
- *
- * @param[in]  register_offset  The (byte) offset within the SCC block
- *                              of the register to be modified.  See
- *                              @ref scmregs and @ref smnregs
- * @param[in]  value            The value to store into the register.
- * @return     0 if OK, non-zero on error.  See #scc_return_t.
- *
- * @internal
- *  Verify that the register_offset is a) valid, b) refers to a writeable
- *  register, and c) the SCC is in a state which would allow a write to this
- *  register.
- */
-	extern scc_return_t scc_write_register(int register_offset,
-					       uint32_t value);
-
-/**
- * @defgroup scmregs SCM Registers
- *
- * These values are offsets into the SCC for the Secure Memory
- * (SCM) registers.  They are used in the @c register_offset parameter of
- * #scc_read_register() and #scc_write_register().
- */
-/** @addtogroup scmregs */
-/** @{ */
-/** Offset of SCM Version ID Register */
-#define SCM_VERSION_REG		0x000
-/** Offset of SCM Interrupt Control Register */
-#define SCM_INT_CTL_REG		0x008
-/** Offset of SCM Status Register */
-#define SCM_STATUS_REG		0x00c
-/** Offset of SCM Error Status Register */
-#define SCM_ERR_STATUS_REG	0x010
-/** Offset of SCM Fault Address Register */
-#define SCM_FAULT_ADR_REG	0x014
-/** Offset of SCM Partition Owners Register */
-#define SCM_PART_OWNERS_REG	0x018
-/** Offset of SCM Partitions Engaged Register */
-#define SCM_PART_ENGAGED_REG	0x01c
-/** Offset of SCM Unique Number 0 Register */
-#define SCM_UNIQUE_ID0_REG	0x020
-/** Offset of SCM Unique Number 1 Register */
-#define SCM_UNIQUE_ID1_REG	0x024
-/** Offset of SCM Unique Number 2 Register */
-#define SCM_UNIQUE_ID2_REG	0x028
-/** Offset of SCM Unique Number 3 Register */
-#define SCM_UNIQUE_ID3_REG	0x02c
-/** Offset of SCM Zeroize Command Register */
-#define SCM_ZCMD_REG		0x050
-/** Offset of SCM Cipher Command Register */
-#define SCM_CCMD_REG		0x054
-/** Offset of SCM Cipher Black RAM Start Address Register */
-#define SCM_C_BLACK_ST_REG	0x058
-/** Offset of SCM Internal Debug Register */
-#define SCM_DBG_STATUS_REG	0x05c
-/** Offset of SCM Cipher IV 0 Register */
-#define SCM_AES_CBC_IV0_REG	0x060
-/** Offset of SCM Cipher IV 1 Register */
-#define SCM_AES_CBC_IV1_REG	0x064
-/** Offset of SCM Cipher IV 2 Register */
-#define SCM_AES_CBC_IV2_REG	0x068
-/** Offset of SCM Cipher IV 3 Register */
-#define SCM_AES_CBC_IV3_REG	0x06c
-/** Offset of SCM SMID Partition 0 Register */
-#define SCM_SMID0_REG		0x080
-/** Offset of SCM Partition 0 Access Permissions Register */
-#define SCM_ACC0_REG		0x084
-/** Offset of SCM SMID Partition 1 Register */
-#define SCM_SMID1_REG		0x088
-/** Offset of SCM Partition 1 Access Permissions Register */
-#define SCM_ACC1_REG		0x08c
-/** Offset of SCM SMID Partition 2 Register */
-#define SCM_SMID2_REG		0x090
-/** Offset of SCM Partition 2 Access Permissions Register */
-#define SCM_ACC2_REG		0x094
-/** Offset of SCM SMID Partition 3 Register */
-#define SCM_SMID3_REG		0x098
-/** Offset of SCM Partition 3 Access Permissions Register */
-#define SCM_ACC3_REG		0x09c
-/** Offset of SCM SMID Partition 4 Register */
-#define SCM_SMID4_REG		0x0a0
-/** Offset of SCM Partition 4 Access Permissions Register */
-#define SCM_ACC4_REG		0x0a4
-/** Offset of SCM SMID Partition 5 Register */
-#define SCM_SMID5_REG		0x0a8
-/** Offset of SCM Partition 5 Access Permissions Register */
-#define SCM_ACC5_REG		0x0ac
-/** Offset of SCM SMID Partition 6 Register */
-#define SCM_SMID6_REG		0x0b0
-/** Offset of SCM Partition 6 Access Permissions Register */
-#define SCM_ACC6_REG		0x0b4
-/** Offset of SCM SMID Partition 7 Register */
-#define SCM_SMID7_REG		0x0b8
-/** Offset of SCM Partition 7 Access Permissions Register */
-#define SCM_ACC7_REG		0x0bc
-/** Offset of SCM SMID Partition 8 Register */
-#define SCM_SMID8_REG		0x0c0
-/** Offset of SCM Partition 8 Access Permissions Register */
-#define SCM_ACC8_REG		0x0c4
-/** Offset of SCM SMID Partition 9 Register */
-#define SCM_SMID9_REG		0x0c8
-/** Offset of SCM Partition 9 Access Permissions Register */
-#define SCM_ACC9_REG		0x0cc
-/** Offset of SCM SMID Partition 10 Register */
-#define SCM_SMID10_REG		0x0d0
-/** Offset of SCM Partition 10 Access Permissions Register */
-#define SCM_ACC10_REG		0x0d4
-/** Offset of SCM SMID Partition 11 Register */
-#define SCM_SMID11_REG		0x0d8
-/** Offset of SCM Partition 11 Access Permissions Register */
-#define SCM_ACC11_REG		0x0dc
-/** Offset of SCM SMID Partition 12 Register */
-#define SCM_SMID12_REG		0x0e0
-/** Offset of SCM Partition 12 Access Permissions Register */
-#define SCM_ACC12_REG		0x0e4
-/** Offset of SCM SMID Partition 13 Register */
-#define SCM_SMID13_REG		0x0e8
-/** Offset of SCM Partition 13 Access Permissions Register */
-#define SCM_ACC13_REG		0x0ec
-/** Offset of SCM SMID Partition 14 Register */
-#define SCM_SMID14_REG		0x0f0
-/** Offset of SCM Partition 14 Access Permissions Register */
-#define SCM_ACC14_REG		0x0f4
-/** Offset of SCM SMID Partition 15 Register */
-#define SCM_SMID15_REG		0x0f8
-/** Offset of SCM Partition 15 Access Permissions Register */
-#define SCM_ACC15_REG		0x0fc
-/** @} */
-
-/** Number of bytes of register space for the SCM. */
-#define SCM_REG_BANK_SIZE	0x100
-
-/** Number of bytes of register space for the SCM. */
-#define SCM_REG_BANK_SIZE	0x100
-
-/** Offset of the SMN registers */
-#define SMN_ADDR_OFFSET		0x100
-
-/**
- * @defgroup smnregs SMN Registers
- *
- * These values are offsets into the SCC for the Security Monitor
- * (SMN) registers.  They are used in the @c register_offset parameter of the
- * #scc_read_register() and #scc_write_register().
- */
-/** @addtogroup smnregs */
-/** @{ */
-/** Offset of SMN Status Register */
-#define SMN_STATUS_REG		(SMN_ADDR_OFFSET+0x00000000)
-/** Offset of SMH Command Register */
-#define SMN_COMMAND_REG		(SMN_ADDR_OFFSET+0x00000004)
-/** Offset of SMH Sequence Start Register */
-#define SMN_SEQ_START_REG	(SMN_ADDR_OFFSET+0x00000008)
-/** Offset of SMH Sequence End Register */
-#define SMN_SEQ_END_REG		(SMN_ADDR_OFFSET+0x0000000c)
-/** Offset of SMH Sequence Check Register */
-#define SMN_SEQ_CHECK_REG	(SMN_ADDR_OFFSET+0x00000010)
-/** Offset of SMH BitBank Count Register */
-#define SMN_BB_CNT_REG		(SMN_ADDR_OFFSET+0x00000014)
-/** Offset of SMH BitBank Increment Register */
-#define SMN_BB_INC_REG		(SMN_ADDR_OFFSET+0x00000018)
-/** Offset of SMH BitBank Decrement Register */
-#define SMN_BB_DEC_REG		(SMN_ADDR_OFFSET+0x0000001c)
-/** Offset of SMH Compare Register */
-#define SMN_COMPARE_REG		(SMN_ADDR_OFFSET+0x00000020)
-/** Offset of SMH Plaintext Check Register */
-#define SMN_PT_CHK_REG		(SMN_ADDR_OFFSET+0x00000024)
-/** Offset of SMH Ciphertext Check Register */
-#define SMN_CT_CHK_REG		(SMN_ADDR_OFFSET+0x00000028)
-/** Offset of SMH Timer Initial Value Register */
-#define SMN_TIMER_IV_REG	(SMN_ADDR_OFFSET+0x0000002c)
-/** Offset of SMH Timer Control Register */
-#define SMN_TIMER_CTL_REG	(SMN_ADDR_OFFSET+0x00000030)
-/** Offset of SMH Security Violation Register */
-#define SMN_SEC_VIO_REG		(SMN_ADDR_OFFSET+0x00000034)
-/** Offset of SMH Timer Register */
-#define SMN_TIMER_REG		(SMN_ADDR_OFFSET+0x00000038)
-/** Offset of SMH High-Assurance Control Register */
-#define SMN_HAC_REG		(SMN_ADDR_OFFSET+0x0000003c)
-/** Number of bytes allocated to the SMN registers */
-#define SMN_REG_BANK_SIZE	0x40
-/** @} */
-
-/** Number of bytes of total register space for the SCC. */
-#define SCC_ADDRESS_RANGE	(SMN_ADDR_OFFSET + SMN_REG_BANK_SIZE)
-
-/**
- * @defgroup smnstatusregdefs SMN Status Register definitions (SMN_STATUS)
- */
-/** @addtogroup smnstatusregdefs */
-/** @{ */
-/** SMN version id. */
-#define SMN_STATUS_VERSION_ID_MASK        0xfc000000
-/**  number of bits to shift #SMN_STATUS_VERSION_ID_MASK to get it to LSB */
-#define SMN_STATUS_VERSION_ID_SHIFT       28
-/** Illegal bus master access attempted. */
-#define SMN_STATUS_ILLEGAL_MASTER         0x01000000
-/** Scan mode entered/exited since last reset. */
-#define SMN_STATUS_SCAN_EXIT              0x00800000
-/** Some security peripheral is initializing */
-#define SMN_STATUS_PERIP_INIT             0x00010000
-/** Internal error detected in SMN. */
-#define SMN_STATUS_SMN_ERROR              0x00008000
-/** SMN has an outstanding interrupt. */
-#define SMN_STATUS_SMN_STATUS_IRQ         0x00004000
-/** Software Alarm was triggered. */
-#define SMN_STATUS_SOFTWARE_ALARM         0x00002000
-/** Timer has expired. */
-#define SMN_STATUS_TIMER_ERROR            0x00001000
-/** Plaintext/Ciphertext compare failed. */
-#define SMN_STATUS_PC_ERROR               0x00000800
-/** Bit Bank detected overflow or underflow */
-#define SMN_STATUS_BITBANK_ERROR          0x00000400
-/** Algorithm Sequence Check failed. */
-#define SMN_STATUS_ASC_ERROR              0x00000200
-/** Security Policy Block detected error. */
-#define SMN_STATUS_SECURITY_POLICY_ERROR  0x00000100
-/** Security Violation Active error. */
-#define SMN_STATUS_SEC_VIO_ACTIVE_ERROR   0x00000080
-/** Processor booted from internal ROM. */
-#define SMN_STATUS_INTERNAL_BOOT          0x00000020
-/** SMN's internal state. */
-#define SMN_STATUS_STATE_MASK             0x0000001F
-/** Number of bits to shift #SMN_STATUS_STATE_MASK to get it to LSB. */
-#define SMN_STATUS_STATE_SHIFT            0
-/** @} */
-
-/**
- * @defgroup sccscmstates SMN Model Secure State Controller States (SMN_STATE_MASK)
- */
-/** @addtogroup sccscmstates */
-/** @{ */
-/** This is the first state of the SMN after power-on reset  */
-#define SMN_STATE_START         0x0
-/** The SMN is zeroizing its RAM during reset */
-#define SMN_STATE_ZEROIZE_RAM   0x5
-/** SMN has passed internal checks, and is waiting for Software check-in */
-#define SMN_STATE_HEALTH_CHECK  0x6
-/** Fatal Security Violation.  SMN is locked, SCM is inoperative. */
-#define SMN_STATE_FAIL          0x9
-/** SCC is in secure state.  SCM is using secret key. */
-#define SMN_STATE_SECURE        0xA
-/** Due to non-fatal error, device is not secure.  SCM is using default key. */
-#define SMN_STATE_NON_SECURE    0xC
-/** @} */
-
-/** @{ */
-/** SCM Status bit: Key Status is Default Key in Use */
-#define SCM_STATUS_KST_DEFAULT_KEY	0x80000000
-/** SCM Status bit: Key Status is (reserved) */
-#define SCM_STATUS_KST_RESERVED1	0x40000000
-/** SCM Status bit: Key status is Wrong Key */
-#define SCM_STATUS_KST_WRONG_KEY	0x20000000
-/** SCM Status bit: Bad Key detected */
-#define SCM_STATUS_KST_BAD_KEY	0x10000000
-/** SCM Status bit: Error has occurred */
-#define SCM_STATUS_ERR		0x00008000
-/** SCM Status bit: Monitor State is Failed */
-#define SCM_STATUS_MSS_FAIL	0x00004000
-/** SCM Status bit: Monitor State is Secure */
-#define SCM_STATUS_MSS_SEC	0x00002000
-/** SCM Status bit: Secure Storage is Failed */
-#define SCM_STATUS_RSS_FAIL	0x00000400
-/** SCM Status bit: Secure Storage is Secure */
-#define SCM_STATUS_RSS_SEC	0x00000200
-/** SCM Status bit: Secure Storage is Initializing */
-#define SCM_STATUS_RSS_INIT	0x00000100
-/** SCM Status bit: Unique Number Valid */
-#define SCM_STATUS_UNV		0x00000080
-/** SCM Status bit: Big Endian mode */
-#define SCM_STATUS_BIG		0x00000040
-/** SCM Status bit: Using Secret Key */
-#define SCM_STATUS_USK		0x00000020
-/** SCM Status bit: Ram is being blocked */
-#define SCM_STATUS_BAR		0x00000010
-/** Bit mask of SRS */
-#define SCM_STATUS_SRS_MASK	0x0000000F
-/** Number of bits to shift SRS to/from MSb */
-#define SCM_STATUS_SRS_SHIFT	0
-/** @} */
-
-#define SCM_STATUS_SRS_RESET	0x0	/**< Reset, Zeroise All */
-#define SCM_STATUS_SRS_READY	0x1	/**< All Ready */
-#define SCM_STATUS_SRS_ZBUSY	0x2	/**< Zeroize Busy (Partition Only) */
-#define SCM_STATUS_SRS_CBUSY	0x3	/**< Cipher Busy */
-#define SCM_STATUS_SRS_ABUSY	0x4	/**< All Busy */
-#define SCM_STATUS_SRS_ZDONE	0x5	/**< Zeroize Done, Cipher Ready */
-#define SCM_STATUS_SRS_CDONE	0x6	/**< Cipher Done, Zeroize Ready */
-#define SCM_STATUS_SRS_ZDONE2	0x7	/**< Zeroize Done, Cipher Busy */
-#define SCM_STATUS_SRS_CDONE2	0x8	/**< Cipher Done, Zeroize Busy */
-#define SCM_STATUS_SRS_ADONE	0xD	/**< All Done */
-
-/* Format of the SCM VERSION ID REGISTER */
-#define SCM_VER_BPP_MASK    0xFF000000	/**< Bytes Per Partition Mask */
-#define SCM_VER_BPP_SHIFT   24		/**< Bytes Per Partition Shift */
-#define SCM_VER_BPCB_MASK   0x001F0000	/**< Bytes Per Cipher Block Mask */
-#define SCM_VER_BPCB_SHIFT  16		/**< Bytes Per Cipher Block Shift */
-#define SCM_VER_NP_MASK     0x0000F000	/**< Number of Partitions Mask */
-#define SCM_VER_NP_SHIFT    12		/**< Number of Partitions Shift */
-#define SCM_VER_MAJ_MASK    0x00000F00	/**< Major Version Mask */
-#define SCM_VER_MAJ_SHIFT   8		/**< Major Version Shift */
-#define SCM_VER_MIN_MASK    0x000000FF	/**< Minor Version Mask */
-#define SCM_VER_MIN_SHIFT   0		/**< Minor Version Shift */
-
-/**< SCC Hardware version supported by this driver */
-#define SCM_MAJOR_VERSION_2 2
-
-/* Format of the SCM ERROR STATUS REGISTER */
-#define SCM_ERRSTAT_MID_MASK    0x00F00000  /**< Master ID Mask */
-#define SCM_ERRSTAT_MID_SHIFT   20	    /**< Master ID Shift */
-#define SCM_ERRSTAT_ILM         0x00080000  /**< Illegal Master */
-#define SCM_ERRSTAT_SUP         0x00008000  /**< Supervisor Access */
-#define SCM_ERRSTAT_ERC_MASK    0x00000F00  /**< Error Code Mask */
-#define SCM_ERRSTAT_ERC_SHIFT   8	    /**< Error Code Shift */
-#define SCM_ERRSTAT_SMS_MASK    0x000000F0  /**< Secure Monitor State Mask */
-#define SCM_ERRSTAT_SMS_SHIFT   4	    /**< Secure Monitor State Shift */
-#define SCM_ERRSTAT_SRS_MASK    0x0000000F  /**< Secure Ram State Mask */
-#define SCM_ERRSTAT_SRS_SHIFT   0	    /**< Secure Ram State Shift */
-
-/* SCM ERROR STATUS REGISTER ERROR CODES */
-#define SCM_ERCD_UNK_ADDR       0x1 /**< Unknown Address */
-#define SCM_ERCD_UNK_CMD        0x2 /**< Unknown Command */
-#define SCM_ERCD_READ_PERM      0x3 /**< Read Permission Error */
-#define SCM_ERCD_WRITE_PERM     0x4 /**< Write Permission Error */
-#define SCM_ERCD_DMA_ERROR      0x5 /**< DMA Error */
-#define SCM_ERCD_BLK_OVFL       0x6 /**< Encryption Block Length Overflow */
-#define SCM_ERCD_NO_KEY         0x7 /**< Key Not Engaged */
-#define SCM_ERCD_ZRZ_OVFL       0x8 /**< Zeroize Command Queue Overflow */
-#define SCM_ERCD_CPHR_OVFL      0x9 /**< Cipher Command Queue Overflow */
-#define SCM_ERCD_PROC_INTR      0xA /**< Process Interrupted */
-#define SCM_ERCD_WRNG_KEY       0xB /**< Wrong Key */
-#define SCM_ERCD_DEVICE_BUSY    0xC /**< Device Busy */
-#define SCM_ERCD_UNALGN_ADDR    0xD /**< DMA Unaligned Address */
-
-/* Format of the CIPHER COMMAND REGISTER */
-#define SCM_CCMD_LENGTH_MASK	0xFFF00000 /**< Cipher Length Mask */
-#define SCM_CCMD_LENGTH_SHIFT	20	   /**< Cipher Length Shift */
-#define SCM_CCMD_OFFSET_MASK	0x000FFF00 /**< Block Offset Mask */
-#define SCM_CCMD_OFFSET_SHIFT	8	   /**< Block Offset Shift */
-#define SCM_CCMD_PART_MASK	0x000000F0     /**< Partition Number Mask */
-#define SCM_CCMD_PART_SHIFT	4	       /**< Partition Number Shift */
-#define SCM_CCMD_CCMD_MASK	0x0000000F     /**< Cipher Command Mask */
-#define SCM_CCMD_CCMD_SHIFT	0	       /**< Cipher Command Shift */
-
-/* Values for SCM_CCMD_CCMD field */
-#define SCM_CCMD_AES_DEC_ECB 1 /**< Decrypt without Chaining (ECB) */
-#define SCM_CCMD_AES_ENC_ECB 3 /**< Encrypt without Chaining (ECB) */
-#define SCM_CCMD_AES_DEC_CBC 5 /**< Decrypt with Chaining (CBC) */
-#define SCM_CCMD_AES_ENC_CBC 7 /**< Encrypt with Chaining (CBC) */
-
-#define SCM_CCMD_AES     1     /**< Use AES Mode */
-#define SCM_CCMD_DEC     0     /**< Decrypt */
-#define SCM_CCMD_ENC     2     /**< Encrypt */
-#define SCM_CCMD_ECB     0     /**< Perform operation without chaining (ECB) */
-#define SCM_CCMD_CBC     4     /**< Perform operation with chaining (CBC) */
-
-/* Format of the ZEROIZE COMMAND REGISTER */
-#define SCM_ZCMD_PART_MASK	0x000000F0  /**< Target Partition Mask */
-#define SCM_ZCMD_PART_SHIFT	4	    /**< Target Partition Shift */
-#define SCM_ZCMD_CCMD_MASK	0x0000000F  /**< Zeroize Command Mask */
-#define SCM_ZCMD_CCMD_SHIFT	0	    /**< Zeroize Command Shift */
-
-/* MASTER ACCESS PERMISSIONS REGISTER */
-/* Note that API users should use the FSL_PERM_ defines instead of these */
-/** SCM Access Permission: Do not zeroize/deallocate partition
-	on SMN Fail state */
-#define SCM_PERM_NO_ZEROIZE	0x10000000
-/** SCM Access Permission: Ignore Supervisor/User mode
-	in permission determination */
-#define SCM_PERM_HD_SUP_DISABLE	0x00000800
-/** SCM Access Permission: Allow Read Access to  Host Domain */
-#define SCM_PERM_HD_READ	0x00000400
-/** SCM Access Permission: Allow Write Access to  Host Domain */
-#define SCM_PERM_HD_WRITE	0x00000200
-/** SCM Access Permission: Allow Execute Access to  Host Domain */
-#define SCM_PERM_HD_EXECUTE	0x00000100
-/** SCM Access Permission: Allow Read Access to Trusted Host Domain */
-#define SCM_PERM_TH_READ	0x00000040
-/** SCM Access Permission: Allow Write Access to Trusted Host Domain */
-#define SCM_PERM_TH_WRITE	0x00000020
-/** SCM Access Permission: Allow Read Access to Other/World Domain */
-#define SCM_PERM_OT_READ	0x00000004
-/** SCM Access Permission: Allow Write Access to Other/World Domain */
-#define SCM_PERM_OT_WRITE	0x00000002
-/** SCM Access Permission: Allow Execute Access to Other/World Domain */
-#define SCM_PERM_OT_EXECUTE	0x00000001
-/**< Valid bits that can be set in the Permissions register */
-#define SCM_PERM_MASK 0xC0000F67
-
-/* Zeroize Command register definitions */
-#define ZCMD_DEALLOC_PART 3	 /**< Deallocate Partition */
-#define Z_INT_EN	0x00000002   /**< Zero Interrupt Enable */
-
-/**
- * @defgroup scmpartitionownersregdefs SCM Partition Owners Register
- */
-/** @addtogroup scmpartitionownersregdefs */
-/** @{ */
-/** Number of bits to shift partition number to get to its field. */
-#define SCM_POWN_SHIFT   2
-/** Mask for a field once the register has been shifted. */
-#define SCM_POWN_MASK    3
-/** Partition is free */
-#define SCM_POWN_PART_FREE       0
-/** Partition is unable to be allocated */
-#define SCM_POWN_PART_UNUSABLE   1
-/** Partition is owned by another master */
-#define SCM_POWN_PART_OTHER      2
-/** Partition is owned by this master */
-#define SCM_POWN_PART_OWNED      3
-/** @} */
-
-/**
- * @defgroup smnpartitionsengagedregdefs SCM Partitions Engaged Register
- */
-/** @addtogroup smnpartitionsengagedregdefs */
-/** @{ */
-/** Number of bits to shift partition number to get to its field. */
-#define SCM_PENG_SHIFT   1
-/** Engaged value for a field once the register has been shifted. */
-#define SCM_PENG_ENGAGED    1
-/** @} */
-
-/** Number of bytes between each subsequent SMID register */
-#define SCM_SMID_WIDTH      8
-
-/**
- * @defgroup smncommandregdefs SMN Command Register Definitions (SMN_COMMAND_REG)
- */
-/** @addtogroup smncommandregdefs */
-/** @{ */
-
-/** These bits are unimplemented or reserved */
-#define SMN_COMMAND_ZEROS_MASK   0xfffffff0
-#define SMN_COMMAND_CLEAR_INTERRUPT     0x8 /**< Clear SMN Interrupt */
-#define SMN_COMMAND_CLEAR_BIT_BANK      0x4 /**< Clear SMN Bit Bank */
-#define SMN_COMMAND_ENABLE_INTERRUPT    0x2 /**< Enable SMN Interrupts */
-#define SMN_COMMAND_SET_SOFTWARE_ALARM  0x1 /**< Set Software Alarm */
-/** @} */
-
-/**
- * @defgroup smntimercontroldefs SMN Timer Control Register definitions (SMN_TIMER_CONTROL)
- */
-/** @addtogroup smntimercontroldefs */
-/** @{ */
-/** These bits are reserved or zero */
-#define SMN_TIMER_CTRL_ZEROS_MASK 0xfffffffc
-/** Load the timer from #SMN_TIMER_IV_REG */
-#define SMN_TIMER_LOAD_TIMER             0x2
-/** Setting to zero stops the Timer */
-#define SMN_TIMER_STOP_MASK              0x1
-/** Setting this value starts the timer */
-#define SMN_TIMER_START_TIMER            0x1
-/** @} */
-
-/**
- * @defgroup scmchainmodedefs SCM_CHAINING_MODE_MASK - Bit definitions
- */
-/** @addtogroup scmchainmodedefs */
-/** @{ */
-#define SCM_CBC_MODE            0x2 /**< Cipher block chaining */
-#define SCM_ECB_MODE            0x0 /**< Electronic codebook. */
-/** @} */
-
-/* Bit definitions in the SCM_CIPHER_MODE_MASK */
-/**
- * @defgroup scmciphermodedefs SCM_CIPHER_MODE_MASK - Bit definitions
- */
-/** @addtogroup scmciphermodedefs */
-/** @{ */
-#define SCM_DECRYPT_MODE        0x1 /**< decrypt from black to red memory */
-#define SCM_ENCRYPT_MODE        0x0 /**< encrypt from red to black memory */
-/** @} */
-
-/**
- * @defgroup smndbgdetdefs SMN Debug Detector Status Register (SCM_DEBUG_DETECT_STAT)
- */
-/** @addtogroup smndbgdetdefs */
-/** @{ */
-#define SMN_DBG_ZEROS_MASK  0xfffff000 /**< These bits are zero or reserved */
-#define SMN_DBG_D12             0x0800 /**< Error detected on Debug Port D12 */
-#define SMN_DBG_D11             0x0400 /**< Error detected on Debug Port D11 */
-#define SMN_DBG_D10             0x0200 /**< Error detected on Debug Port D10 */
-#define SMN_DBG_D9              0x0100 /**< Error detected on Debug Port D9 */
-#define SMN_DBG_D8              0x0080 /**< Error detected on Debug Port D8 */
-#define SMN_DBG_D7              0x0040 /**< Error detected on Debug Port D7 */
-#define SMN_DBG_D6              0x0020 /**< Error detected on Debug Port D6 */
-#define SMN_DBG_D5              0x0010 /**< Error detected on Debug Port D5 */
-#define SMN_DBG_D4              0x0008 /**< Error detected on Debug Port D4 */
-#define SMN_DBG_D3              0x0004 /**< Error detected on Debug Port D3 */
-#define SMN_DBG_D2              0x0002 /**< Error detected on Debug Port D2 */
-#define SMN_DBG_D1              0x0001 /**< Error detected on Debug Port D1 */
-/** @} */
-
-/** Mask for the usable bits of the Sequence Start Register
-    (#SMN_SEQ_START_REG) */
-#define SMN_SEQUENCE_START_MASK    0x0000ffff
-
-/** Mask for the usable bits of the Sequence End Register
-    (#SMN_SEQ_END_REG) */
-#define SMN_SEQUENCE_END_MASK      0x0000ffff
-
-/** Mask for the usable bits of the Sequence Check Register
-    (#SMN_SEQ_CHECK_REG) */
-#define SMN_SEQUENCE_CHECK_MASK    0x0000ffff
-
-/** Mask for the usable bits of the Bit Counter Register
-    (#SMN_BB_CNT_REG) */
-#define SMN_BIT_COUNT_MASK         0x000007ff
-
-/** Mask for the usable bits of the Bit Bank Increment Size Register
-    (#SMN_BB_INC_REG) */
-#define SMN_BITBANK_INC_SIZE_MASK  0x000007ff
-
-/** Mask for the usable bits of the Bit Bank Decrement Register
-    (#SMN_BB_DEC_REG) */
-#define SMN_BITBANK_DECREMENT_MASK 0x000007ff
-
-/** Mask for the usable bits of the Compare Size Register
-    (#SMN_COMPARE_REG) */
-#define SMN_COMPARE_SIZE_MASK      0x0000003f
-
-/*! @} */
-
-#endif				/* SCC_DRIVER_H */
diff --git a/include/asm-arm/arch-mxc/mxc_scc_driver.h b/include/asm-arm/arch-mxc/mxc_scc_driver.h
deleted file mode 100644
index 5f1e1bb..0000000
--- a/include/asm-arm/arch-mxc/mxc_scc_driver.h
+++ /dev/null
@@ -1,1031 +0,0 @@
-
-/*
- * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-
-#ifndef __ASM_ARCH_MXC_SCC_DRIVER_H__
-#define __ASM_ARCH_MXC_SCC_DRIVER_H__
-
-/* Start marker for C++ compilers */
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*
- * NAMING CONVENTIONS
- * ==================
- * (A note to maintainers and other interested parties)
- *
- * Use scc_ or SCC_ prefix for 'high-level' interface routines and the types
- * passed to those routines.  Try to avoid #defines in these interfaces.
- *
- * Use SMN_ or SCM_ prefix for the #defines used with scc_read_register() and
- * scc_write_register, or values passed/retrieved from those routines.
- */
-
-/*!
- * @defgroup MXCSCC SCC Driver
- *
- * @ingroup MXCSECDRVRS
- */
-
-/*!
- * @file arch-mxc/mxc_scc_driver.h
- *
- * @brief (Header file to use the SCC driver.)
- *
- * The SCC driver will only be available to other kernel modules.  That is,
- * there will be no node file in /dev, no way for a user-mode program to access
- * the driver, no way for a user program to access the device directly.
- *
- * With the exception of #scc_monitor_security_failure(), all routines are
- * 'synchronous', i.e. they will not return to their caller until the requested
- * action is complete, or fails to complete.  Some of these functions could
- * take quite a while to perform, depending upon the request.
- *
- * Routines are provided to:
- * @li encrypt or decrypt secrets - #scc_crypt()
- * @li trigger a security-violation alarm - #scc_set_sw_alarm()
- * @li get configuration and version information - #scc_get_configuration()
- * @li zeroize memory - #scc_zeroize_memories()
- * @li Work on wrapped and stored secret values: #scc_alloc_slot(),
- *     #scc_dealloc_slot(), scc_load_slot(), #scc_decrypt_slot(),
- *     #scc_encrypt_slot(), #scc_get_slot_info()
-
- * @li monitor the Security Failure alarm - #scc_monitor_security_failure()
- * @li stop monitoring Security Failure alarm -
- *     #scc_stop_monitoring_security_failure()
- * @li write registers of the SCC - #scc_write_register()
- * @li read registers of the SCC - #scc_read_register()
- *
- * The driver does not allow "storage" of data in either the Red or Black
- * memories.  Any decrypted secret is returned to the user, and if the user
- * wants to use it at a later point, the encrypted form must again be passed
- * to the driver, and it must be decrypted again.
- *
- * The SCC encrypts and decrypts using Triple DES with an internally stored
- * key.  When the SCC is in Secure mode, it uses its secret, unique-per-chip
- * key.  When it is in Non-Secure mode, it uses a default key.  This ensures
- * that secrets stay secret if the SCC is not in Secure mode.
- *
- * Not all functions that could be provided in a 'high level' manner have been
- * implemented.  Among the missing are interfaces to the ASC/AIC components and
- * the timer functions.  These and other features must be accessed through
- * #scc_read_register() and #scc_write_register(), using the @c \#define values
- * provided.
- *
- * Here is a glossary of acronyms used in the SCC driver documentation:
- * - CBC - Cipher Block Chaining.  A method of performing a block cipher.
- *    Each block is encrypted using some part of the result of the previous
- *    block's encryption.  It needs an 'initialization vector' to seed the
- *    operation.
- * - ECB - Electronic Code Book.  A method of performing a block cipher.
- *    With a given key, a given block will always encrypt to the same value.
- * - DES - Data Encryption Standard.  (8-byte) Block cipher algorithm which
- *    uses 56-bit keys.  In SCC, this key is constant and unique to the device.
- *    SCC uses the "triple DES" form of this algorithm.
- * - AIC - Algorithm Integrity Checker.
- * - ASC - Algorithm Sequence Checker.
- * - SMN - Security Monitor.  The part of the SCC responsible for monitoring
- *    for security problems and notifying the CPU and other PISA components.
- * - SCM - Secure Memory.  The part of the SCC which handles the cryptography.
- * - SCC - Security Controller.  Central security mechanism for PISA.
- * - PISA - Platform-Independent Security Architecture.
- */
-
-/* Temporarily define compile-time flags to make Doxygen happy. */
-#ifdef DOXYGEN_HACK
-/*! @defgroup scccompileflags SCC Driver compile-time flags
- *
- * These preprocessor flags should be set, if desired, in a makefile so
- * that they show up on the compiler command line.
- */
-/*! @addtogroup scccompileflags */
-
-/*! @{ */
-/*!
- * Compile-time flag to change @ref smnregs and @ref scmregs
- * offset values for the SCC's implementation on the MX.21 board.
- *
- * This must also be set properly for any code which calls the
- * scc_read_register() or scc_write_register() functions or references the
- * register offsets.
- */
-#define TAHITI
-/*! @} */
-#undef TAHITI
-
-#endif				/* DOXYGEN_HACK */
-
-/*! Major Version of the driver.  Used for
-    scc_configuration->driver_major_version */
-#define SCC_DRIVER_MAJOR_VERSION_1 1
-/*! Old Minor Version of the driver. */
-#define SCC_DRIVER_MINOR_VERSION_0 0
-/*! Old Minor Version of the driver. */
-#define SCC_DRIVER_MINOR_VERSION_4 4
-/*! Old Minor Version of the driver. */
-#define SCC_DRIVER_MINOR_VERSION_5 5
-/*! Old Minor Version of the driver. */
-#define SCC_DRIVER_MINOR_VERSION_6 6
-/*! Minor Version of the driver.  Used for
-    scc_configuration->driver_minor_version */
-#define SCC_DRIVER_MINOR_VERSION_8 8
-
-
-/*!
- * @typedef scc_return_t 
- */
-/*! Common status return values from SCC driver functions. */
-	typedef enum scc_return_t {
-		SCC_RET_OK = 0,	/*!< Function succeeded  */
-		SCC_RET_FAIL,	/*!< Non-specific failure */
-		SCC_RET_VERIFICATION_FAILED,	/*!< Decrypt validation failed */
-		SCC_RET_TOO_MANY_FUNCTIONS,	/*!< At maximum registered functions */
-		SCC_RET_BUSY,	/*!< SCC is busy and cannot handle request */
-		SCC_RET_INSUFFICIENT_SPACE,	/*!< Encryption or decryption failed because
-							   @c count_out_bytes says that @c data_out is
-							   too small to hold the value. */
-	} scc_return_t;
-
-/*!
- * Configuration information about SCC and the driver.
- *
- * This struct/typedef contains information from the SCC and the driver to
- * allow the user of the driver to determine the size of the SCC's memories and
- * the version of the SCC and the driver.
- */
-	typedef struct scc_config_t {
-		int driver_major_version;	/*!< Major version of the SCC driver code  */
-		int driver_minor_version;	/*!< Minor version of the SCC driver code  */
-		int scm_version;	/*!< Version from SCM Configuration register */
-		int smn_version;	/*!< Version from SMN Status register */
-		int block_size_bytes;	/*!< Number of bytes per block of RAM; also
-					   block size of the crypto algorithm. */
-		int black_ram_size_blocks;	/*!< Number of blocks of Black RAM */
-		int red_ram_size_blocks;	/*!< Number of blocks of Red RAM */
-	} scc_config_t;
-
-/*!
- * @typedef scc_enc_dec_t 
- */
-/*!
- * Determine whether SCC will run its cryptographic
- * function as an encryption or decryption.  Used as an argument to
- * #scc_crypt().
- */
-	typedef enum scc_enc_dec_t {
-		SCC_ENCRYPT,	/*!< Encrypt (from Red to Black) */
-		SCC_DECRYPT	/*!< Decrypt (from Black to Red) */
-	} scc_enc_dec_t;
-
-/*
- * @typedef scc_crypto_mode_t 
- */
-/*!
- * Determine whether SCC will run its cryptographic function in ECB (electronic
- * codebook) or CBC (cipher-block chaining) mode.  Used as an argument to
- * #scc_crypt().
- */
-	typedef enum scc_crypto_mode_t {
-		SCC_ECB_MODE,	/*!< Electronic Codebook Mode */
-		SCC_CBC_MODE	/*!< Cipher Block Chaining Mode  */
-	} scc_crypto_mode_t;
-
-/*!
- * @typedef scc_verify_t 
- */
-/*!
- * Tell the driver whether it is responsible for verifying the integrity of a
- * secret.  During an encryption, using other than #SCC_VERIFY_MODE_NONE will
- * cause a check value to be generated and appended to the plaintext before
- * encryption.  During decryption, the check value will be verified after
- * decryption, and then stripped from the message.
- */
-	typedef enum scc_verify_t {
-		/*! No verification value added or checked.  Input plaintext data must be
-		 *  be a multiple of the blocksize (#scc_get_configuration()).  */
-		SCC_VERIFY_MODE_NONE,
-		/*! Driver will generate/validate a 2-byte CCITT CRC.  Input plaintext will
-		   be padded to a multiple of the blocksize, adding 3-10 bytes to the
-		   resulting output ciphertext.  Upon decryption, this padding will be
-		   stripped, and the CRC will be verified. */
-		SCC_VERIFY_MODE_CCITT_CRC
-	} scc_verify_t;
-
-/*!
- * Determine if the given credentials match that of the key slot.
- *
- * @param[in]  owner_id     A value which will control access to the slot.
- * @param[in]  slot         Key Slot to query
- * @param[in]  access_len   Length of the key
- *
- * @return     0 on success, non-zero on failure.  See #scc_return_t.
- */
-	 scc_return_t
-	    scc_verify_slot_access(uint64_t owner_id, uint32_t slot,
-				   uint32_t access_len);
-
-/*!
- * Retrieve configuration information from the SCC.
- *
- * This function always succeeds.
- *
- * @return   A pointer to the configuration information.  This is a pointer to
- *           static memory and must not be freed.  The values never change, and
- *           the return value will never be null.
- */
-	extern scc_config_t *scc_get_configuration(void);
-
-/*!
- * Zeroize Red and Black memories of the SCC.  This will start the Zeroizing
- * process.  The routine will return when the memories have zeroized or failed
- * to do so.  The driver will poll waiting for this to occur, so this
- * routine must not be called from interrupt level.  Some future version of
- * driver may elect instead to sleep.
- *
- * @return 0 or error if initialization fails.
- */
-	extern scc_return_t scc_zeroize_memories(void);
-
-/*!
- * Perform a Triple DES encryption or decryption operation.
- *
- * This routine will cause the SCM to perform an encryption or decryption with
- * its internal key.  If the SCC's #SMN_STATUS register shows that the SCC is
- * in #SMN_STATE_SECURE, then the Secret Key will be used.  If it is
- * #SMN_STATE_NON_SECURE (or health check), then the Default Key will be used.
- *
- * This function will perform in a variety of ways, depending upon the values
- * of @c direction, @c crypto_mode, and @c check_mode.  If
- * #SCC_VERIFY_MODE_CCITT_CRC mode is requested, upon successful completion,
- * the @c count_in_bytes will be different from the returned value of @c
- * count_out_bytes.  This is because the two-byte CRC and some amount of
- * padding (at least one byte) will either be added or stripped.
- *
- * This function will not return until the SCC has performed the operation (or
- * reported failure to do so).  It must therefore not be called from interrupt
- * level.  In the current version, it will poll the SCC for completion.  In
- * future versions, it may sleep.
- *
- * @param[in]    count_in_bytes The number of bytes to move through the crypto
- *                            function.  Must be greater than zero.
- *
- * @param[in]    data_in      Pointer to the array of bytes to be used as input
- *                            to the crypto function.
- *
- * @param[in]    init_vector  Pointer to the block-sized (8 byte) array of
- *                            bytes which form the initialization vector for
- *                            this operation.  A non-null value is required
- *                            when @c crypto_mode has the value #SCC_CBC_MODE;
- *                            the value is ignored in #SCC_ECB_MODE.
- *
- * @param[in]    direction    Direct the driver to perform encryption or
- *                            decryption.
- *
- * @param[in]    crypto_mode  Run the crypto function in ECB or CBC mode.
- *
- * @param[in]    check_mode   During encryption, generate and append a check
- *                            value to the plaintext and pad the resulting
- *                            data.  During decryption, validate the plaintext
- *                            with that check value and remove the padding.
- *
- * @param[in,out] count_out_bytes On input, the number of bytes available for
- *                            copying to @c data_out.  On return, the number of
- *                            bytes copied to @c data_out.
- *
- * @param[out] data_out       Pointer to the array of bytes that are where the
- *                            output of the crypto function are to be placed.
- *                            For encryption, this must be able to hold a
- *                            longer ciphertext than the plaintext message at
- *                            @c data_in.  The driver will append a 'pad' of
- *                            1-8 bytes to the message, and if @c check_mode is
- *                            used, additional bytes may be added, the number
- *                            depending upon the type of check being requested.
- *
- * @return     0 on success, non-zero on failure.  See #scc_return_t.
- *
- * @internal
- * This function will verify SCC state and the functions parameters.  It will
- * acquire the crypto lock, and set up some SCC registers and variables common
- * to encryption and decryption.  A rough check will be made to verify that
- * enough space is available in @c count_out_bytes.  Upon success, either the
- * #scc_encrypt or #scc_decrypt routine will be called to do the actual work.
- * The crypto lock will then be released.
- */
-extern scc_return_t scc_crypt(unsigned long count_in_bytes,
-				      const uint8_t * data_in,
-				      const uint8_t * init_vector,
-				      scc_enc_dec_t direction,
-				      scc_crypto_mode_t crypto_mode,
-				      scc_verify_t check_mode,
-				      uint8_t * data_out,
-				      unsigned long *count_out_bytes);
-
-
-/*!
- * Allocate a key slot for a stored key (or other stored value).
- *
- * This feature is to allow decrypted secret values to be kept in RED RAM.
- * This can all visibility of the data only by Sahara.
- *
- * @param   value_size_bytes  Size, in bytes, of RED key/value.  Currently only
- *                            a size up to 32 bytes is supported.
- *
- * @param      owner_id       A value which will control access to the slot.
- *                            It must be passed into to any subsequent calls to
- *                            use the assigned slot.
- *
- * @param[out] slot           The slot number for the key.
- *
- * @return     0 on success, non-zero on failure.  See #scc_return_t.
- */
-	extern scc_return_t scc_alloc_slot(uint32_t value_size_bytes,
-					   uint64_t owner_id, uint32_t * slot);
-
-/*!
- * Deallocate the key slot of a stored key or secret value.
- *
- * @param      owner_id       The id which owns the @c slot.
- *
- * @param      slot           The slot number for the key.
-
- * @return     0 on success, non-zero on failure.  See #scc_return_t.
- */
-	extern scc_return_t scc_dealloc_slot(uint64_t owner_id, uint32_t slot);
-
-/*!
- * Load a value into a slot.
- *
- * @param owner_id      Value of owner of slot
- * @param slot          Handle of slot
- * @param key_data      Data to load into the slot
- * @param key_length    Length, in bytes, of @c key_data to copy to SCC.
- *
- * @return SCC_RET_OK on success.  SCC_RET_FAIL will be returned if slot
- * specified cannot be accessed for any reason, or SCC_RET_INSUFFICIENT_SPACE
- * if @c key_length exceeds the size of the slot.
- */
-	extern scc_return_t scc_load_slot(uint64_t owner_id, uint32_t slot,
-					  const uint8_t * key_data,
-					  uint32_t key_length);
-/*!
- * Read a value from a slot.
- *
- * @param owner_id      Value of owner of slot
- * @param slot          Handle of slot
- * @param key_length    Length, in bytes, of @c key_data to copy from SCC.
- * @param key_data      Location to write the key
- *
- * @return SCC_RET_OK on success.  SCC_RET_FAIL will be returned if slot
- * specified cannot be accessed for any reason, or SCC_RET_INSUFFICIENT_SPACE
- * if @c key_length exceeds the size of the slot.
- */
-	extern scc_return_t scc_read_slot(uint64_t owner_id, uint32_t slot,
-					  uint32_t key_length,
-					  uint8_t * key_data);
-
-/*!
- * Allocate a key slot to fit the requested size.
- *
- * @param owner_id      Value of owner of slot
- * @param slot          Handle of slot
- * @param length        Length, in bytes, of @c black_data
- * @param black_data    Location to store result of encrypting RED data in slot
- *
- * @return SCC_RET_OK on success, SCC_RET_FAIL if slot specified cannot be
- *         accessed for any reason.
- */
-	extern scc_return_t scc_encrypt_slot(uint64_t owner_id, uint32_t slot,
-					     uint32_t length,
-					     uint8_t * black_data);
-
-/*!
- * Decrypt some black data and leave result in the slot.
- *
- * @param owner_id      Value of owner of slot
- * @param slot          Handle of slot
- * @param length        Length, in bytes, of @c black_data
- * @param black_data    Location of data to dencrypt and store in slot
- *
- * @return SCC_RET_OK on success, SCC_RET_FAIL if slot specified cannot be
- *         accessed for any reason.
- */
-	extern scc_return_t scc_decrypt_slot(uint64_t owner_id, uint32_t slot,
-					     uint32_t length,
-					     const uint8_t * black_data);
-
-/*!
- * Get attributes of data in RED slot.
- *
- * @param      owner_id         The id which owns the @c slot.
- *
- * @param      slot             The slot number for the key.
- *
- * @param[out] address          Physical address of RED value.
- *
- * @param[out] value_size_bytes Length, in bytes, of RED value,
- *                              or NULL if unneeded..
- *
- * @param[out] slot_size_bytes  Length, in bytes, of slot size,
- *                              or NULL if unneeded..
- *
- * @return     0 on success, non-zero on failure.  See #scc_return_t.
- */
-	extern scc_return_t scc_get_slot_info(uint64_t owner_id, uint32_t slot,
-					      uint32_t *address,
-					      uint32_t *value_size_bytes,
-					      uint32_t *slot_size_bytes);
-
-/*!
- * Signal a software alarm to the SCC.  This will take the SCC and other PISA
- * parts out of Secure mode and into Security Failure mode.  The SCC will stay
- * in failed mode until a reboot.
- *
- * @internal
- * If the SCC is not already in fail state, simply write the
- * #SMN_COMMAND_SET_SOFTWARE_ALARM bit in #SMN_COMMAND.  Since there is no
- * reason to wait for the interrupt to bounce back, simply act as though
- * one did.
- */
-	extern void scc_set_sw_alarm(void);
-
-/*!
- * This routine will register a function to be called should a Security Failure
- * be signalled by the SCC (Security Monitor).
- *
- * The callback function may be called from interrupt level, it may be called
- * from some process' task.  It should therefore not take a long time to
- * perform its operation, and it may not sleep.
- *
- * @param  callback_func  Function pointer to routine which will receive
- *                        notification of the security failure.
- * @return         0 if function was successfully registered, non-zero on
- *                 failure.  See #scc_return_t.
- *
- * @internal
- *  There is a fixed global static array which keeps track of the requests to
- *  monitor the failure.
- *
- *  Add @c callback_func to the first empty slot in #scc_callbacks[].  If there
- *  is no room, return #SCC_RET_TOO_MANY_FUNCTIONS.
- */
-	extern scc_return_t scc_monitor_security_failure(void
-							 callback_func(void));
-
-/*!
- * This routine will deregister a function previously registered with
- * #scc_monitor_security_failure().
- *
- * @param callback_func Function pointer to routine previously registered with
- *                      #scc_stop_monitoring_security_failure().
- */
-	extern void scc_stop_monitoring_security_failure(void
-							 callback_func(void));
-
-/*!
- * Read value from an SCC register.
- * The offset will be checked for validity (range) as well as whether it is
- * accessible (e.g. not busy, not in failed state) at the time of the call.
- *
- * @param[in]   register_offset  The (byte) offset within the SCC block
- *                               of the register to be queried. See
- *                              @ref scmregs and @ref smnregs.
- * @param[out]  value            Pointer to where value from the register
- *                               should be placed.
- * @return      0 if OK, non-zero on error.  See #scc_return_t.
- *
- * @internal
- *  Verify that the register_offset is a) valid, b) refers to a readable
- *  register, and c) the SCC is in a state which would allow a read of this
- *  register.
- */
-	extern scc_return_t scc_read_register(int register_offset,
-					      uint32_t * value);
-
-/*!
- * Write a new value into an SCC register.
- * The offset will be checked for validity (range) as well as whether it is
- * accessible (e.g. not busy, not in failed state) at the time of the call.
- *
- * @param[in]  register_offset  The (byte) offset within the SCC block
- *                              of the register to be modified. See
- *                              @ref scmregs and @ref smnregs.
- * @param[in]  value            The value to store into the register.
- * @return     0 if OK, non-zero on error.  See #scc_return_t.
- *
- * @internal
- *  Verify that the register_offset is a) valid, b) refers to a writeable
- *  register, and c) the SCC is in a state which would allow a write to this
- *  register.
- */
-	extern scc_return_t scc_write_register(int register_offset,
-					       uint32_t value);
-
-/*
- * NOTE TO MAINTAINERS
- *
- * All of the doxygen comments for the register offset values are in this the
- * following comment section.  Any changes to register names or definitions
- * must be reflected in this section and in both the TAHITI and non-TAHITI
- *version of the memory map.
- */
-
-/*!
- * @defgroup scmregs SCM Registers
- *
- * These values are offsets into the SCC for the Secure Memory
- * (SCM) registers.  They are used in the @c register_offset parameter of
- * #scc_read_register() and #scc_write_register().
- */
-/*! @addtogroup scmregs */
-/*! @{ */
-/*! @def SCM_RED_START
- * Starting block offset in red memory for cipher function. */
-
-/*! @def SCM_BLACK_START
- * Starting block offset in black memory for cipher function. */
-
-/*! @def SCM_LENGTH
- * Number of blocks to process during cipher function */
-
-/*! @def SCM_CONTROL
- * SCM Control register.
- * See @ref scmcontrolregdefs "SCM Control Register definitions" for details.
- */
-
-/*! @def SCM_STATUS
- * SCM Status register.
- * See @ref scmstatusregdefs "SCM Status Register Definitions" for details.
- */
-
-/*! @def SCM_ERROR_STATUS
- * SCM Error Status Register.
- * See @ref scmerrstatdefs "SCM Error Status Register definitions" for
- * details. */
-
-/*! @def SCM_INTERRUPT_CTRL
- * SCM Interrupt Control Register.
- * See @ref scminterruptcontroldefs "SCM Interrupt Control Register definitions"
- * for details.
- */
-
-/*! @def SCM_CONFIGURATION
- * SCM Configuration Register.
- * See @ref scmconfigdefs "SCM Configuration Register Definitions" for
- * details.
- */
-
-/*! @def SCM_INIT_VECTOR_0
- * Upper Half of the Initialization Vector */
-
-/*! @def SCM_INIT_VECTOR_1
- * Lower Half of the Initialization Vector */
-
-/*! @def SCM_RED_MEMORY
- * Starting location of first block of Red memory */
-
-/*! @def SCM_BLACK_MEMORY
- * Starting location of first block of Black memory */
-
-	/*! @} *//* end of SCM group */
-
-/*!
- * @defgroup smnregs SMN Registers
- *
- * These values are offsets into the SCC for the Security Monitor
- * (SMN) registers.  They are used in the @c register_offset parameter of the
- * #scc_read_register() and #scc_write_register().
- */
-/*! @addtogroup smnregs */
-/*! @{ */
-/*! @def SMN_STATUS
- * Status register for SMN.
- * See @ref smnstatusregdefs "SMN Status Register definitions" for further
- * information.
- */
-
-/*! @def SMN_COMMAND
- * Command register for SMN. See
- * @ref smncommandregdefs "Command Register Definitions" for further
- * information.
- */
-
-/*! @def SMN_SEQUENCE_START
- * Sequence Start register for ASC. See #SMN_SEQUENCE_START_MASK
- */
-
-/*! @def SMN_SEQUENCE_END
- * Sequence End register for ASC. See #SMN_SEQUENCE_CHECK_MASK
- */
-
-/*! @def SMN_SEQUENCE_CHECK
- * Sequence Check register for ASC. See #SMN_SEQUENCE_END_MASK
- */
-
-/*! @def SMN_BIT_COUNT
- * Bit Bank Repository for AIC. See #SMN_BIT_COUNT_MASK
- */
-
-/*! @def SMN_BITBANK_INC_SIZE
- * Bit Bank Increment Size for AIC. See #SMN_BITBANK_INC_SIZE_MASK
- */
-
-/*! @def SMN_BITBANK_DECREMENT
- * Bit Bank Decrement for AIC. See #SMN_BITBANK_DECREMENT_MASK
- */
-
-/*! @def SMN_COMPARE_SIZE
- * Compare Size register for Plaintext/Ciphertext checker.  See
- * #SMN_COMPARE_SIZE_MASK */
-
-/*! @def SMN_PLAINTEXT_CHECK
- * Plaintext Check register for Plaintext/Ciphertext checker.
- */
-
-/*! @def SMN_CIPHERTEXT_CHECK
- * Ciphertext Check register for Plaintext/Ciphertext checker.
- */
-
-/*! @def SMN_TIMER_IV
- * Timer Initial Value register
- */
-
-/*! @def SMN_TIMER_CONTROL
- * Timer Control register.
- * See @ref smntimercontroldefs "SMN Timer Control Register definitions".
- */
-
-/*! @def SMN_DEBUG_DETECT_STAT
- * Debug Detector Status Register
- * See @ref smndbgdetdefs "SMN Debug Detector Status Register"for definitions.
- */
-
-/*! @def SMN_TIMER
- * Current value of the Timer Register
- */
-
-	/*! @} *//* end of SMN group */
-
-/*
- * SCC MEMORY MAP
- *
- */
-
-/* SCM registers */
-#define SCM_RED_START           0x00000000	/*          read/write       */
-#define SCM_BLACK_START         0x00000004	/*          read/write       */
-#define SCM_LENGTH              0x00000008	/*          read/write       */
-#define SCM_CONTROL             0x0000000C	/*          read/write       */
-#define SCM_STATUS              0x00000010	/*          read only        */
-#define SCM_ERROR_STATUS        0x00000014	/*          read/write       */
-#define SCM_INTERRUPT_CTRL      0x00000018	/*          read/write       */
-#define SCM_CONFIGURATION       0x0000001C	/*          read only        */
-#define SCM_INIT_VECTOR_0       0x00000020	/*          read/write       */
-#define SCM_INIT_VECTOR_1       0x00000024	/*          read/write       */
-#define SCM_RED_MEMORY          0x00000400	/*          read/write       */
-#define SCM_BLACK_MEMORY        0x00000800	/*          read/write       */
-
-/* SMN Registers */
-#define SMN_STATUS              0x00001000	/*          read/write       */
-#define SMN_COMMAND             0x00001004	/*          read/write       */
-#define SMN_SEQUENCE_START      0x00001008	/*          read/write       */
-#define SMN_SEQUENCE_END        0x0000100C	/*          read/write       */
-#define SMN_SEQUENCE_CHECK      0x00001010	/*          read/write       */
-#define SMN_BIT_COUNT           0x00001014	/*          read only        */
-#define SMN_BITBANK_INC_SIZE    0x00001018	/*          read/write       */
-#define SMN_BITBANK_DECREMENT   0x0000101C	/*          write only       */
-#define SMN_COMPARE_SIZE        0x00001020	/*          read/write       */
-#define SMN_PLAINTEXT_CHECK     0x00001024	/*          read/write       */
-#define SMN_CIPHERTEXT_CHECK    0x00001028	/*          read/write       */
-#define SMN_TIMER_IV            0x0000102C	/*          read/write       */
-#define SMN_TIMER_CONTROL       0x00001030	/*          read/write       */
-#define SMN_DEBUG_DETECT_STAT   0x00001034	/*          read/write       */
-#define SMN_TIMER               0x00001038	/*          read only        */
-
-/*! Total address space of the SCC, in bytes */
-#define SCC_ADDRESS_RANGE    0x103c
-
-/*!
- * @defgroup smnstatusregdefs SMN Status Register definitions (SMN_STATUS)
- */
-/*! @addtogroup smnstatusregdefs */
-/*! @{ */
-/*! SMN version id. */
-#define SMN_STATUS_VERSION_ID_MASK        0xfc000000
-/*!  number of bits to shift #SMN_STATUS_VERSION_ID_MASK to get it to LSB */
-#define SMN_STATUS_VERSION_ID_SHIFT       26
-/*! Cacheable access to SMN attempted.  */
-#define SMN_STATUS_CACHEABLE_ACCESS       0x02000000
-/*! Illegal bus master access attempted. */
-#define SMN_STATUS_ILLEGAL_MASTER         0x01000000
-/*! Scan mode entered/exited since last reset. */
-#define SMN_STATUS_SCAN_EXIT              0x00800000
-/*! Unaligned access attempted. */
-#define SMN_STATUS_UNALIGNED_ACCESS       0x00400000
-/*! Bad byte offset access attempted. */
-#define SMN_STATUS_BYTE_ACCESS            0x00200000
-/*! Illegal address access attempted. */
-#define SMN_STATUS_ILLEGAL_ADDRESS        0x00100000
-/*! User access attempted. */
-#define SMN_STATUS_USER_ACCESS            0x00080000
-/*! SCM is using DEFAULT key.  */
-#define SMN_STATUS_DEFAULT_KEY            0x00040000
-/*! SCM detects weak or bad key.  */
-#define SMN_STATUS_BAD_KEY                0x00020000
-/*! Illegal access to SCM detected. */
-#define SMN_STATUS_ILLEGAL_ACCESS         0x00010000
-/*! Internal error detected in SCM. */
-#define SMN_STATUS_SCM_ERROR              0x00008000
-/*! SMN has an outstanding interrupt. */
-#define SMN_STATUS_SMN_STATUS_IRQ         0x00004000
-/*! Software Alarm was triggered. */
-#define SMN_STATUS_SOFTWARE_ALARM         0x00002000
-/*! Timer has expired. */
-#define SMN_STATUS_TIMER_ERROR            0x00001000
-/*! Plaintext/Ciphertext compare failed. */
-#define SMN_STATUS_PC_ERROR               0x00000800
-/*! Bit Bank detected overflow or underflow */
-#define SMN_STATUS_BITBANK_ERROR          0x00000400
-/*! Algorithm Sequence Check failed. */
-#define SMN_STATUS_ASC_ERROR              0x00000200
-/*! Security Policy Block detected error. */
-#define SMN_STATUS_SECURITY_POLICY_ERROR  0x00000100
-/*! At least one Debug signal is active. */
-#define SMN_STATUS_DEBUG_ACTIVE           0x00000080
-/*! SCM failed to zeroize its memory. */
-#define SMN_STATUS_ZEROIZE_FAIL           0x00000040
-/*! Processor booted from internal ROM. */
-#define SMN_STATUS_INTERNAL_BOOT          0x00000020
-/*! SMN's internal state. */
-#define SMN_STATUS_STATE_MASK             0x0000001F
-/*! Number of bits to shift #SMN_STATUS_STATE_MASK to get it to LSB. */
-#define SMN_STATUS_STATE_SHIFT            0
-/*! @} */
-
-/*!
- * @defgroup sccscmstates SMN Model Secure State Controller States (SMN_STATE_MASK)
- */
-/*! @addtogroup sccscmstates */
-/*! @{ */
-/*! This is the first state of the SMN after power-on reset  */
-#define SMN_STATE_START         0x0
-/*! The SMN is zeroizing its RAM during reset */
-#define SMN_STATE_ZEROIZE_RAM   0x5
-/*! SMN has passed internal checks, and is waiting for Software check-in */
-#define SMN_STATE_HEALTH_CHECK  0x6
-/*! Fatal Security Violation.  SMN is locked, SCM is inoperative. */
-#define SMN_STATE_FAIL          0x9
-/*! SCC is in secure state.  SCM is using secret key. */
-#define SMN_STATE_SECURE        0xA
-/*! Due to non-fatal error, device is not secure.  SCM is using default key. */
-#define SMN_STATE_NON_SECURE    0xC
-/*! @} */
-
-/*!
- * @defgroup scmconfigdefs SCM Configuration Register definitions (SCM_CONFIGURATION)
- **/
-/*! @addtogroup scmconfigdefs */
-/*! @{ */
-/*! Version number of the Secure Memory. */
-#define SCM_CFG_VERSION_ID_MASK         0xf8000000
-/*! Number of bits to shift #SCM_CFG_VERSION_ID_MASK to get it to LSB. */
-#define SCM_CFG_VERSION_ID_SHIFT        27
-/*! Version one value for SCC configuration */
-#define SCM_VERSION_1    1
-/*! Size, in blocks, of Red memory. */
-#define SCM_CFG_BLACK_SIZE_MASK         0x07fe0000
-/*! Number of bits to shift #SCM_CFG_BLACK_SIZE_MASK to get it to LSB. */
-#define SCM_CFG_BLACK_SIZE_SHIFT        17
-/*! Size, in blocks, of Black memory. */
-#define SCM_CFG_RED_SIZE_MASK           0x0001ff80
-/*! Number of bits to shift #SCM_CFG_RED_SIZE_MASK to get it to LSB. */
-#define SCM_CFG_RED_SIZE_SHIFT          7
-/*! Number of bytes per block. */
-#define SCM_CFG_BLOCK_SIZE_MASK         0x0000007f
-/*! Number of bits to shift #SCM_CFG_BLOCK_SIZE_MASK to get it to LSB. */
-#define SCM_CFG_BLOCK_SIZE_SHIFT        0
-/*! @} */
-
-/*!
- * @defgroup smncommandregdefs SMN Command Register Definitions (SMN_COMMAND)
- */
-/*! @addtogroup smncommandregdefs */
-/*! @{ */
-#define SMN_COMMAND_ZEROS_MASK   0xffffff70	/*!< These bits are unimplemented
-						   or reserved */
-#define SMN_COMMAND_TAMPER_LOCK         0x10 /*!< Lock Tamper Detect Bit */
-#define SMN_COMMAND_CLEAR_INTERRUPT     0x8	/*!< Clear SMN Interrupt */
-#define SMN_COMMAND_CLEAR_BIT_BANK      0x4	/*!< Clear SMN Bit Bank */
-#define SMN_COMMAND_ENABLE_INTERRUPT    0x2	/*!< Enable SMN Interrupts */
-#define SMN_COMMAND_SET_SOFTWARE_ALARM  0x1	/*!< Set Software Alarm */
-/*! @} */
-
-/*!
- * @defgroup smntimercontroldefs SMN Timer Control Register definitions (SMN_TIMER_CONTROL)
- */
-/*! @addtogroup smntimercontroldefs */
-/*! @{ */
-/*! These bits are reserved or zero */
-#define SMN_TIMER_CTRL_ZEROS_MASK 0xfffffffc
-/*! Load the timer from #SMN_TIMER_IV */
-#define SMN_TIMER_LOAD_TIMER             0x2
-/*! Setting to zero stops the Timer */
-#define SMN_TIMER_STOP_MASK              0x1
-/*! Setting this value starts the timer */
-#define SMN_TIMER_START_TIMER            0x1
-/*! @} */
-
-/*!
- * @defgroup scminterruptcontroldefs SCM Interrupt Control Register definitions (SCM_INTERRUPT_CTRL)
- *
- * These are the bit definitions for the #SCM_INTERRUPT_CTRL register.
- */
-/*! @addtogroup scminterruptcontroldefs */ 
-/*! @{ */
-/*! Clear SCM memory */
-#define SCM_INTERRUPT_CTRL_ZEROIZE_MEMORY      0x4
-/*! Clear outstanding SCM interrupt */
-#define SCM_INTERRUPT_CTRL_CLEAR_INTERRUPT     0x2
-/*! Inhibit SCM interrupts */
-#define SCM_INTERRUPT_CTRL_MASK_INTERRUPTS     0x1
-/*! @} */
-
-/*!
- * @defgroup scmcontrolregdefs SCM Control Register definitions (SCM_CONTROL).
- * These values are used with the #SCM_CONTROL register.
- */
-/*! @addtogroup scmcontrolregdefs */
-/*! @{ */
-/*! These bits are zero or reserved */
-#define SCM_CONTROL_ZEROS_MASK    0xfffffff8
-/*! Setting this will start encrypt/decrypt */
-#define SCM_CONTROL_START_CIPHER        0x04
-/*! CBC/ECB flag.
- * See @ref scmchainmodedefs "Chaining Mode bit definitions."
- */
-#define SCM_CONTROL_CHAINING_MODE_MASK  0x02
-/*! Encrypt/decrypt choice.
- * See @ref scmciphermodedefs "Cipher Mode bit definitions." */
-#define SCM_CONTROL_CIPHER_MODE_MASK    0x01
-/*! @} */
-
-/*!
- * @defgroup scmchainmodedefs  SCM_CHAINING_MODE_MASK - Bit definitions
- */
-/*! @addtogroup scmchainmodedefs */
-/*! @{ */
-#define SCM_CBC_MODE            0x2	/*!< Cipher block chaining */
-#define SCM_ECB_MODE            0x0	/*!< Electronic codebook. */
-/*! @} */
-
-/* Bit definitions in the SCM_CIPHER_MODE_MASK */
-/*!
- * @defgroup scmciphermodedefs SCM_CIPHER_MODE_MASK - Bit definitions
- */
-/*! @{ */
-#define SCM_DECRYPT_MODE        0x1	/*!< decrypt from black to red memory */
-#define SCM_ENCRYPT_MODE        0x0	/*!< encrypt from red to black memory */
-/*! @} */
-
-/*!
- * @defgroup scmstatusregdefs  SCM Status Register (SCM_STATUS).
- * Bit and field definitions of the SCM_STATUS register.
- */
-/*! @addtogroup scmstatusregdefs */
-/*! @{ */
-/*! These bits are zero or reserved */
-#define SCM_STATUS_ZEROS_MASK        0xffffe000
-/*! Ciphering failed due to length error. */
-#define SCM_STATUS_LENGTH_ERROR          0x1000
-/*! SMN has stopped blocking access to the SCM */
-#define SCM_STATUS_BLOCK_ACCESS_REMOVED  0x0800
-/*! Ciphering done. */
-#define SCM_STATUS_CIPHERING_DONE        0x0400
-/*! Zeroizing done. */
-#define SCM_STATUS_ZEROIZING_DONE        0x0200
-/*! SCM wants attention. Interrupt status is available. */
-#define SCM_STATUS_INTERRUPT_STATUS      0x0100
-/*! Secret Key is in use. */
-#define SCM_STATUS_SECRET_KEY            0x0080
-/*! Secret Key is in use.  Deprecated.  Use #SCM_STATUS_SECRET_KEY. */
-#define SCM_STATUS_DEFAULT_KEY           0x0080
-/*! Internal error to SCM. */
-#define SCM_STATUS_INTERNAL_ERROR        0x0040
-/*! Secret key is not valid. */
-#define SCM_STATUS_BAD_SECRET_KEY        0x0020
-/*! Failed to zeroize memory. */
-#define SCM_STATUS_ZEROIZE_FAILED        0x0010
-/*! SMN is blocking access to Secure Memory. */
-#define SCM_STATUS_SMN_BLOCKING_ACCESS   0x0008
-/*! SCM is current encrypting or decrypting data. */
-#define SCM_STATUS_CIPHERING             0x0004
-/*! SCM is currently zeroizing data. */
-#define SCM_STATUS_ZEROIZING             0x0002
-/*! SCM is busy and access to memory is blocked. */
-#define SCM_STATUS_BUSY                  0x0001
-/*! @} */
-
-/*!
- * @defgroup scmerrstatdefs SCM Error Status Register (SCM_ERROR_STATUS)
- *
- * These definitions are associated with the SCM Error Status Register
- * (SCM_ERROR_STATUS).
- */
-/*! @addtogroup scmerrstatdefs */
-/*! @{ */
-/*! These bits are zero or reserved */
-#define SCM_ERR_ZEROS_MASK      0xffffc000
-/*! Cacheable access to SCM was attempted */
-#define SCM_ERR_CACHEABLE_ACCESS    0x2000
-/*! Access attempted by illegal bus master */
-#define SCM_ERR_ILLEGAL_MASTER      0x1000
-/*! Unaligned access attempted */
-#define SCM_ERR_UNALIGNED_ACCESS    0x0800
-/*! Byte or half-word access attempted */
-#define SCM_ERR_BYTE_ACCESS         0x0400
-/*! Illegal address attempted */
-#define SCM_ERR_ILLEGAL_ADDRESS     0x0200
-/*! User access attempted */
-#define SCM_ERR_USER_ACCESS         0x0100
-/*! Access attempted while SCM was using default key */
-#define SCM_ERR_SECRET_KEY_IN_USE   0x0080
-/*! Access attempted while SCM had internal error */
-#define SCM_ERR_INTERNAL_ERROR      0x0040
-/*! Access attempted while SCM was detecting Bad Key */
-#define SCM_ERR_BAD_SECRET_KEY      0x0020
-/*! The SCM failed to Zeroize memory */
-#define SCM_ERR_ZEROIZE_FAILED      0x0010
-/*! Access attempted while SMN was Blocking Access */
-#define SCM_ERR_SMN_BLOCKING_ACCESS 0x0008
-/*! Access attempted while SCM was CIPHERING */
-#define SCM_ERR_CIPHERING           0x0004
-/*! Access attempted while SCM was ZEROIZING */
-#define SCM_ERR_ZEROIZING           0x0002
-/*! Access attempted while SCM was BUSY */
-#define SCM_ERR_BUSY                0x0001
-/*! @} */
-
-/*!
- * @defgroup smndbgdetdefs SMN Debug Detector Status Register
- * (SCM_DEBUG_DETECT_STAT)
- */
-/*! @addtogroup smndbgdetdefs */
-/*! @{ */
-#define SMN_DBG_ZEROS_MASK  0xfffff000	/*!< These bits are zero or reserved */
-#define SMN_DBG_D12             0x0800	/*!< Error detected on Debug Port D12 */
-#define SMN_DBG_D11             0x0400	/*!< Error detected on Debug Port D11 */
-#define SMN_DBG_D10             0x0200	/*!< Error detected on Debug Port D10 */
-#define SMN_DBG_D9              0x0100	/*!< Error detected on Debug Port D9 */
-#define SMN_DBG_D8              0x0080	/*!< Error detected on Debug Port D8 */
-#define SMN_DBG_D7              0x0040	/*!< Error detected on Debug Port D7 */
-#define SMN_DBG_D6              0x0020	/*!< Error detected on Debug Port D6 */
-#define SMN_DBG_D5              0x0010	/*!< Error detected on Debug Port D5 */
-#define SMN_DBG_D4              0x0008	/*!< Error detected on Debug Port D4 */
-#define SMN_DBG_D3              0x0004	/*!< Error detected on Debug Port D3 */
-#define SMN_DBG_D2              0x0002	/*!< Error detected on Debug Port D2 */
-#define SMN_DBG_D1              0x0001	/*!< Error detected on Debug Port D1 */
-/*! @} */
-
-/*! Mask for the usable bits of the Sequence Start Register
-    (#SMN_SEQUENCE_START) */
-#define SMN_SEQUENCE_START_MASK    0x0000ffff
-
-/*! Mask for the usable bits of the Sequence End Register
-    (#SMN_SEQUENCE_END) */
-#define SMN_SEQUENCE_END_MASK      0x0000ffff
-
-/*! Mask for the usable bits of the Sequence Check Register
-    (#SMN_SEQUENCE_CHECK) */
-#define SMN_SEQUENCE_CHECK_MASK    0x0000ffff
-
-/*! Mask for the usable bits of the Bit Counter Register
-    (#SMN_BIT_COUNT) */
-#define SMN_BIT_COUNT_MASK         0x000007ff
-
-/*! Mask for the usable bits of the Bit Bank Increment Size Register
-    (#SMN_BITBANK_INC_SIZE) */
-#define SMN_BITBANK_INC_SIZE_MASK  0x000007ff
-
-/*! Mask for the usable bits of the Bit Bank Decrement Register
-    (#SMN_BITBANK_DECREMENT) */
-#define SMN_BITBANK_DECREMENT_MASK 0x000007ff
-
-/*! Mask for the usable bits of the Compare Size Register
-    (#SMN_COMPARE_SIZE) */
-#define SMN_COMPARE_SIZE_MASK      0x0000003f
-
-/* Close out marker for C++ compilers */
-#ifdef __cplusplus
-}
-#endif
-#endif				/* __ASM_ARCH_MXC_SCC_DRIVER_H__ */
diff --git a/include/asm-arm/arch-mxc/mxc_v4l2.h b/include/asm-arm/arch-mxc/mxc_v4l2.h
deleted file mode 100644
index ade1e18..0000000
--- a/include/asm-arm/arch-mxc/mxc_v4l2.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU Lesser General
- * Public License.  You may obtain a copy of the GNU Lesser General
- * Public License Version 2.1 or later at the following locations:
- *
- * http://www.opensource.org/licenses/lgpl-license.html
- * http://www.gnu.org/copyleft/lgpl.html
- */
-
-/*!
- * @file arch-mxc/mxc_v4l2.h
- *
- * @brief mxc V4L2 private structures
- *
- * @ingroup MXC_V4L2_CAPTURE
- */
-
-#ifndef __ASM_ARCH_MXC_V4L2_H__
-#define __ASM_ARCH_MXC_V4L2_H__
-
-#define V4L2_CID_MXC_ROT		(V4L2_CID_PRIVATE_BASE + 0)
-#define V4L2_CID_MXC_FLASH		(V4L2_CID_PRIVATE_BASE + 1)
-
-#define V4L2_MXC_ROTATE_NONE			0
-#define V4L2_MXC_ROTATE_VERT_FLIP		1
-#define V4L2_MXC_ROTATE_HORIZ_FLIP		2
-#define V4L2_MXC_ROTATE_180			3
-#define V4L2_MXC_ROTATE_90_RIGHT		4
-#define V4L2_MXC_ROTATE_90_RIGHT_VFLIP		5
-#define V4L2_MXC_ROTATE_90_RIGHT_HFLIP		6
-#define V4L2_MXC_ROTATE_90_LEFT			7
-
-struct v4l2_mxc_offset {
-	uint32_t u_offset;
-	uint32_t v_offset;
-};
-
-#endif
diff --git a/include/asm-arm/arch-mxc/mxcfb.h b/include/asm-arm/arch-mxc/mxcfb.h
deleted file mode 100644
index 4bff1a6..0000000
--- a/include/asm-arm/arch-mxc/mxcfb.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU Lesser General
- * Public License.  You may obtain a copy of the GNU Lesser General
- * Public License Version 2.1 or later at the following locations:
- *
- * http://www.opensource.org/licenses/lgpl-license.html
- * http://www.gnu.org/copyleft/lgpl.html
- */
-
-/*
- * @file arch-mxc/   mxcfb.h
- *
- * @brief Global header file for the MXC Frame buffer
- *
- * @ingroup Framebuffer
- */
-#ifndef __ASM_ARCH_MXCFB_H__
-#define __ASM_ARCH_MXCFB_H__
-
-#include <linux/fb.h>
-
-#define FB_SYNC_OE_ACT_HIGH	0x80000000
-#define FB_SYNC_CLK_INVERT	0x40000000
-#define FB_SYNC_DATA_INVERT	0x20000000
-#define FB_SYNC_CLK_IDLE_EN	0x10000000
-#define FB_SYNC_SHARP_MODE	0x08000000
-#define FB_SYNC_SWAP_RGB	0x04000000
-
-struct mxcfb_gbl_alpha {
-	int enable;
-	int alpha;
-};
-
-struct mxcfb_color_key {
-	int enable;
-	__u32 color_key;
-};
-
-struct mxcfb_pos {
-	__u16 x;
-	__u16 y;
-};
-
-#define MXCFB_WAIT_FOR_VSYNC	_IOW('F', 0x20, u_int32_t)
-#define MXCFB_SET_GBL_ALPHA     _IOW('F', 0x21, struct mxcfb_gbl_alpha)
-#define MXCFB_SET_CLR_KEY       _IOW('F', 0x22, struct mxcfb_color_key)
-#define MXCFB_SET_OVERLAY_POS   _IOW('F', 0x24, struct mxcfb_pos)
-
-#ifdef __KERNEL__
-
-extern struct fb_videomode mxcfb_modedb[];
-extern int mxcfb_modedb_sz;
-
-enum {
-	MXCFB_REFRESH_OFF,
-	MXCFB_REFRESH_AUTO,
-	MXCFB_REFRESH_PARTIAL,
-};
-
-struct mxcfb_rect {
-	u32 top;
-	u32 left;
-	u32 width;
-	u32 height;
-};
-
-int mxcfb_set_refresh_mode(struct fb_info *fbi, int mode,
-			   struct mxcfb_rect *update_region);
-
-#endif				/* __KERNEL__ */
-#endif
diff --git a/include/asm-arm/arch-mxc/pmic_adc.h b/include/asm-arm/arch-mxc/pmic_adc.h
deleted file mode 100644
index 0ddb3dc..0000000
--- a/include/asm-arm/arch-mxc/pmic_adc.h
+++ /dev/null
@@ -1,455 +0,0 @@
-/*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU Lesser General
- * Public License.  You may obtain a copy of the GNU Lesser General
- * Public License Version 2.1 or later at the following locations:
- *
- * http://www.opensource.org/licenses/lgpl-license.html
- * http://www.gnu.org/copyleft/lgpl.html
- */
-
-#ifndef __ASM_ARCH_MXC_PMIC_ADC_H__
-#define __ASM_ARCH_MXC_PMIC_ADC_H__
-
-/*!
- * @defgroup PMIC_ADC PMIC Digitizer Driver
- * @ingroup PMIC_DRVRS
- */
-
-/*!
- * @file arch-mxc/pmic_adc.h
- * @brief This is the header of PMIC ADC driver.
- *
- * @ingroup PMIC_ADC
- */
-
-#include <asm/ioctl.h>
-#include <asm/arch/pmic_status.h>
-#include <asm/arch/pmic_external.h>
-
-/*!
- * @name IOCTL user space interface
- */
-
-/*! @{ */
-/*!
- * Initialize ADC.
- * Argument type: none.
- */
-#define PMIC_ADC_INIT                   _IO('p', 0xb0)
-/*!
- * De-initialize ADC.
- * Argument type: none.
- */
-#define PMIC_ADC_DEINIT                 _IO('p', 0xb1)
-/*!
- * Convert one channel.
- * Argument type: pointer to t_adc_convert_param.
- */
-#define PMIC_ADC_CONVERT                _IOWR('p', 0xb2, int)
-/*!
- * Convert one channel eight samples.
- * Argument type: pointer to t_adc_convert_param.
- */
-#define PMIC_ADC_CONVERT_8X             _IOWR('p', 0xb3, int)
-/*!
- * Convert multiple channels.
- * Argument type: pointer to t_adc_convert_param.
- */
-#define PMIC_ADC_CONVERT_MULTICHANNEL   _IOWR('p', 0xb4, int)
-/*!
- * Set touch screen operation mode.
- * Argument type: t_touch_mode.
- */
-#define PMIC_ADC_SET_TOUCH_MODE         _IOW('p', 0xb5, int)
-/*!
- * Get touch screen operation mode.
- * Argument type: pointer to t_touch_mode.
- */
-#define PMIC_ADC_GET_TOUCH_MODE         _IOR('p', 0xb6, int)
-/*!
- * Get touch screen sample.
- * Argument type: pointer to t_touch_sample.
- */
-#define PMIC_ADC_GET_TOUCH_SAMPLE       _IOWR('p', 0xb7, int)
-/*!
- * Get battery current.
- * Argument type: pointer to unsigned short.
- */
-#define PMIC_ADC_GET_BATTERY_CURRENT    _IOR('p', 0xb8, int)
-/*!
- * Activate comparator.
- * Argument type: pointer to t_adc_comp_param.
- */
-#define PMIC_ADC_ACTIVATE_COMPARATOR    _IOW('p', 0xb9, int)
-/*!
- * De-active comparator.
- * Argument type: none.
- */
-#define PMIC_ADC_DEACTIVE_COMPARATOR    _IOW('p', 0xba, int)
-
-/*!
- * Install touch screen read interface.
- */
-#define TOUCH_SCREEN_READ_INSTALL       _IOWR('D',4, int)
-/*!
- * Remove touch screen read interface.
- */
-#define TOUCH_SCREEN_READ_UNINSTALL     _IOWR('D',5, int)
-
-/*! @{ */
-/*!
- * @name Touch Screen minimum and maximum values
- */
-#define TS_X_MIN                80	/*! < Minimum X */
-#define TS_Y_MIN                80	/*! < Minimum Y */
-
-#define TS_X_MAX                1000	/*! < Maximum X */
-#define TS_Y_MAX                1000	/*! < Maximum Y */
-/*! @} */
-/*!
- * This enumeration defines input channels for PMIC ADC
- */
-
-typedef enum {
-	BATTERY_VOLTAGE,
-	BATTERY_CURRENT,
-	CHARGE_VOLTAGE,
-	CHARGE_CURRENT,
-	APPLICATION_SUPPLY,
-	TS_X_POS1,
-	TS_X_POS2,
-	TS_Y_POS1,
-	TS_Y_POS2,
-	GEN_PURPOSE_AD4,
-	GEN_PURPOSE_AD5,
-	GEN_PURPOSE_AD6,
-	GEN_PURPOSE_AD7,
-	GEN_PURPOSE_AD8,
-	GEN_PURPOSE_AD9,
-	GEN_PURPOSE_AD10,
-	GEN_PURPOSE_AD11,
-	USB_ID,
-	LICELL,
-	RAWEXTBPLUSSENSE,
-	MPBSENSE,
-	BATSENSE,
-	GND,
-	THERMISTOR,
-	DIE_TEMP
-} t_channel;
-
-/*!
- * This enumeration defines reason of ADC Comparator interrupt.
- */
-typedef enum {
-	/*!
-	 * Greater than WHIGH
-	 */
-	GTWHIGH,
-	/*!
-	 * Less than WLOW
-	 */
-	LTWLOW,
-} t_comp_exception;
-
-/*!
- * ADC comparator callback function type
- */
-typedef void (*t_comparator_cb) (t_comp_exception reason);
-
-/*!
- * This enumeration defines the touch screen operation modes.
- */
-typedef enum {
-	/*!
-	 * Touch Screen X position
-	 */
-	TS_X_POSITION = 0,
-	/*!
-	 * Touch Screen Y position
-	 */
-	TS_Y_POSITION = 1,
-	/*!
-	 * Pressure
-	 */
-	TS_PRESSURE = 2,
-	/*!
-	 * Plate X
-	 */
-	TS_PLATE_X = 3,
-	/*!
-	 * Plate Y
-	 */
-	TS_PLATE_Y = 4,
-	/*!
-	 * Standby
-	 */
-	TS_STANDBY = 5,
-	/*!
-	 * No touch screen, TSX1, TSX2, TSY1 and TSY2 are used as  general
-	 * purpose A/D inputs.
-	 */
-	TS_NONE = 6,
-} t_touch_mode;
-/*!
- * This structure is used to report touch screen value.
- */
-typedef struct {
-/*!
-	 * Touch Screen X position
-	 */
-	unsigned int x_position;
-	/*!
-	 * Touch Screen X position1
-	 */
-	unsigned int x_position1;
-	/*!
-	 * Touch Screen X position2
-	 */
-	unsigned int x_position2;
-	/*!
-	 * Touch Screen X position3
-	 */
-	unsigned int x_position3;
-	/*!
-	 * Touch Screen Y position
-	 */
-	unsigned int y_position;
-	/*!
-	 * Touch Screen Y position1
-	 */
-	unsigned int y_position1;
-	/*!
-	 * Touch Screen Y position2
-	 */
-	unsigned int y_position2;
-	/*!
-	 * Touch Screen Y position3
-	 */
-	unsigned int y_position3;
-	/*!
-	 * Touch Screen contact value
-	 */
-	unsigned int contact_resistance;
-} t_touch_screen;
-
-/*!
- * This enumeration defines ADC conversion modes.
- */
-typedef enum {
-	/*!
-	 * Sample 8 channels, 1 sample per channel
-	 */
-	ADC_8CHAN_1X = 0,
-	/*!
-	 * Sample 1 channel 8 times
-	 */
-	ADC_1CHAN_8X,
-} t_conversion_mode;
-
-/*!
- * This structure is used with IOCTL code \a PMIC_ADC_CONVERT,
- * \a PMIC_ADC_CONVERT_8X and \a PMIC_ADC_CONVERT_MULTICHANNEL.
- */
-
-typedef struct {
-	/*!
-	 * channel or channels to be sampled.
-	 */
-	t_channel channel;
-	/*!
-	 * holds up to 16 sampling results
-	 */
-	unsigned short result[16];
-} t_adc_convert_param;
-
-/*!
- * This structure is used to activate/deactivate ADC comparator.
- */
-typedef struct {
-	/*!
-	 * wlow.
-	 */
-	unsigned char wlow;
-	/*!
-	 * whigh.
-	 */
-	unsigned char whigh;
-	/*!
-	 * channel to monitor
-	 */
-	t_channel channel;
-	/*!
-	 * callback function.
-	 */
-	t_comparator_cb callback;
-} t_adc_comp_param;
-
-/* EXPORTED FUNCTIONS */
-
-#ifdef __KERNEL__
-/*!
- * This function initializes all ADC registers with default values. This
- * function also registers the interrupt events.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_adc_init(void);
-
-/*!
- * This function disables the ADC, de-registers the interrupt events.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_adc_deinit(void);
-
-/*!
- * This function triggers a conversion and returns one sampling result of one
- * channel.
- *
- * @param        channel   The channel to be sampled
- * @param        result    The pointer to the conversion result. The memory
- *                         should be allocated by the caller of this function.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-
-PMIC_STATUS pmic_adc_convert(t_channel channel, unsigned short *result);
-
-/*!
- * This function triggers a conversion and returns eight sampling results of
- * one channel.
- *
- * @param        channel   The channel to be sampled
- * @param        result    The pointer to array to store eight sampling results.
- *                         The memory should be allocated by the caller of this
- *                         function.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-
-PMIC_STATUS pmic_adc_convert_8x(t_channel channel, unsigned short *result);
-
-/*!
- * This function triggers a conversion and returns sampling results of each
- * specified channel.
- *
- * @param        channels  This input parameter is bitmap to specify channels
- *                         to be sampled.
- * @param        result    The pointer to array to store sampling result.
- *                         The order of the result in the array is from lowest
- *                         channel number to highest channel number of the
- *                         sampled channels.
- *                         The memory should be allocated by the caller of this
- *                         function.
- *			   Note that the behavior of this function might differ
- *			   from one platform to another regarding especially
- *			   channels order.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-
-PMIC_STATUS pmic_adc_convert_multichnnel(t_channel channels,
-					 unsigned short *result);
-
-/*!
- * This function sets touch screen operation mode.
- *
- * @param        touch_mode   Touch screen operation mode.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_adc_set_touch_mode(t_touch_mode touch_mode);
-
-/*!
- * This function retrieves the current touch screen operation mode.
- *
- * @param        touch_mode   Pointer to the retrieved touch screen operation
- *                            mode.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_adc_get_touch_mode(t_touch_mode * touch_mode);
-
-/*!
- * This function retrieves the current touch screen operation mode.
- *
- * @param        touch_sample Pointer to touch sample.
- * @param        wait	Indicates if this function needs to block or not.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_adc_get_touch_sample(t_touch_screen * ts_value, int wait);
-
-/*!
- * This function starts a Battery Current mode conversion.
- *
- * @param        mode      Conversion mode.
- * @param        result    Battery Current measurement result.
- *                         if \a mode = ADC_8CHAN_1X, the result is \n
- *                             result[0] = (BATTP - BATT_I) \n
- *                         if \a mode = ADC_1CHAN_8X, the result is \n
- *                             result[0] = BATTP \n
- *                             result[1] = BATT_I \n
- *                             result[2] = BATTP \n
- *                             result[3] = BATT_I \n
- *                             result[4] = BATTP \n
- *                             result[5] = BATT_I \n
- *                             result[6] = BATTP \n
- *                             result[7] = BATT_I
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_adc_get_battery_current(t_conversion_mode mode,
-					 unsigned short *result);
-
-/*!
- * This function actives the comparator.  When comparator is activated and ADC
- * is enabled, the 8th converted value will be digitally compared against the
- * window defined by WLOW and WHIGH registers.
- *
- * @param        low      Comparison window low threshold (WLOW).
- * @param        high     Comparison window high threshold (WHIGH).
- * @param        callback Callback function to be called when the converted
- *                        value is beyond the comparison window.  The callback
- *                        function will pass a parameter of type
- *                        \b t_comp_expection to indicate the reason of
- *                        comparator exception.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-
-PMIC_STATUS pmic_adc_active_comparator(unsigned char low,
-				       unsigned char high,
-				       t_channel channel,
-				       t_comparator_cb callback);
-
-/*!
- * This function de-actives the comparator.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_adc_deactive_comparator(void);
-
-/*!
- * This function enables the touch screen read interface.
- *
- * @return       This function returns 0 if successful.
- */
-PMIC_STATUS pmic_adc_install_ts(void);
-
-/*!
- * This function disables the touch screen read interface.
- *
- * @return       This function returns 0 if successful.
- */
-PMIC_STATUS pmic_adc_remove_ts(void);
-
-int is_pmic_adc_ready(void);
-
-#endif				/* _KERNEL */
-#endif				/* __ASM_ARCH_MXC_PMIC_ADC_H__ */
diff --git a/include/asm-arm/arch-mxc/pmic_audio.h b/include/asm-arm/arch-mxc/pmic_audio.h
index 2e0e2d1..8ec3d2c 100644
--- a/include/asm-arm/arch-mxc/pmic_audio.h
+++ b/include/asm-arm/arch-mxc/pmic_audio.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -32,8 +32,8 @@
  * @ingroup PMIC_AUDIO
  */
 
-#include <asm/arch/pmic_status.h>
-#include <asm/arch/pmic_external.h>
+#include <linux/pmic_status.h>
+#include <linux/pmic_external.h>
 
 /***************************************************************************
  *                       TYPEDEFS AND ENUMERATIONS                         *
diff --git a/include/asm-arm/arch-mxc/pmic_battery.h b/include/asm-arm/arch-mxc/pmic_battery.h
deleted file mode 100644
index e216436..0000000
--- a/include/asm-arm/arch-mxc/pmic_battery.h
+++ /dev/null
@@ -1,419 +0,0 @@
-/*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU Lesser General
- * Public License.  You may obtain a copy of the GNU Lesser General
- * Public License Version 2.1 or later at the following locations:
- *
- * http://www.opensource.org/licenses/lgpl-license.html
- * http://www.gnu.org/copyleft/lgpl.html
- */
-#ifndef __ASM_ARCH_MXC_PMIC_BATTERY_H__
-#define __ASM_ARCH_MXC_PMIC_BATTERY_H__
-
-/*!
- * @defgroup PMIC_BATTERY PMIC Battery Driver
- * @ingroup PMIC_DRVRS
- */
-
-/*!
- * @file arch-mxc/pmic_battery.h
- * @brief This is the header of PMIC Battery driver.
- *
- * @ingroup PMIC_BATTERY
- */
-
-#include <asm/ioctl.h>
-#include <asm/arch/pmic_status.h>
-#include <asm/arch/pmic_external.h>
-
-/*!
- * @name IOCTL user space interface
- */
-
-/*! @{ */
-/*!
- * Enable and disable charger.
- * Argument type: pointer to t_charger_setting
- */
-#define PMIC_BATT_CHARGER_CONTROL              _IOW('p', 0xc0, int)
-/*!
- * Set charger configuration.
- * Argument type: pointer to t_charger_setting
- */
-#define PMIC_BATT_SET_CHARGER                  _IOW('p', 0xc1, int)
-/*!
- * Get charger configuration.
- * Argument type: pointer to t_charger_setting
- */
-#define PMIC_BATT_GET_CHARGER                  _IOR('p', 0xc2, int)
-/*!
- * Get charger current.
- * Argument type: pointer to t_charger_setting
- */
-#define PMIC_BATT_GET_CHARGER_CURRENT          _IOR('p', 0xc3, int)
-/*!
- * Set EOL control
- * Argument type: pointer to t_eol_setting
- */
-#define PMIC_BATT_EOL_CONTROL                   _IOW('p', 0xc4, int)
-/*!
- * Enable and disable charging LED.
- * Argument type: bool
- */
-#define PMIC_BATT_LED_CONTROL                   _IOW('p', 0xc5, int)
-/*!
- * Enable and disable reverse supply.
- * Argument type: bool
- */
-#define PMIC_BATT_REV_SUPP_CONTROL              _IOW('p', 0xc6, int)
-/*!
- * Enable and disable unregulated charging mode.
- * Argument type: bool
- */
-#define PMIC_BATT_UNREG_CONTROL                 _IOW('p', 0xc7, int)
-
-/*!
- * Set the output controls.
- * Argument type: t_control
- */
-#define PMIC_BATT_SET_OUT_CONTROL                _IOW('p', 0xc8, int)
-/*!
- * Set the over voltage threshold.
- * Argument type: int
- */
-#define PMIC_BATT_SET_THRESHOLD	                 _IOW('p', 0xc9, int)
-
-/*!
- * Get the charger voltage.
- * Argument type: int
- */
-#define PMIC_BATT_GET_CHARGER_VOLTAGE		_IOR('p', 0xca, int)
-/*!
- * Get the battery voltage.
- * Argument type: int
- */
-#define PMIC_BATT_GET_BATTERY_VOLTAGE		_IOR('p', 0xcb, int)
-/*!
- * Get the battery current.
- * Argument type: int
- */
-#define PMIC_BATT_GET_BATTERY_CURRENT		_IOR('p', 0xcc, int)
-/*!
- * Get the charger sensor.
- * Argument type: int
- */
-#define PMIC_BATT_GET_CHARGER_SENSOR		_IOR('p', 0xcd, int)
-/*!
- * Get the battery temperature.
- * Argument type: int
- */
-#define PMIC_BATT_GET_BATTERY_TEMPERATURE	_IOR('p', 0xce, int)
-/*! @} */
-
-/*!
- * This enumeration defines battery chargers.
- */
-typedef enum {
-	BATT_MAIN_CHGR = 0,	/*!< Main battery charger */
-	BATT_CELL_CHGR,		/*!< Cell battery charger */
-	BATT_TRCKLE_CHGR	/*!< Trickle charger (only available on mc13783) */
-} t_batt_charger;
-
-/*!
- * This enumeration defines the bp threshold.
- */
-typedef enum {
-	BATT_BP_0 = 0,		/*!< LOBATL UVDET + 0.2 */
-	BATT_BP_1,		/*!< LOBATL UVDET + 0.3 */
-	BATT_BP_2,		/*!< LOBATL UVDET + 0.4 */
-	BATT_BP_3		/*!< LOBATL UVDET + 0.5 */
-} t_bp_threshold;
-
-/*!
- * This enumeration of all types of output controls
- */
-typedef enum {
-	/*!
-	 * controlled hardware
-	 */
-	CONTROL_HARDWARE = 0,
-	/*!
-	 * BPFET is driven low, BATTFET is driven high
-	 */
-	CONTROL_BPFET_LOW,
-	/*!
-	 * BPFET is driven high, BATTFET is driven low
-	 */
-	CONTROL_BPFET_HIGH,
-} t_control;
-
-/*!
- * This enumeration define all battery interrupt
- */
-typedef enum {
-	/*!
-	 * Charge detection interrupt
-	 */
-	BAT_IT_CHG_DET,
-	/*!
-	 * Charge over voltage detection it
-	 */
-	BAT_IT_CHG_OVERVOLT,
-	/*!
-	 * Charge path reverse current it
-	 */
-	BAT_IT_CHG_REVERSE,
-	/*!
-	 * Charge path short circuitin revers supply mode it
-	 */
-	BAT_IT_CHG_SHORT_CIRCUIT,
-	/*!
-	 * Charger has switched its mode (CC to CV or CV to CC)
-	 */
-	BAT_IT_CCCV,
-	/*!
-	 * Charge current has dropped below its threshold
-	 */
-	BAT_IT_BELOW_THRESHOLD,
-} t_batt_event;
-
-/*!
- * This structure is used for the following battery changer control
- * IOCTLs:
- * - PMIC_BATT_CHARGER_CONTROL
- * - PMIC_BATT_SET_CHARGER
- * - PMIC_BATT_GET_CHARGER
- */
-typedef struct {
-	/*!
-	 * Charger
-	 */
-	t_batt_charger chgr;
-	/*!
-	 * Turn on charger
-	 */
-	bool on;
-	/*!
-	 * Charging voltage
-	 */
-	unsigned char c_voltage;
-	/*!
-	 * Charging current
-	 */
-	unsigned char c_current;
-} t_charger_setting;
-
-/*!
- * This structure is used for EOL setting IOCTL PMIC_BATT_EOL_CONTROL
- */
-typedef struct {
-	/*!
-	 * Enable EOL comparator
-	 */
-	bool enable;
-	/*!
-	 * c_voltage threshold - Used on SC55112
-	 */
-	unsigned char threshold;
-	/*!
-	 * bp threshold - Used on mc13783
-	 */
-	t_bp_threshold typical;
-} t_eol_setting;
-
-/* EXPORTED FUNCTIONS */
-
-#ifdef __KERNEL__
-
-/*START: for 3ds hw event*/
-/*!
- * Battery event type enum
- */
-enum {
-	BAT_EVENT_CHARGER_PLUG = 0x01,
-	BAT_EVENT_CHARGER_UNPLUG = 0x02,
-	BAT_EVENT_CHARGER_OVERVOLTAGE = 0x04,
-	BAT_EVENT_BATTERY_LOW = 0x08,
-	BAT_EVENT_POWER_FAILED = 0x10,
-	BAT_EVENT_CHARGER_FULL = 0x20,
-} t_bat_event;
-/*END: for 3ds hw event*/
-
-/*!
- * This function is used to start charging a battery. For different charger,
- * different c_voltage and current range are supported. \n
- *
- *
- * @param      chgr        Charger as defined in \b t_batt_charger.
- * @param      c_voltage     Charging voltage.
- * @param      c_current     Charging current.
- *
- * @return     This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_batt_enable_charger(t_batt_charger chgr,
-				     unsigned char c_voltage,
-				     unsigned char c_current);
-
-/*!
- * This function turns off a charger.
- *
- * @param      chgr        Charger as defined in \b t_batt_charger.
- *
- * @return     This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_batt_disable_charger(t_batt_charger chgr);
-
-/*!
- * This function is used to change the charger setting.
- *
- * @param      chgr        Charger as defined in \b t_batt_charger.
- * @param      c_voltage   Charging voltage.
- * @param      c_current   Charging current.
- *
- * @return     This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_batt_set_charger(t_batt_charger chgr,
-				  unsigned char c_voltage,
-				  unsigned char c_current);
-
-/*!
- * This function is used to retrieve the charger setting.
- *
- * @param      chgr        Charger as defined in \b t_batt_charger.
- * @param      c_voltage   Output parameter for charging c_voltage setting.
- * @param      c_current   Output parameter for charging current setting.
- *
- * @return     This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_batt_get_charger_setting(t_batt_charger chgr,
-					  unsigned char *c_voltage,
-					  unsigned char *c_current);
-
-/*!
- * This function is retrieves the main battery charging current.
- *
- * @param      c_current     Output parameter for charging current setting.
- *
- * @return     This function returns PMIC_SUCCESS if successful.
- */
-
-PMIC_STATUS pmic_batt_get_charge_current(unsigned short *c_current);
-
-/*!
- * This function enables End-of-Life comparator.
- *
- * @param      threshold  End-of-Life threshold.
- *
- * @return     This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_batt_enable_eol(unsigned char threshold);
-
-/*!
- * This function enables End-of-Life comparator.
- *
- * @param      typical  Falling Edge Threshold threshold.
- *                      @verbatim
-                        BPDET   UVDET   LOBATL
-                        ____    _____   ___________
-                        0       2.6     UVDET + 0.2
-                        1       2.6     UVDET + 0.3
-                        2       2.6     UVDET + 0.4
-                        3       2.6     UVDET + 0.5
- *
- * @return     This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_batt_bp_enable_eol(t_bp_threshold typical);
-
-/*!
- * This function disables End-of-Life comparator.
- *
- * @return     This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_batt_disable_eol(void);
-
-/*!
- * This function sets the output controls.
- * It sets the FETOVRD and FETCTRL bits of mc13783
- *
- * @param        control        type of control.
- *
- * @return       This function returns 0 if successful.
- */
-PMIC_STATUS pmic_batt_set_out_control(t_control control);
-
-/*!
- * This function sets over voltage threshold.
- *
- * @param        threshold      value of over voltage threshold.
- *
- * @return       This function returns 0 if successful.
- */
-PMIC_STATUS pmic_batt_set_threshold(int threshold);
-
-/*!
- * This function controls charge LED.
- *
- * @param      on   If on is true, LED will be turned on,
- *                  or otherwise, LED will be turned off.
- *
- * @return     This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_batt_led_control(bool on);
-
-/*!
- * This function sets reverse supply mode.
- *
- * @param      enable     If enable is true, reverse supply mode is enable,
- *                        or otherwise, reverse supply mode is disabled.
- *
- * @return     This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_batt_set_reverse_supply(bool enable);
-
-/*!
- * This function sets unregulated charging mode on main battery.
- *
- * @param      enable     If enable is true, unregulated charging mode is
- *                        enable, or otherwise, disabled.
- *
- * @return     This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_batt_set_unregulated(bool enable);
-
-/*!
- * This function sets a 5K pull down at CHRGRAW.
- * To be used in the dual path charging configuration.
- *
- * @param      enable     If enable is true, 5k pull down is
- *                        enable, or otherwise, disabled.
- *
- * @return     This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_batt_set_5k_pull(bool enable);
-
-/*!
- * This function is used to subscribe on battery event IT.
- *
- * @param        event          type of event.
- * @param        callback       event callback function.
- *
- * @return       This function returns 0 if successful.
- */
-PMIC_STATUS pmic_batt_event_subscribe(t_batt_event event, void *callback);
-
-/*!
- * This function is used to un subscribe on battery event IT.
- *
- * @param        event          type of event.
- * @param        callback       event callback function.
- *
- * @return       This function returns 0 if successful.
- */
-PMIC_STATUS pmic_batt_event_unsubscribe(t_batt_event event, void *callback);
-
-#endif				/* __KERNEL__ */
-
-#endif				/* __ASM_ARCH_MXC_PMIC_BATTERY_H__ */
diff --git a/include/asm-arm/arch-mxc/pmic_convity.h b/include/asm-arm/arch-mxc/pmic_convity.h
index 55fc280..b88bb54 100644
--- a/include/asm-arm/arch-mxc/pmic_convity.h
+++ b/include/asm-arm/arch-mxc/pmic_convity.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -34,8 +34,8 @@
  * @ingroup PMIC_CONNECTIVITY
  */
 
-#include <asm/arch/pmic_status.h>
-#include <asm/arch/pmic_external.h>
+#include <linux/pmic_status.h>
+#include <linux/pmic_external.h>
 
 /***************************************************************************
  *                       TYPEDEFS AND ENUMERATIONS                         *
diff --git a/include/asm-arm/arch-mxc/pmic_external.h b/include/asm-arm/arch-mxc/pmic_external.h
deleted file mode 100644
index 8861193..0000000
--- a/include/asm-arm/arch-mxc/pmic_external.h
+++ /dev/null
@@ -1,1131 +0,0 @@
-/*
- * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-#ifndef __ASM_ARCH_MXC_PMIC_EXTERNAL_H__
-#define __ASM_ARCH_MXC_PMIC_EXTERNAL_H__
-
-#ifdef __KERNEL__
-#include <linux/list.h>
-#endif
-
-/*!
- * @defgroup PMIC_DRVRS PMIC Drivers
- */
-
-/*!
- * @defgroup PMIC_CORE PMIC Protocol Drivers
- * @ingroup PMIC_DRVRS
- */
-
-/*!
- * @file arch-mxc/pmic_external.h
- * @brief This file contains interface of PMIC protocol driver.
- *
- * @ingroup PMIC_CORE
- */
-
-#include <asm/ioctl.h>
-#include <asm/arch/pmic_status.h>
-
-/*!
- * This is the enumeration of versions of PMIC
- */
-typedef enum {
-	PMIC_MC13783 = 1,	/*!< MC13783 */
-	PMIC_SC55112 = 2,	/*!< SC55112 */
-	PMIC_MC13892 = 3,
-	PMIC_MC34704 = 4
-} pmic_id_t;
-
-/*!
- * @struct pmic_version_t
- * @brief PMIC version and revision
- */
-typedef struct {
-	/*!
-	 * PMIC version identifier.
-	 */
-	pmic_id_t id;
-	/*!
-	 * Revision of the PMIC.
-	 */
-	int revision;
-} pmic_version_t;
-
-/*!
- * struct pmic_event_callback_t
- * @brief This structure contains callback function pointer and its
- * parameter to be used when un/registering and launching a callback
- * for an event.
- */
-typedef struct {
-	/*!
-	 * call back function
-	 */
-	void (*func) (void *);
-
-	/*!
-	 * call back function parameter
-	 */
-	void *param;
-} pmic_event_callback_t;
-
-/*!
- * This structure is used with IOCTL.
- * It defines register, register value, register mask and event number
- */
-typedef struct {
-	/*!
-	 * register number
-	 */
-	int reg;
-	/*!
-	 * value of register
-	 */
-	unsigned int reg_value;
-	/*!
-	 * mask of bits, only used with PMIC_WRITE_REG
-	 */
-	unsigned int reg_mask;
-} register_info;
-
-/*!
- * @name IOCTL definitions for sc55112 core driver
- */
-/*! @{ */
-/*! Read a PMIC register */
-#define PMIC_READ_REG          _IOWR('P', 0xa0, register_info*)
-/*! Write a PMIC register */
-#define PMIC_WRITE_REG         _IOWR('P', 0xa1, register_info*)
-/*! Subscribe a PMIC interrupt event */
-#define PMIC_SUBSCRIBE         _IOR('P', 0xa2, int)
-/*! Unsubscribe a PMIC interrupt event */
-#define PMIC_UNSUBSCRIBE       _IOR('P', 0xa3, int)
-/*! Subscribe a PMIC event for user notification*/
-#define PMIC_NOTIFY_USER       _IOR('P', 0xa4, int)
-/*! Get the PMIC event occured for which user recieved notification */
-#define PMIC_GET_NOTIFY	       _IOW('P', 0xa5, int)
-/*! @} */
-
-/*!
- * This is PMIC registers valid bits
- */
-#define PMIC_ALL_BITS           0xFFFFFF
-#define PMIC_MAX_EVENTS		48
-
-#define PMIC_ARBITRATION	"NULL"
-
-#ifdef CONFIG_MXC_PMIC_MC13783
-/*!
- * This is the enumeration of register names of MC13783
- */
-typedef enum {
-	/*!
-	 * REG_INTERRUPT_STATUS_0
-	 */
-	REG_INTERRUPT_STATUS_0 = 0,
-	/*!
-	 * REG_INTERRUPT_MASK_0
-	 */
-	REG_INTERRUPT_MASK_0,
-	/*!
-	 * REG_INTERRUPT_SENSE_0
-	 */
-	REG_INTERRUPT_SENSE_0,
-	/*!
-	 * REG_INTERRUPT_STATUS_1
-	 */
-	REG_INTERRUPT_STATUS_1,
-	/*!
-	 * REG_INTERRUPT_MASK_1
-	 */
-	REG_INTERRUPT_MASK_1,
-	/*!
-	 * REG_INTERRUPT_SENSE_1
-	 */
-	REG_INTERRUPT_SENSE_1,
-	/*!
-	 * REG_POWER_UP_MODE_SENSE
-	 */
-	REG_POWER_UP_MODE_SENSE,
-	/*!
-	 * REG_REVISION
-	 */
-	REG_REVISION,
-	/*!
-	 * REG_SEMAPHORE
-	 */
-	REG_SEMAPHORE,
-	/*!
-	 * REG_ARBITRATION_PERIPHERAL_AUDIO
-	 */
-	REG_ARBITRATION_PERIPHERAL_AUDIO,
-	/*!
-	 * REG_ARBITRATION_SWITCHERS
-	 */
-	REG_ARBITRATION_SWITCHERS,
-	/*!
-	 * REG_ARBITRATION_REGULATORS_0
-	 */
-	REG_ARBITRATION_REGULATORS_0,
-	/*!
-	 * REG_ARBITRATION_REGULATORS_1
-	 */
-	REG_ARBITRATION_REGULATORS_1,
-	/*!
-	 * REG_POWER_CONTROL_0
-	 */
-	REG_POWER_CONTROL_0,
-	/*!
-	 * REG_POWER_CONTROL_1
-	 */
-	REG_POWER_CONTROL_1,
-	/*!
-	 * REG_POWER_CONTROL_2
-	 */
-	REG_POWER_CONTROL_2,
-	/*!
-	 * REG_REGEN_ASSIGNMENT
-	 */
-	REG_REGEN_ASSIGNMENT,
-	/*!
-	 * REG_CONTROL_SPARE
-	 */
-	REG_CONTROL_SPARE,
-	/*!
-	 * REG_MEMORY_A
-	 */
-	REG_MEMORY_A,
-	/*!
-	 * REG_MEMORY_B
-	 */
-	REG_MEMORY_B,
-	/*!
-	 * REG_RTC_TIME
-	 */
-	REG_RTC_TIME,
-	/*!
-	 * REG_RTC_ALARM
-	 */
-	REG_RTC_ALARM,
-	/*!
-	 * REG_RTC_DAY
-	 */
-	REG_RTC_DAY,
-	/*!
-	 * REG_RTC_DAY_ALARM
-	 */
-	REG_RTC_DAY_ALARM,
-	/*!
-	 * REG_SWITCHERS_0
-	 */
-	REG_SWITCHERS_0,
-	/*!
-	 * REG_SWITCHERS_1
-	 */
-	REG_SWITCHERS_1,
-	/*!
-	 * REG_SWITCHERS_2
-	 */
-	REG_SWITCHERS_2,
-	/*!
-	 * REG_SWITCHERS_3
-	 */
-	REG_SWITCHERS_3,
-	/*!
-	 * REG_SWITCHERS_4
-	 */
-	REG_SWITCHERS_4,
-	/*!
-	 * REG_SWITCHERS_5
-	 */
-	REG_SWITCHERS_5,
-	/*!
-	 * REG_REGULATOR_SETTING_0
-	 */
-	REG_REGULATOR_SETTING_0,
-	/*!
-	 * REG_REGULATOR_SETTING_1
-	 */
-	REG_REGULATOR_SETTING_1,
-	/*!
-	 * REG_REGULATOR_MODE_0
-	 */
-	REG_REGULATOR_MODE_0,
-	/*!
-	 * REG_REGULATOR_MODE_1
-	 */
-	REG_REGULATOR_MODE_1,
-	/*!
-	 * REG_POWER_MISCELLANEOUS
-	 */
-	REG_POWER_MISCELLANEOUS,
-	/*!
-	 * REG_POWER_SPARE
-	 */
-	REG_POWER_SPARE,
-	/*!
-	 * REG_AUDIO_RX_0
-	 */
-	REG_AUDIO_RX_0,
-	/*!
-	 * REG_AUDIO_RX_1
-	 */
-	REG_AUDIO_RX_1,
-	/*!
-	 * REG_AUDIO_TX
-	 */
-	REG_AUDIO_TX,
-	/*!
-	 * REG_AUDIO_SSI_NETWORK
-	 */
-	REG_AUDIO_SSI_NETWORK,
-	/*!
-	 * REG_AUDIO_CODEC
-	 */
-	REG_AUDIO_CODEC,
-	/*!
-	 * REG_AUDIO_STEREO_DAC
-	 */
-	REG_AUDIO_STEREO_DAC,
-	/*!
-	 * REG_AUDIO_SPARE
-	 */
-	REG_AUDIO_SPARE,
-	/*!
-	 * REG_ADC_0
-	 */
-	REG_ADC_0,
-	/*!
-	 * REG_ADC_1
-	 */
-	REG_ADC_1,
-	/*!
-	 * REG_ADC_2
-	 */
-	REG_ADC_2,
-	/*!
-	 * REG_ADC_3
-	 */
-	REG_ADC_3,
-	/*!
-	 * REG_ADC_4
-	 */
-	REG_ADC_4,
-	/*!
-	 * REG_CHARGER
-	 */
-	REG_CHARGER,
-	/*!
-	 * REG_USB
-	 */
-	REG_USB,
-	/*!
-	 * REG_CHARGE_USB_SPARE
-	 */
-	REG_CHARGE_USB_SPARE,
-	/*!
-	 * REG_LED_CONTROL_0
-	 */
-	REG_LED_CONTROL_0,
-	/*!
-	 * REG_LED_CONTROL_1
-	 */
-	REG_LED_CONTROL_1,
-	/*!
-	 * REG_LED_CONTROL_2
-	 */
-	REG_LED_CONTROL_2,
-	/*!
-	 * REG_LED_CONTROL_3
-	 */
-	REG_LED_CONTROL_3,
-	/*!
-	 * REG_LED_CONTROL_4
-	 */
-	REG_LED_CONTROL_4,
-	/*!
-	 * REG_LED_CONTROL_5
-	 */
-	REG_LED_CONTROL_5,
-	/*!
-	 * REG_SPARE
-	 */
-	REG_SPARE,
-	/*!
-	 * REG_TRIM_0
-	 */
-	REG_TRIM_0,
-	/*!
-	 * REG_TRIM_1
-	 */
-	REG_TRIM_1,
-	/*!
-	 * REG_TEST_0
-	 */
-	REG_TEST_0,
-	/*!
-	 * REG_TEST_1
-	 */
-	REG_TEST_1,
-	/*!
-	 * REG_TEST_2
-	 */
-	REG_TEST_2,
-	/*!
-	 * REG_TEST_3
-	 */
-	REG_TEST_3,
-	/*!
-	 * REG_NB
-	 */
-	REG_NB,
-} pmic_reg;
-
-/*!
- * This is event list of mc13783 interrupt
- */
-
-typedef enum {
-	/*!
-	 * ADC has finished requested conversions
-	 */
-	EVENT_ADCDONEI = 0,
-	/*!
-	 * ADCBIS has finished requested conversions
-	 */
-	EVENT_ADCBISDONEI = 1,
-	/*!
-	 * Touchscreen wakeup
-	 */
-	EVENT_TSI = 2,
-	/*!
-	 * ADC reading above high limit
-	 */
-	EVENT_WHIGHI = 3,
-	/*!
-	 * ADC reading below low limit
-	 */
-	EVENT_WLOWI = 4,
-	/*!
-	 * Charger attach and removal
-	 */
-	EVENT_CHGDETI = 6,
-	/*!
-	 * Charger over-voltage detection
-	 */
-	EVENT_CHGOVI = 7,
-	/*!
-	 * Charger path reverse current
-	 */
-	EVENT_CHGREVI = 8,
-	/*!
-	 * Charger path short circuit
-	 */
-	EVENT_CHGSHORTI = 9,
-	/*!
-	 * BP regulator current or voltage regulation
-	 */
-	EVENT_CCCVI = 10,
-	/*!
-	 * Charge current below threshold
-	 */
-	EVENT_CHRGCURRI = 11,
-	/*!
-	 * BP turn on threshold detection
-	 */
-	EVENT_BPONI = 12,
-	/*!
-	 * End of life / low battery detect
-	 */
-	EVENT_LOBATLI = 13,
-	/*!
-	 * Low battery warning
-	 */
-	EVENT_LOBATHI = 14,
-	/*!
-	 * USB detect
-	 */
-	EVENT_USBI = 16,
-	/*!
-	 * USB ID Line detect
-	 */
-	EVENT_IDI = 19,
-	/*!
-	 * Single ended 1 detect
-	 */
-	EVENT_SE1I = 21,
-	/*!
-	 * Car-kit detect
-	 */
-	EVENT_CKDETI = 22,
-	/*!
-	 * 1 Hz time-tick
-	 */
-	EVENT_E1HZI = 24,
-	/*!
-	 * Time of day alarm
-	 */
-	EVENT_TODAI = 25,
-	/*!
-	 * ON1B event
-	 */
-	EVENT_ONOFD1I = 27,
-	/*!
-	 * ON2B event
-	 */
-	EVENT_ONOFD2I = 28,
-	/*!
-	 * ON3B event
-	 */
-	EVENT_ONOFD3I = 29,
-	/*!
-	 * System reset
-	 */
-	EVENT_SYSRSTI = 30,
-	/*!
-	 * RTC reset occurred
-	 */
-	EVENT_RTCRSTI = 31,
-	/*!
-	 * Power cut event
-	 */
-	EVENT_PCI = 32,
-	/*!
-	 * Warm start event
-	 */
-	EVENT_WARMI = 33,
-	/*!
-	 * Memory hold event
-	 */
-	EVENT_MEMHLDI = 34,
-	/*!
-	 * Power ready
-	 */
-	EVENT_PWRRDYI = 35,
-	/*!
-	 * Thermal warning lower threshold
-	 */
-	EVENT_THWARNLI = 36,
-	/*!
-	 * Thermal warning higher threshold
-	 */
-	EVENT_THWARNHI = 37,
-	/*!
-	 * Clock source change
-	 */
-	EVENT_CLKI = 38,
-	/*!
-	 * Semaphore
-	 */
-	EVENT_SEMAFI = 39,
-	/*!
-	 * Microphone bias 2 detect
-	 */
-	EVENT_MC2BI = 41,
-	/*!
-	 * Headset attach
-	 */
-	EVENT_HSDETI = 42,
-	/*!
-	 * Stereo headset detect
-	 */
-	EVENT_HSLI = 43,
-	/*!
-	 * Thermal shutdown ALSP
-	 */
-	EVENT_ALSPTHI = 44,
-	/*!
-	 * Short circuit on AHS outputs
-	 */
-	EVENT_AHSSHORTI = 45,
-	/*!
-	 * number of event
-	 */
-	EVENT_NB,
-} type_event;
-
-/*!
- * This enumeration all senses of MC13783.
- */
-typedef enum {
-	/*!
-	 * Charger attach sense
-	 */
-	SENSE_CHGDETS = 6,
-	/*!
-	 * Charger over-voltage sense
-	 */
-	SENSE_CHGOVS,
-	/*!
-	 * Charger reverse current
-	 * If 1 current flows into phone
-	 */
-	SENSE_CHGREVS,
-	/*!
-	 * Charger short circuit
-	 */
-	SENSE_CHGSHORTS,
-	/*!
-	 * Charger regulator operating mode
-	 */
-	SENSE_CCCVS,
-	/*!
-	 * Charger current below threshold
-	 */
-	SENSE_CHGCURRS,
-	/*!
-	 * BP turn on
-	 */
-	SENSE_BPONS,
-	/*!
-	 * Low bat detect
-	 */
-	SENSE_LOBATLS,
-	/*!
-	 * Low bat warning
-	 */
-	SENSE_LOBATHS,
-	/*!
-	 * UDPS
-	 */
-	SENSE_UDPS,
-	/*!
-	 * USB 4V4
-	 */
-	SENSE_USB4V4S,
-	/*!
-	 * USB 2V0
-	 */
-	SENSE_USB2V0S,
-	/*!
-	 * USB 0V8
-	 */
-	SENSE_USB0V8S,
-	/*!
-	 * ID Floats
-	 */
-	SENSE_ID_FLOATS,
-	/*!
-	 * ID Gnds
-	 */
-	SENSE_ID_GNDS,
-	/*!
-	 * Single ended
-	 */
-	SENSE_SE1S,
-	/*!
-	 * Car-kit detect
-	 */
-	SENSE_CKDETS,
-	/*!
-	 * UDMS
-	 */
-	SENSE_UDMS,
-	/*!
-	 * mic bias detect
-	 */
-	SENSE_MC2BS,
-	/*!
-	 * headset attached
-	 */
-	SENSE_HSDETS,
-	/*!
-	 * ST headset attached
-	 */
-	SENSE_HSLS,
-	/*!
-	 * Thermal shutdown ALSP
-	 */
-	SENSE_ALSPTHS,
-	/*!
-	 * short circuit on AHS
-	 */
-	SENSE_AHSSHORTS,
-	/*!
-	 * ON1B pin is hight
-	 */
-	SENSE_ONOFD1S,
-	/*!
-	 * ON2B pin is hight
-	 */
-	SENSE_ONOFD2S,
-	/*!
-	 * ON3B pin is hight
-	 */
-	SENSE_ONOFD3S,
-	/*!
-	 * System reset power ready
-	 */
-	SENSE_PWRRDYS,
-	/*!
-	 * Thermal warning higher threshold
-	 */
-	SENSE_THWARNHS,
-	/*!
-	 * Thermal warning lower threshold
-	 */
-	SENSE_THWARNLS,
-	/*!
-	 * Clock source is XTAL
-	 */
-	SENSE_CLKS,
-} t_sensor;
-
-/*!
- * This structure is used to read all sense bits of MC13783.
- */
-typedef struct {
-	/*!
-	 * Charger attach sense
-	 */
-	bool sense_chgdets;
-	/*!
-	 * Charger over-voltage sense
-	 */
-	bool sense_chgovs;
-	/*!
-	 * Charger reverse current
-	 * If 1 current flows into phone
-	 */
-	bool sense_chgrevs;
-	/*!
-	 * Charger short circuit
-	 */
-	bool sense_chgshorts;
-	/*!
-	 * Charger regulator operating mode
-	 */
-	bool sense_cccvs;
-	/*!
-	 * Charger current below threshold
-	 */
-	bool sense_chgcurrs;
-	/*!
-	 * BP turn on
-	 */
-	bool sense_bpons;
-	/*!
-	 * Low bat detect
-	 */
-	bool sense_lobatls;
-	/*!
-	 * Low bat warning
-	 */
-	bool sense_lobaths;
-	/*!
-	 * USB 4V4
-	 */
-	bool sense_usb4v4s;
-	/*!
-	 * USB 2V0
-	 */
-	bool sense_usb2v0s;
-	/*!
-	 * USB 0V8
-	 */
-	bool sense_usb0v8s;
-	/*!
-	 * ID Floats
-	 */
-	bool sense_id_floats;
-	/*!
-	 * ID Gnds
-	 */
-	bool sense_id_gnds;
-	/*!
-	 * Single ended
-	 */
-	bool sense_se1s;
-	/*!
-	 * Car-kit detect
-	 */
-	bool sense_ckdets;
-	/*!
-	 * mic bias detect
-	 */
-	bool sense_mc2bs;
-	/*!
-	 * headset attached
-	 */
-	bool sense_hsdets;
-	/*!
-	 * ST headset attached
-	 */
-	bool sense_hsls;
-	/*!
-	 * Thermal shutdown ALSP
-	 */
-	bool sense_alspths;
-	/*!
-	 * short circuit on AHS
-	 */
-	bool sense_ahsshorts;
-	/*!
-	 * ON1B pin is hight
-	 */
-	bool sense_onofd1s;
-	/*!
-	 * ON2B pin is hight
-	 */
-	bool sense_onofd2s;
-	/*!
-	 * ON3B pin is hight
-	 */
-	bool sense_onofd3s;
-	/*!
-	 * System reset power ready
-	 */
-	bool sense_pwrrdys;
-	/*!
-	 * Thermal warning higher threshold
-	 */
-	bool sense_thwarnhs;
-	/*!
-	 * Thermal warning lower threshold
-	 */
-	bool sense_thwarnls;
-	/*!
-	 * Clock source is XTAL
-	 */
-	bool sense_clks;
-} t_sensor_bits;
-
-#endif				/*CONFIG_MXC_PMIC_MC13783 */
-
-#if defined(CONFIG_MXC_PMIC_MC13892_MODULE) || defined(CONFIG_MXC_PMIC_MC13892)
-enum {
-	REG_INT_STATUS0 = 0,
-	REG_INT_MASK0,
-	REG_INT_SENSE0,
-	REG_INT_STATUS1,
-	REG_INT_MASK1,
-	REG_INT_SENSE1,
-	REG_PU_MODE_S,
-	REG_IDENTIFICATION,
-	REG_UNUSED0,
-	REG_ACC0,
-	REG_ACC1,		/*10 */
-	REG_UNUSED1,
-	REG_UNUSED2,
-	REG_POWER_CTL0,
-	REG_POWER_CTL1,
-	REG_POWER_CTL2,
-	REG_REGEN_ASSIGN,
-	REG_UNUSED3,
-	REG_MEM_A,
-	REG_MEM_B,
-	REG_RTC_TIME,		/*20 */
-	REG_RTC_ALARM,
-	REG_RTC_DAY,
-	REG_RTC_DAY_ALARM,
-	REG_SW_0,
-	REG_SW_1,
-	REG_SW_2,
-	REG_SW_3,
-	REG_SW_4,
-	REG_SW_5,
-	REG_SETTING_0,		/*30 */
-	REG_SETTING_1,
-	REG_MODE_0,
-	REG_MODE_1,
-	REG_POWER_MISC,
-	REG_UNUSED4,
-	REG_UNUSED5,
-	REG_UNUSED6,
-	REG_UNUSED7,
-	REG_UNUSED8,
-	REG_UNUSED9,		/*40 */
-	REG_UNUSED10,
-	REG_UNUSED11,
-	REG_ADC0,
-	REG_ADC1,
-	REG_ADC2,
-	REG_ADC3,
-	REG_ADC4,
-	REG_CHARGE,
-	REG_USB0,
-	REG_USB1,		/*50 */
-	REG_LED_CTL0,
-	REG_LED_CTL1,
-	REG_LED_CTL2,
-	REG_LED_CTL3,
-	REG_UNUSED12,
-	REG_UNUSED13,
-	REG_TRIM0,
-	REG_TRIM1,
-	REG_TEST0,
-	REG_TEST1,		/*60 */
-	REG_TEST2,
-	REG_TEST3,
-	REG_TEST4,
-};
-
-typedef enum {
-	EVENT_ADCDONEI = 0,
-	EVENT_ADCBISDONEI = 1,
-	EVENT_TSI = 2,
-	EVENT_VBUSVI = 3,
-	EVENT_IDFACI = 4,
-	EVENT_USBOVI = 5,
-	EVENT_CHGDETI = 6,
-	EVENT_CHGFAULTI = 7,
-	EVENT_CHGREVI = 8,
-	EVENT_CHGRSHORTI = 9,
-	EVENT_CCCVI = 10,
-	EVENT_CHGCURRI = 11,
-	EVENT_BPONI = 12,
-	EVENT_LOBATLI = 13,
-	EVENT_LOBATHI = 14,
-	EVENT_IDFLOATI = 19,
-	EVENT_IDGNDI = 20,
-	EVENT_SE1I = 21,
-	EVENT_CKDETI = 22,
-	EVENT_1HZI = 24,
-	EVENT_TODAI = 25,
-	EVENT_PWRONI = 27,
-	EVENT_WDIRESETI = 29,
-	EVENT_SYSRSTI = 30,
-	EVENT_RTCRSTI = 31,
-	EVENT_PCI = 32,
-	EVENT_WARMI = 33,
-	EVENT_MEMHLDI = 34,
-	EVENT_THWARNLI = 36,
-	EVENT_THWARNHI = 37,
-	EVENT_CLKI = 38,
-	EVENT_SCPI = 40,
-	EVENT_LBPI = 44,
-	EVENT_NB,
-} type_event;
-
-typedef enum {
-	SENSE_VBUSVS = 3,
-	SENSE_IDFACS = 4,
-	SENSE_USBOVS = 5,
-	SENSE_CHGDETS = 6,
-	SENSE_CHGREVS = 8,
-	SENSE_CHGRSHORTS = 9,
-	SENSE_CCCVS = 10,
-	SENSE_CHGCURRS = 11,
-	SENSE_BPONS = 12,
-	SENSE_LOBATLS = 13,
-	SENSE_LOBATHS = 14,
-	SENSE_IDFLOATS = 19,
-	SENSE_IDGNDS = 20,
-	SENSE_SE1S = 21,
-	SENSE_PWRONS = 27,
-	SENSE_THWARNLS = 36,
-	SENSE_THWARNHS = 37,
-	SENSE_CLKS = 38,
-	SENSE_LBPS = 44,
-	SENSE_NB,
-} t_sensor;
-
-typedef struct {
-	bool sense_vbusvs;
-	bool sense_idfacs;
-	bool sense_usbovs;
-	bool sense_chgdets;
-	bool sense_chgrevs;
-	bool sense_chgrshorts;
-	bool sense_cccvs;
-	bool sense_chgcurrs;
-	bool sense_bpons;
-	bool sense_lobatls;
-	bool sense_lobaths;
-	bool sense_idfloats;
-	bool sense_idgnds;
-	bool sense_se1s;
-	bool sense_pwrons;
-	bool sense_thwarnls;
-	bool sense_thwarnhs;
-	bool sense_clks;
-	bool sense_lbps;
-} t_sensor_bits;
-
-extern struct i2c_client *mc13892_client;
-int pmic_i2c_24bit_read(struct i2c_client *client, unsigned int reg_num,
-			unsigned int *value);
-int pmic_read(int reg_num, unsigned int *reg_val);
-int pmic_write(int reg_num, const unsigned int reg_val);
-void gpio_pmic_active(void);
-void pmic_event_list_init(void);
-void mc13892_power_off(void);
-
-#endif
-
-#if defined(CONFIG_MXC_PMIC_MC34704_MODULE) || defined(CONFIG_MXC_PMIC_MC34704)
-
-typedef enum {
-	/* register names for mc34704 */
-	REG_MC34704_GENERAL1 = 0x01,
-	REG_MC34704_GENERAL2 = 0x02,
-	REG_MC34704_GENERAL3 = 0x03,
-	REG_MC34704_VGSET1 = 0x04,
-	REG_MC34704_VGSET2 = 0x05,
-	REG_MC34704_REG2SET1 = 0x06,
-	REG_MC34704_REG2SET2 = 0x07,
-	REG_MC34704_REG3SET1 = 0x08,
-	REG_MC34704_REG3SET2 = 0x09,
-	REG_MC34704_REG4SET1 = 0x0A,
-	REG_MC34704_REG4SET2 = 0x0B,
-	REG_MC34704_REG5SET1 = 0x0C,
-	REG_MC34704_REG5SET2 = 0x0D,
-	REG_MC34704_REG5SET3 = 0x0E,
-	REG_MC34704_REG6SET1 = 0x0F,
-	REG_MC34704_REG6SET2 = 0x10,
-	REG_MC34704_REG6SET3 = 0x11,
-	REG_MC34704_REG7SET1 = 0x12,
-	REG_MC34704_REG7SET2 = 0x13,
-	REG_MC34704_REG7SET3 = 0x14,
-	REG_MC34704_REG8SET1 = 0x15,
-	REG_MC34704_REG8SET2 = 0x16,
-	REG_MC34704_REG8SET3 = 0x17,
-	REG_MC34704_FAULTS = 0x18,
-	REG_MC34704_I2CSET1 = 0x19,
-	REG_MC34704_REG3DAC = 0x49,
-	REG_MC34704_REG7CR0 = 0x58,
-	REG_MC34704_REG7DAC = 0x59,
-	REG_NB = 0x60,
-} pmic_reg;
-
-typedef enum {
-	/* events for mc34704 */
-	EVENT_FLT1 = 0,
-	EVENT_FLT2,
-	EVENT_FLT3,
-	EVENT_FLT4,
-	EVENT_FLT5,
-	EVENT_FLT6,
-	EVENT_FLT7,
-	EVENT_FLT8,
-	EVENT_NB,
-} type_event;
-
-typedef enum {
-	MCU_SENSOR_NOT_SUPPORT
-} t_sensor;
-
-typedef enum {
-	MCU_SENSOR_BIT_NOT_SUPPORT
-} t_sensor_bits;
-
-#endif				/* MXC_PMIC_MC34704 */
-
-/* EXPORTED FUNCTIONS */
-#ifdef __KERNEL__
-
-#if defined(CONFIG_MXC_PMIC)
-/*!
- * This function is used to determine the PMIC type and its revision.
- *
- * @return      Returns the PMIC type and its revision.
- */
-pmic_version_t pmic_get_version(void);
-
-/*!
- * This function is called by PMIC clients to read a register on PMIC.
- *
- * @param        priority   priority of access
- * @param        reg        number of register
- * @param        reg_value   return value of register
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_read_reg(int reg, unsigned int *reg_value,
-			  unsigned int reg_mask);
-/*!
- * This function is called by PMIC clients to write a register on MC13783.
- *
- * @param        priority   priority of access
- * @param        reg        number of register
- * @param        reg_value  New value of register
- * @param        reg_mask   Bitmap mask indicating which bits to modify
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_write_reg(int reg, unsigned int reg_value,
-			   unsigned int reg_mask);
-
-/*!
- * This function is called by PMIC clients to subscribe on an event.
- *
- * @param        event_sub   structure of event, it contains type of event and callback
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_event_subscribe(type_event event,
-				 pmic_event_callback_t callback);
-/*!
-* This function is called by PMIC clients to un-subscribe on an event.
-*
-* @param        event_unsub   structure of event, it contains type of event and callback
-*
-* @return       This function returns PMIC_SUCCESS if successful.
-*/
-PMIC_STATUS pmic_event_unsubscribe(type_event event,
-				   pmic_event_callback_t callback);
-PMIC_STATUS pmic_event_unsubscribe(type_event event,
-				   pmic_event_callback_t callback);
-/*!
-* This function is called to read all sensor bits of PMIC.
-*
-* @param        sensor    Sensor to be checked.
-*
-* @return       This function returns true if the sensor bit is high;
-*               or returns false if the sensor bit is low.
-*/
-bool pmic_check_sensor(t_sensor sensor);
-
-/*!
-* This function checks one sensor of PMIC.
-*
-* @param        sensor_bits  structure of all sensor bits.
-*
-* @return       This function returns PMIC_SUCCESS if successful.
-*/
-PMIC_STATUS pmic_get_sensors(t_sensor_bits * sensor_bits);
-
-void pmic_event_callback(type_event event);
-void pmic_event_list_init(void);
-
-#ifdef CONFIG_REGULATOR_MC13783
-/*!
- * This function is used to initialize the regulator for MC13783.
- *
- * @return      Returns 0.
- */
-int reg_mc13783_probe(void);
-#else
-static inline int reg_mc13783_probe(void)
-{
-	return 0;
-};
-#endif
-
-#ifdef CONFIG_REGULATOR_MC13892
-int reg_mc13892_probe(void);
-#else
-static inline int reg_mc13892_probe(void)
-{
-	return 0;
-};
-#endif
-
-#ifdef CONFIG_REGULATOR_MC34704
-int reg_mc34704_probe(void);
-#endif
-#endif				/*CONFIG_MXC_PMIC*/
-#endif				/* __KERNEL__ */
-/* CONFIG_MXC_PMIC_MC13783 || CONFIG_MXC_PMIC_MC9SDZ60 */
-
-#endif				/* __ASM_ARCH_MXC_PMIC_EXTERNAL_H__ */
diff --git a/include/asm-arm/arch-mxc/pmic_light.h b/include/asm-arm/arch-mxc/pmic_light.h
deleted file mode 100644
index 8eac46b..0000000
--- a/include/asm-arm/arch-mxc/pmic_light.h
+++ /dev/null
@@ -1,1082 +0,0 @@
-/*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU Lesser General
- * Public License.  You may obtain a copy of the GNU Lesser General
- * Public License Version 2.1 or later at the following locations:
- *
- * http://www.opensource.org/licenses/lgpl-license.html
- * http://www.gnu.org/copyleft/lgpl.html
- */
-#ifndef __ASM_ARCH_MXC_PMIC_LIGHT_H__
-#define __ASM_ARCH_MXC_PMIC_LIGHT_H__
-
-/*!
- * @defgroup PMIC_LIGHT PMIC Light Driver
- * @ingroup PMIC_DRVRS
- */
-
-/*!
- * @file arch-mxc/pmic_light.h
- * @brief This is the header of PMIC Light driver.
- *
- * @ingroup PMIC_LIGHT
- */
-
-#include <asm/ioctl.h>
-#include <asm/arch/pmic_status.h>
-#include <asm/arch/pmic_external.h>
-
-/*!
- * @name IOCTL user space interface
- */
-
-/*! @{ */
-/*!
- * Enable Backlight.
- * Argument type: none.
- */
-#define PMIC_BKLIT_ENABLE                   _IO('p', 0xe0)
-/*!
- * Disable Backlight.
- * Argument type: none.
- */
-#define PMIC_BKLIT_DISABLE                  _IO('p', 0xe1)
-/*!
- * Set backlight configuration.
- * Argument type: pointer to t_bklit_setting_param
- */
-#define PMIC_SET_BKLIT                      _IOW('p', 0xe2, int)
-/*!
- * Get backlight configuration.
- * Argument type: pointer to t_bklit_setting_param
- */
-#define PMIC_GET_BKLIT                      _IOWR('p', 0xe3, int)
-/*!
- * Ramp up configuration.
- * Argument type: t_bklit_channel
- */
-#define PMIC_RAMPUP_BKLIT                   _IOW('p', 0xe4, int)
-/*!
- * Ramp down configuration.
- * Argument type: t_bklit_channel
- */
-#define PMIC_RAMPDOWN_BKLIT                 _IOW('p', 0xe5, int)
-/*!
- * Enable Tri-color LED.
- * Argument type: t_tcled_enable_param
- */
-#define PMIC_TCLED_ENABLE                   _IOW('p', 0xe6, int)
-/*!
- * Disable Tri-color LED.
- * Argument type: t_funlight_bank
- */
-#define PMIC_TCLED_DISABLE                  _IOW('p', 0xe7, int)
-/*!
- * Start Tri-color LED pattern.
- * Argument type: t_fun_param
- */
-#define PMIC_TCLED_PATTERN                  _IOW('p', 0xe8, int)
-/*!
- * Enable Backlight & tcled.
- * Argument type: none.
- */
-#define PMIC_BKLIT_TCLED_ENABLE             _IO('p', 0xe9)
-/*!
- * Disable Backlight & tcled.
- * Argument type: none.
- */
-#define PMIC_BKLIT_TCLED_DISABLE            _IO('p', 0xea)
-/*!
- * Reset ramp up configuration.
- * Argument type: t_bklit_channel
- */
-#define PMIC_OFF_RAMPUP_BKLIT               _IOW('p', 0xeb, int)
-/*!
- * Reset ramp down configuration.
- * Argument type: t_bklit_channel
- */
-#define PMIC_OFF_RAMPDOWN_BKLIT             _IOW('p', 0xec, int)
-/*!
- * Set tcled ind configuration.
- * Argument type: t_tcled_ind_param
- */
-#define PMIC_SET_TCLED			    _IOW('p', 0xed, int)
-/*!
- * Get tcled ind configuration.
- * Argument type: t_tcled_ind_param
- */
-#define PMIC_GET_TCLED			    _IOWR('p', 0xee, int)
-/*! @} */
-/*!
- * @enum t_bklit_mode
- * @brief Backlight modes.
- */
-typedef enum {
-	BACKLIGHT_CURRENT_CTRL_MODE,	/*! < Current control mode */
-	BACKLIGHT_TRIODE_MODE	/*! < Triode mode */
-} t_bklit_mode;
-
-/*!
- * @enum t_bklit_channel
- * @brief Backlight channels.
- */
-typedef enum {
-	BACKLIGHT_LED1,		/*! < Backlight channel 1 */
-	BACKLIGHT_LED2,		/*! < Backlight channel 2 */
-	BACKLIGHT_LED3		/*! < Backlight channel 3 */
-} t_bklit_channel;
-
-/*!
- * @enum t_bklit_strobe_mode
- * @brief Backlight Strobe Light Pulsing modes.
- */
-typedef enum {
-	/*!
-	 * No Strobe Light Pulsing
-	 */
-	BACKLIGHT_STROBE_NONE,
-	/*!
-	 * Strobe Light Pulsing at 3.3% duty cycle over 300msec (Driver goes
-	 * into Triode Mode with pulses constrained to 10msec.)
-	 */
-	BACKLIGHT_STROBE_FAST,
-	/*!
-	 * Strobe Light Pulsing at 10% duty cycle over 100msec (Driver goes
-	 * into Triode Mode with pulses constrained to 10msec.)
-	 */
-	BACKLIGHT_STROBE_SLOW
-} t_bklit_strobe_mode;
-
-/*!
- * @struct t_bklit_setting_param
- * @brief Backlight setting.
- */
-
-typedef struct {
-	t_bklit_channel channel;	/*!< Channel */
-	t_bklit_mode mode;	/*!< Mode */
-	t_bklit_strobe_mode strobe;	/*!< Strobe mode */
-	unsigned char current_level;	/*!< Current level */
-	unsigned char duty_cycle;	/*!< Duty cycle */
-	unsigned char cycle_time;	/*!< Cycle time */
-	bool edge_slow;		/*!< Edge Slow */
-	bool en_dis;		/*!< Enable disable boost mode */
-	unsigned int abms;	/*!< Adaptive boost
-				 *   mode selection */
-	unsigned int abr;	/*!< Adaptive
-				 *   boost reference */
-} t_bklit_setting_param;
-
-/*!
- * @enum t_funlight_bank
- * @brief Tri-color LED fun light banks.
- */
-typedef enum {
-	TCLED_FUN_BANK1 = 0,	/*! < Fun light bank 1 */
-	TCLED_FUN_BANK2,	/*! < Fun light bank 2 */
-	TCLED_FUN_BANK3		/*! < Fun light bank 3 */
-} t_funlight_bank;
-
-/*!
- * @enum t_tcled_mode
- * @brief Tri-color LED operation modes.
- *
- * The Tri-Color LED Driver circuitry includes 2 modes of operation. In LED
- * Indicator Mode, this circuitry operates as Red and Green LED Drivers with
- * flasher timing to indicate GSM network status. In Fun Light Mode, this
- * circuitry provides expanded capability for current control and distribution
- * that supplements the three channels.
- */
-typedef enum {
-	TCLED_IND_MODE = 0,	/*! < LED Indicator Mode */
-	TCLED_FUN_MODE		/*! < Fun Light Mode */
-} t_tcled_mode;
-
-/*!
- * @struct t_tcled_enable_param
- * @brief enable setting.
- */
-typedef struct {
-	t_funlight_bank bank;	/*!< Bank */
-	t_tcled_mode mode;	/*!< Mode */
-} t_tcled_enable_param;
-
-/*!
- * @enum t_ind_channel
- * @brief Tri-color LED indicator mode channels.
- *
- */
-
-typedef enum {
-	TCLED_IND_RED = 0,	/*! < Red LED */
-	TCLED_IND_GREEN,	/*! < Green LED */
-	TCLED_IND_BLUE		/*! < Blue LED */
-} t_ind_channel;
-
-/*!
- * @enum t_funlight_channel
- * @brief Tri-color LED fun light mode channels.
- *
- */
-typedef enum {
-	TCLED_FUN_CHANNEL1 = 0,	/*! < Fun light channel 1 (Red) */
-	TCLED_FUN_CHANNEL2,	/*! < Fun light channel 2 (Green) */
-	TCLED_FUN_CHANNEL3	/*! < Fun light channel 3 (Blue) */
-} t_funlight_channel;
-
-/*!
- * @enum t_tcled_ind_blink_pattern
- * @brief Tri-color LED Indicator Mode blinking mode.
- */
-typedef enum {
-	TCLED_IND_OFF = 0,	/*! < Continuous off */
-	TCLED_IND_BLINK_1,	/*! < 1 / 31 */
-	TCLED_IND_BLINK_2,	/*! < 2 / 31 */
-	TCLED_IND_BLINK_3,	/*! < 3 / 31  */
-	TCLED_IND_BLINK_4,	/*! < 4 / 31  */
-	TCLED_IND_BLINK_5,	/*! < 5 / 31  */
-	TCLED_IND_BLINK_6,	/*! < 6 / 31  */
-	TCLED_IND_BLINK_7,	/*! < 7 / 31  */
-	TCLED_IND_BLINK_8,	/*! < 8 / 31  */
-	TCLED_IND_BLINK_9,	/*! < 9 / 31  */
-	TCLED_IND_BLINK_10,	/*! < 10 / 31  */
-	TCLED_IND_BLINK_11,	/*! < 11 / 31  */
-	TCLED_IND_BLINK_12,	/*! < 12 / 31  */
-	TCLED_IND_BLINK_13,	/*! < 13 / 31  */
-	TCLED_IND_BLINK_14,	/*! < 14 / 31  */
-	TCLED_IND_BLINK_15,	/*! < 15 / 31  */
-	TCLED_IND_BLINK_16,	/*! < 16 / 31  */
-	TCLED_IND_BLINK_17,	/*! < 17 / 31  */
-	TCLED_IND_BLINK_18,	/*! < 18 / 31  */
-	TCLED_IND_BLINK_19,	/*! < 19 / 31  */
-	TCLED_IND_BLINK_20,	/*! < 20 / 31  */
-	TCLED_IND_BLINK_21,	/*! < 21 / 31  */
-	TCLED_IND_BLINK_22,	/*! < 22 / 31  */
-	TCLED_IND_BLINK_23,	/*! < 23 / 31  */
-	TCLED_IND_BLINK_24,	/*! < 24 / 31  */
-	TCLED_IND_BLINK_25,	/*! < 25 / 31  */
-	TCLED_IND_BLINK_26,	/*! < 26 / 31  */
-	TCLED_IND_BLINK_27,	/*! < 27 / 31  */
-	TCLED_IND_BLINK_28,	/*! < 28 / 31  */
-	TCLED_IND_BLINK_29,	/*! < 29 / 31  */
-	TCLED_IND_BLINK_30,	/*! < 30 / 31  */
-	TCLED_IND_ON		/*! < Continuous on */
-} t_tcled_ind_blink_pattern;
-
-/*!
- * @enum t_tcled_cur_level
- * @brief Tri-color LED current levels.
- */
-typedef enum {
-	TCLED_CUR_LEVEL_1 = 0,	/*! < Tri-Color LED current level 1 */
-	TCLED_CUR_LEVEL_2,	/*! < Tri-Color LED current level 2 */
-	TCLED_CUR_LEVEL_3,	/*! < Tri-Color LED current level 3 */
-	TCLED_CUR_LEVEL_4	/*! < Tri-Color LED current level 4 */
-} t_tcled_cur_level;
-
-/*!
- * @enum t_tcled_fun_cycle_time
- * @brief Tri-color LED fun light mode cycle time.
- */
-typedef enum {
-	TC_CYCLE_TIME_1 = 0,	/*! < Tri-Color LED cycle time 1 */
-	TC_CYCLE_TIME_2,	/*! < Tri-Color LED cycle time 2 */
-	TC_CYCLE_TIME_3,	/*! < Tri-Color LED cycle time 3 */
-	TC_CYCLE_TIME_4		/*! < Tri-Color LED cycle time 4 */
-} t_tcled_fun_cycle_time;
-
-/*!
- * @enum t_tcled_fun_speed
- * @brief Tri-color LED fun light mode pattern speed.
- */
-typedef enum {
-	TC_OFF = 0,		/*! < Tri-Color pattern off */
-	TC_SLOW,		/*! < Tri-Color slow pattern */
-	TC_FAST			/*! < Tri-Color fast pattern */
-} t_tcled_fun_speed;
-
-/*!
- * @enum t_tcled_fun_speed
- * @brief Tri-color LED fun light mode pattern speed.
- */
-typedef enum {
-	TC_STROBE_OFF = 0,	/*! < No strobe */
-	TC_STROBE_SLOW,		/*! < Slow strobe pattern */
-	TC_STROBE_FAST		/*! < fast strobe pattern */
-} t_tcled_fun_strobe_speed;
-
-/*!
- * @enum t_chaselight_pattern
- * @brief Tri-color LED fun light mode chasing light patterns.
- */
-typedef enum {
-	PMIC_RGB = 0,		/*!< R -> G -> B */
-	BGR			/*!< B -> G -> R */
-} t_chaselight_pattern;
-
-/*!
- * This enumeration of Fun Light Pattern.
- */
-typedef enum {
-	/*!
-	 * Blended ramps slow
-	 */
-	BLENDED_RAMPS_SLOW,
-	/*!
-	 * Blended ramps fast
-	 */
-	BLENDED_RAMPS_FAST,
-	/*!
-	 * Saw ramps slow
-	 */
-	SAW_RAMPS_SLOW,
-	/*!
-	 * Saw ramps fast
-	 */
-	SAW_RAMPS_FAST,
-	/*!
-	 * Blended bowtie slow
-	 */
-	BLENDED_BOWTIE_SLOW,
-	/*!
-	 * Blended bowtie fast
-	 */
-	BLENDED_BOWTIE_FAST,
-	/*!
-	 * Strobe slow
-	 */
-	STROBE_SLOW,
-	/*!
-	 * Strobe fast
-	 */
-	STROBE_FAST,
-	/*!
-	 * Chasing Light RGB Slow
-	 */
-	CHASING_LIGHT_RGB_SLOW,
-	/*!
-	 * Chasing Light RGB fast
-	 */
-	CHASING_LIGHT_RGB_FAST,
-	/*!
-	 * Chasing Light BGR Slow
-	 */
-	CHASING_LIGHT_BGR_SLOW,
-	/*!
-	 * Chasing Light BGR fast
-	 */
-	CHASING_LIGHT_BGR_FAST,
-} t_fun_pattern;
-
-/*!
- * @struct t_fun_param
- * @brief LED fun pattern IOCTL parameter
- */
-typedef struct {
-	t_funlight_bank bank;	/*!< TCLED bank */
-	t_funlight_channel channel;	/*!< TCLED channel */
-	t_fun_pattern pattern;	/*!< Fun pattern */
-} t_fun_param;
-
-/*!
- * @enum t_led_channel
- * @brief LED channels including backlight and tri-color LEDs.
- */
-typedef enum {
-	AUDIO_LED1,		/*! < Backlight channel 1 */
-	AUDIO_LED2,		/*! < Backlight channel 2 */
-	AUDIO_LEDR,		/*! < Fun light channel 1 (Red) */
-	AUDIO_LEDG,		/*! < Fun light channel 2 (Green) */
-	AUDIO_LEDB		/*! < Fun light channel 3 (Blue) */
-} t_led_channel;
-
-/*!
- * @enum t_aud_path
- * @brief LED audio modulation in-out audio channels
- */
-typedef enum {
-	MIXED_RX = 0,		/*!<  Mixed L & R Channel RX audio */
-	TX			/*!<  TX path */
-} t_aud_path;
-
-/*!
- * @enum t_aud_gain
- * @brief LED audio modulation in-out audio channels
- */
-typedef enum {
-	GAIN_MINUS6DB = 0,	/*!< -6 dB */
-	GAIN_0DB,		/*!< 0 dB */
-	GAIN_6DB,		/*!< 6 dB */
-	GAIN_12DB		/*!< 12 dB */
-} t_aud_gain;
-
-/*!
- * @struct t_tcled_ind_param
- * @brief LED parameter
- */
-typedef struct {
-	t_funlight_bank bank;	/*! < tcled bank */
-	t_ind_channel channel;	/*! < tcled channel */
-	t_tcled_cur_level level;	/*! < tcled current level */
-	t_tcled_ind_blink_pattern pattern;	/*! < tcled dutty cycle */
-	bool skip;		/*! < tcled skip */
-	bool rampup;		/*! < tcled rampup */
-	bool rampdown;		/*! < tcled rampdown */
-	bool half_current;	/*! < tcled half current */
-} t_tcled_ind_param;
-
-#if defined(CONFIG_MXC_PMIC_MC13892)
-
-enum curr_level {
-	LIT_CURR_0 = 0,
-	LIT_CURR_3,
-	LIT_CURR_6,
-	LIT_CURR_9,
-	LIT_CURR_12,
-	LIT_CURR_15,
-	LIT_CURR_18,
-	LIT_CURR_21,
-	/* below setting only used for main/aux/keypad */
-	LIT_CURR_HI_0,
-	LIT_CURR_HI_6,
-	LIT_CURR_HI_12,
-	LIT_CURR_HI_18,
-	LIT_CURR_HI_24,
-	LIT_CURR_HI_30,
-	LIT_CURR_HI_36,
-	LIT_CURR_HI_42,
-};
-
-enum lit_channel {
-	LIT_MAIN = 0,
-	LIT_AUX,
-	LIT_KEY,
-	LIT_RED,
-	LIT_GREEN,
-	LIT_BLUE,
-};
-
-#endif
-
-/* EXPORTED FUNCTIONS */
-#ifdef __KERNEL__
-/*!
- * This function enables backlight & tcled.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_bklit_tcled_master_enable(void);
-
-/*!
- * This function disables backlight & tcled.
- *
- * @return       This function returns PMIC_SUCCESS if successful
- */
-PMIC_STATUS pmic_bklit_tcled_master_disable(void);
-
-/*!
- * This function enables backlight.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_bklit_master_enable(void);
-
-/*!
- * This function disables backlight.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_bklit_master_disable(void);
-
-/*!
- * This function sets backlight current level.
- *
- * @param        channel   Backlight channel
- * @param        level     Backlight current level, as the following table.
- *                         @verbatim
-                               level     current
-                               ------    -----------
-                                 0         0 mA
-                                 1         12 mA
-                                 2         24 mA
-                                 3         36 mA
-                                 4         48 mA
-                                 5         60 mA
-                                 6         72 mA
-                                 7         84 mA
-                            @endverbatim
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_bklit_set_current(t_bklit_channel channel,
-				   unsigned char level);
-
-/*!
- * This function retrives backlight current level.
- *
- * @param        channel   Backlight channel
- * @param        level     Pointer to store backlight current level result.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_bklit_get_current(t_bklit_channel channel,
-				   unsigned char *level);
-
-/*!
- * This function sets a backlight channel duty cycle.
- * LED perceived brightness for each zone may be individually set by setting
- * duty cycle. The default setting is for 0% duty cycle; this keeps all zone
- * drivers turned off even after the master enable command. Each LED current
- * sink can be turned on and adjusted for brightness with an independent 4 bit
- * word for a duty cycle ranging from 0% to 100% in approximately 6.7% steps.
- *
- * @param        channel   Backlight channel.
- * @param        dc        Backlight duty cycle, as the following table.
- *                         @verbatim
-                                dc        Duty Cycle (% On-time over Cycle Time)
-                               ------    ---------------------------------------
-                                  0        0%
-                                  1        6.7%
-                                  2        13.3%
-                                  3        20%
-                                  4        26.7%
-                                  5        33.3%
-                                  6        40%
-                                  7        46.7%
-                                  8        53.3%
-                                  9        60%
-                                 10        66.7%
-                                 11        73.3%
-                                 12        80%
-                                 13        86.7%
-                                 14        93.3%
-                                 15        100%
-                             @endverbatim
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_bklit_set_dutycycle(t_bklit_channel channel, unsigned char dc);
-
-/*!
- * This function retrives a backlight channel duty cycle.
- *
- * @param        channel   Backlight channel.
- * @param        cycle     Pointer to backlight duty cycle.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_bklit_get_dutycycle(t_bklit_channel channel,
-				     unsigned char *dc);
-
-/*!
- * This function sets a backlight channel cycle time.
- * Cycle Time is defined as the period of a complete cycle of
- * Time_on + Time_off. The default Cycle Time is set to 0.01 seconds such that
- * the 100 Hz on-off cycling is averaged out by the eye to eliminate
- * flickering. Additionally, the Cycle Time can be programmed to intentionally
- * extend the period of on-off cycles for a visual pulsating or blinking effect.
- *
- * @param        period    Backlight cycle time, as the following table.
- *                         @verbatim
-                                period      Cycle Time
-                               --------    ------------
-                                  0          0.01 seconds
-                                  1          0.1 seconds
-                                  2          0.5 seconds
-                                  3          2 seconds
-                             @endverbatim
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_bklit_set_cycle_time(unsigned char period);
-
-/*!
- * This function retrives a backlight channel cycle time setting.
- *
- * @param        period    Pointer to save backlight cycle time setting result.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_bklit_get_cycle_time(unsigned char *period);
-
-/*!
- * This function sets backlight operation mode. There are two modes of
- * operations: current control and triode mode.
- * The Duty Cycle/Cycle Time control is retained in Triode Mode. Audio
- * coupling is not available in Triode Mode.
- *
- * @param        channel   Backlight channel.
- * @param        mode      Backlight operation mode.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_bklit_set_mode(t_bklit_channel channel, t_bklit_mode mode);
-/*!
- * This function gets backlight operation mode. There are two modes of
- * operations: current control and triode mode.
- * The Duty Cycle/Cycle Time control is retained in Triode Mode. Audio
- * coupling is not available in Triode Mode.
- *
- * @param        channel   Backlight channel.
- * @param        mode      Backlight operation mode.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_bklit_get_mode(t_bklit_channel channel, t_bklit_mode * mode);
-/*!
- * This function starts backlight brightness ramp up function; ramp time is
- * fixed at 0.5 seconds.
- *
- * @param        channel   Backlight channel.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_bklit_rampup(t_bklit_channel channel);
-/*!
- * This function stops backlight brightness ramp up function;
- *
- * @param        channel   Backlight channel.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_bklit_off_rampup(t_bklit_channel channel);
-/*!
- * This function starts backlight brightness ramp down function; ramp time is
- * fixed at 0.5 seconds.
- *
- * @param        channel   Backlight channel.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_bklit_rampdown(t_bklit_channel channel);
-/*!
- * This function stops backlight brightness ramp down function.
- *
- * @param        channel   Backlight channel.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_bklit_off_rampdown(t_bklit_channel channel);
-/*!
- * This function enables backlight analog edge slowing mode. Analog Edge
- * Slowing slows down the transient edges to reduce the chance of coupling LED
- * modulation activity into other circuits. Rise and fall times will be targeted
- * for approximately 50usec.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_bklit_enable_edge_slow(void);
-
-/*!
- * This function disables backlight analog edge slowing mode. The backlight
- * drivers will default to an Instant On mode.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_bklit_disable_edge_slow(void);
-/*!
- * This function gets backlight analog edge slowing mode. DThe backlight
- *
- * @param        edge      Edge slowing mode.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_bklit_get_edge_slow(bool * edge);
-/*!
- * This function sets backlight Strobe Light Pulsing mode.
- *
- * @param        channel   Backlight channel.
- * @param        mode      Strobe Light Pulsing mode.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_bklit_set_strobemode(t_bklit_channel channel,
-				      t_bklit_strobe_mode mode);
-
-/*!
- * This function enables tri-color LED.
- *
- * @param        mode      Tri-color LED operation mode.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_tcled_enable(t_tcled_mode mode, t_funlight_bank bank);
-/*!
- * This function disables tri-color LED.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_tcled_disable(t_funlight_bank bank);
-/*!
- * This function retrives tri-color LED operation mode.
- *
- * @param        mode      Pointer to Tri-color LED operation mode.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_tcled_get_mode(t_tcled_mode * mode, t_funlight_bank bank);
-/*!
- * This function sets a tri-color LED channel current level in indicator mode.
- *
- * @param        channel      Tri-color LED channel.
- * @param        level        Current level.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_tcled_ind_set_current(t_ind_channel channel,
-				       t_tcled_cur_level level,
-				       t_funlight_bank bank);
-/*!
- * This function retrives a tri-color LED channel current level in indicator mode.
- *
- * @param        channel      Tri-color LED channel.
- * @param        level        Pointer to current level.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_tcled_ind_get_current(t_ind_channel channel,
-				       t_tcled_cur_level * level,
-				       t_funlight_bank bank);
-/*!
- * This function sets a tri-color LED channel blinking pattern in indication
- * mode.
- *
- * @param        channel      Tri-color LED channel.
- * @param        pattern      Blinking pattern.
- * @param        skip         If true, skip a cycle after each cycle.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-
-PMIC_STATUS pmic_tcled_ind_set_blink_pattern(t_ind_channel channel,
-					     t_tcled_ind_blink_pattern pattern,
-					     bool skip, t_funlight_bank bank);
-/*!
- * This function retrives a tri-color LED channel blinking pattern in
- * indication mode.
- *
- * @param        channel      Tri-color LED channel.
- * @param        pattern      Pointer to Blinking pattern.
- * @param        skip         Pointer to a boolean variable indicating if skip
- *                            a cycle after each cycle.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_tcled_ind_get_blink_pattern(t_ind_channel channel,
-					     t_tcled_ind_blink_pattern *
-					     pattern, bool * skip,
-					     t_funlight_bank bank);
-/*!
- * This function sets a tri-color LED channel current level in Fun Light mode.
- *
- * @param        bank         Tri-color LED bank
- * @param        channel      Tri-color LED channel.
- * @param        level        Current level.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_tcled_fun_set_current(t_funlight_bank bank,
-				       t_funlight_channel channel,
-				       t_tcled_cur_level level);
-
-/*!
- * This function retrives a tri-color LED channel current level
- * in Fun Light mode.
- *
- * @param        bank         Tri-color LED bank
- * @param        channel      Tri-color LED channel.
- * @param        level        Pointer to current level.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_tcled_fun_get_current(t_funlight_bank bank,
-				       t_funlight_channel channel,
-				       t_tcled_cur_level * level);
-
-/*!
- * This function sets tri-color LED cycle time in Fun Light mode.
- *
- * @param        bank         Tri-color LED bank
- * @param        ct           Cycle time.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_tcled_fun_set_cycletime(t_funlight_bank bank,
-					 t_tcled_fun_cycle_time ct);
-
-/*!
- * This function retrives tri-color LED cycle time in Fun Light mode.
- *
- * @param        bank         Tri-color LED bank
- * @param        ct           Pointer to cycle time.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_tcled_fun_get_cycletime(t_funlight_bank bank,
-					 t_tcled_fun_cycle_time * ct);
-
-/*!
- * This function sets a tri-color LED channel duty cycle in Fun Light mode.
- *
- * @param        bank         Tri-color LED bank
- * @param        channel      Tri-color LED channel.
- * @param        dc           Duty cycle.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_tcled_fun_set_dutycycle(t_funlight_bank bank,
-					 t_funlight_channel channel,
-					 unsigned char dc);
-
-/*!
- * This function retrives a tri-color LED channel duty cycle in Fun Light mode.
- *
- * @param        bank         Tri-color LED bank
- * @param        channel      Tri-color LED channel.
- * @param        dc           Pointer to duty cycle.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_tcled_fun_get_dutycycle(t_funlight_bank bank,
-					 t_funlight_channel channel,
-					 unsigned char *dc);
-
-/*!
- * This function initiates Blended Ramp fun light pattern.
- *
- * @param        bank         Tri-color LED bank
- * @param        speed        Speed of pattern.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_tcled_fun_blendedramps(t_funlight_bank bank,
-					t_tcled_fun_speed speed);
-
-/*!
- * This function initiates Saw Ramp fun light pattern.
- *
- * @param        bank         Tri-color LED bank
- * @param        speed        Speed of pattern.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_tcled_fun_sawramps(t_funlight_bank bank,
-				    t_tcled_fun_speed speed);
-
-/*!
- * This function initiates Blended Bowtie fun light pattern.
- *
- * @param        bank         Tri-color LED bank
- * @param        speed        Speed of pattern.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_tcled_fun_blendedbowtie(t_funlight_bank bank,
-					 t_tcled_fun_speed speed);
-
-/*!
- * This function initiates Chasing Lights fun light pattern.
- *
- * @param        bank         Tri-color LED bank
- * @param        pattern      Chasing light pattern mode.
- * @param        speed        Speed of pattern.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_tcled_fun_chasinglightspattern(t_funlight_bank bank,
-						t_chaselight_pattern pattern,
-						t_tcled_fun_speed speed);
-
-/*!
- * This function initiates Strobe Mode fun light pattern.
- *
- * @param        bank         Tri-color LED bank
- * @param        channel      Tri-color LED channel.
- * @param        speed        Speed of pattern.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_tcled_fun_strobe(t_funlight_bank bank,
-				  t_funlight_channel channel,
-				  t_tcled_fun_strobe_speed speed);
-
-/*!
- * This function initiates Tri-color LED brightness Ramp Up function; Ramp time
- * is fixed at 1 second.
- *
- * @param        bank         Tri-color LED bank
- * @param        channel      Tri-color LED channel.
- * @param        rampup       Ramp-up configuration.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_tcled_fun_rampup(t_funlight_bank bank,
-				  t_funlight_channel channel, bool rampup);
-/*!
- * This function gets Tri-color LED brightness Ramp Up function; Ramp time
- * is fixed at 1 second.
- *
- * @param        bank         Tri-color LED bank
- * @param        channel      Tri-color LED channel.
- * @param        rampup       Ramp-up configuration.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_tcled_get_fun_rampup(t_funlight_bank bank,
-				      t_funlight_channel channel,
-				      bool * rampup);
-
-/*!
- * This function initiates Tri-color LED brightness Ramp Down function; Ramp
- * time is fixed at 1 second.
- *
- * @param        bank         Tri-color LED bank
- * @param        channel      Tri-color LED channel.
- * @param        rampdown     Ramp-down configuration.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_tcled_fun_rampdown(t_funlight_bank bank,
-				    t_funlight_channel channel, bool rampdown);
-/*!
- * This function initiates Tri-color LED brightness Ramp Down function; Ramp
- * time is fixed at 1 second.
- *
- * @param        bank         Tri-color LED bank
- * @param        channel      Tri-color LED channel.
- * @param        rampdown     Ramp-down configuration.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_tcled_get_fun_rampdown(t_funlight_bank bank,
-					t_funlight_channel channel,
-					bool * rampdown);
-
-/*!
- * This function enables a Tri-color channel triode mode.
- *
- * @param        bank         Tri-color LED bank
- * @param        channel      Tri-color LED channel.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_tcled_fun_triode_on(t_funlight_bank bank,
-				     t_funlight_channel channel);
-
-/*!
- * This function disables a Tri-color LED channel triode mode.
- *
- * @param        bank         Tri-color LED bank
- * @param        channel      Tri-color LED channel.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_tcled_fun_triode_off(t_funlight_bank bank,
-				      t_funlight_channel channel);
-
-/*!
- * This function enables Tri-color LED edge slowing.
- *
- * @return       This function returns PMIC_NOT_SUPPORTED.
- */
-PMIC_STATUS pmic_tcled_enable_edge_slow(void);
-
-/*!
- * This function disables Tri-color LED edge slowing.
- *
- * @return       This function returns PMIC_NOT_SUPPORTED.
- */
-PMIC_STATUS pmic_tcled_disable_edge_slow(void);
-
-/*!
- * This function enables Tri-color LED half current mode.
- *
- * @return       This function returns PMIC_NOT_SUPPORTED.
- */
-PMIC_STATUS pmic_tcled_enable_half_current(void);
-
-/*!
- * This function disables Tri-color LED half current mode.
- *
- * @return       This function returns PMIC_NOT_SUPPORTED.
- */
-PMIC_STATUS pmic_tcled_disable_half_current(void);
-
-/*!
- * This function enables backlight or Tri-color LED audio modulation.
- *
- * @return       This function returns PMIC_NOT_SUPPORTED.
- */
-PMIC_STATUS pmic_tcled_enable_audio_modulation(t_led_channel channel,
-					       t_aud_path path,
-					       t_aud_gain gain,
-					       bool lpf_bypass);
-
-/*!
- * This function disables backlight or Tri-color LED audio modulation.
- *
- * @return       This function returns PMIC_NOT_SUPPORTED.
- */
-PMIC_STATUS pmic_tcled_disable_audio_modulation(void);
-/*!
- * This function enables the boost mode.
- * Only on mc13783 2.0 or higher
- *
- * @param       en_dis   Enable or disable the boost mode
- *
- * @return      This function returns 0 if successful.
- */
-PMIC_STATUS pmic_bklit_set_boost_mode(bool en_dis);
-
-/*!
- * This function gets the boost mode.
- * Only on mc13783 2.0 or higher
- *
- * @param       en_dis   Enable or disable the boost mode
- *
- * @return      This function returns 0 if successful.
- */
-PMIC_STATUS pmic_bklit_get_boost_mode(bool * en_dis);
-
-/*!
- * This function sets boost mode configuration
- * Only on mc13783 2.0 or higher
- *
- * @param    abms      Define adaptive boost mode selection
- * @param    abr       Define adaptive boost reference
- *
- * @return       This function returns 0 if successful.
- */
-PMIC_STATUS pmic_bklit_config_boost_mode(unsigned int abms, unsigned int abr);
-
-/*!
- * This function gets boost mode configuration
- * Only on mc13783 2.0 or higher
- *
- * @param    abms      Define adaptive boost mode selection
- * @param    abr       Define adaptive boost reference
- *
- * @return       This function returns 0 if successful.
- */
-PMIC_STATUS pmic_bklit_gets_boost_mode(unsigned int *abms, unsigned int *abr);
-
-#if defined(CONFIG_MXC_PMIC_MC13892)
-
-PMIC_STATUS mc13892_bklit_set_current(enum lit_channel channel,
-				      unsigned char level);
-PMIC_STATUS mc13892_bklit_get_current(enum lit_channel channel,
-				      unsigned char *level);
-PMIC_STATUS mc13892_bklit_set_dutycycle(enum lit_channel channel,
-					unsigned char dc);
-PMIC_STATUS mc13892_bklit_get_dutycycle(enum lit_channel channel,
-					unsigned char *dc);
-PMIC_STATUS mc13892_bklit_set_ramp(enum lit_channel channel, int flag);
-PMIC_STATUS mc13892_bklit_get_ramp(enum lit_channel channel, int *flag);
-PMIC_STATUS mc13892_bklit_set_blink_p(enum lit_channel channel, int period);
-PMIC_STATUS mc13892_bklit_get_blink_p(enum lit_channel channel, int *period);
-
-#endif
-
-#endif				/* __KERNEL__ */
-
-#endif				/* __ASM_ARCH_MXC_PMIC_LIGHT_H__ */
diff --git a/include/asm-arm/arch-mxc/pmic_power.h b/include/asm-arm/arch-mxc/pmic_power.h
index 26a2b00..60f23ab 100644
--- a/include/asm-arm/arch-mxc/pmic_power.h
+++ b/include/asm-arm/arch-mxc/pmic_power.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -25,9 +25,9 @@
  * @ingroup PMIC_POWER
  */
 
-#include <asm/ioctl.h>
-#include <asm/arch/pmic_status.h>
-#include <asm/arch/pmic_external.h>
+#include <linux/ioctl.h>
+#include <linux/pmic_status.h>
+#include <linux/pmic_external.h>
 
 /*!
  * @name IOCTL user space interface
diff --git a/include/asm-arm/arch-mxc/pmic_rtc.h b/include/asm-arm/arch-mxc/pmic_rtc.h
deleted file mode 100644
index 54942ae..0000000
--- a/include/asm-arm/arch-mxc/pmic_rtc.h
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU Lesser General
- * Public License.  You may obtain a copy of the GNU Lesser General
- * Public License Version 2.1 or later at the following locations:
- *
- * http://www.opensource.org/licenses/lgpl-license.html
- * http://www.gnu.org/copyleft/lgpl.html
- */
-
-#ifndef __ASM_ARCH_MXC_PMIC_RTC_H__
-#define __ASM_ARCH_MXC_PMIC_RTC_H__
-
-/*!
- * @defgroup PMIC_RTC PMIC RTC Driver
- * @ingroup PMIC_DRVRS
- */
-
-/*!
- * @file arch-mxc/pmic_rtc.h
- * @brief This is the header of PMIC RTC driver.
- *
- * @ingroup PMIC_RTC
- */
-
-/*
- * Includes
- */
-#include <asm/ioctl.h>
-#include <asm/arch/pmic_status.h>
-#include <asm/arch/pmic_external.h>
-
-#define         PMIC_RTC_SET_TIME                    _IOWR('p',0xd1, int)
-#define         PMIC_RTC_GET_TIME                    _IOWR('p',0xd2, int)
-#define         PMIC_RTC_SET_ALARM		     _IOWR('p',0xd3, int)
-#define         PMIC_RTC_GET_ALARM		     _IOWR('p',0xd4, int)
-#define         PMIC_RTC_WAIT_ALARM		     _IOWR('p',0xd5, int)
-#define         PMIC_RTC_ALARM_REGISTER              _IOWR('p',0xd6, int)
-#define         PMIC_RTC_ALARM_UNREGISTER            _IOWR('p',0xd7, int)
-
-/*!
- * This enumeration define all RTC interrupt
- */
-typedef enum {
-	/*!
-	 * Time of day alarm
-	 */
-	RTC_IT_ALARM,
-	/*!
-	 * 1 Hz timetick
-	 */
-	RTC_IT_1HZ,
-	/*!
-	 * RTC reset occurred
-	 */
-	RTC_IT_RST,
-} t_rtc_int;
-
-/*
- * RTC PMIC API
- */
-
-/* EXPORTED FUNCTIONS */
-#ifdef __KERNEL__
-
-/*!
- * This function set the real time clock of PMIC
- *
- * @param        pmic_time  	value of date and time
- *
- * @return       This function returns PMIC_STATUS if successful.
- */
-PMIC_STATUS pmic_rtc_set_time(struct timeval *pmic_time);
-
-/*!
- * This function get the real time clock of PMIC
- *
- * @param        pmic_time  	return value of date and time
- *
- * @return       This function returns PMIC_STATUS if successful.
- */
-PMIC_STATUS pmic_rtc_get_time(struct timeval *pmic_time);
-
-/*!
- * This function set the real time clock alarm of PMIC
- *
- * @param        pmic_time  	value of date and time
- *
- * @return       This function returns PMIC_STATUS if successful.
- */
-PMIC_STATUS pmic_rtc_set_time_alarm(struct timeval *pmic_time);
-
-/*!
- * This function get the real time clock alarm of PMIC
- *
- * @param        pmic_time  	return value of date and time
- *
- * @return       This function returns PMIC_STATUS if successful.
- */
-PMIC_STATUS pmic_rtc_get_time_alarm(struct timeval *pmic_time);
-
-/*!
- * This function wait the Alarm event
- *
- * @return       This function returns PMIC_STATUS if successful.
- */
-PMIC_STATUS pmic_rtc_wait_alarm(void);
-
-/*!
- * This function is used to un/subscribe on RTC event IT.
- *
- * @param        event  	type of event.
- * @param        callback  	event callback function.
- * @param        sub      	define if Un/subscribe event.
- *
- * @return       This function returns PMIC_STATUS if successful.
- */
-PMIC_STATUS pmic_rtc_event(t_rtc_int event, void *callback, bool sub);
-
-/*!
- * This function is used to subscribe on RTC event IT.
- *
- * @param        event  	type of event.
- * @param        callback  	event callback function.
- *
- * @return       This function returns PMIC_STATUS if successful.
- */
-PMIC_STATUS pmic_rtc_event_sub(t_rtc_int event, void *callback);
-
-/*!
- * This function is used to un-subscribe on RTC event IT.
- *
- * @param        event  	type of event.
- * @param        callback  	event callback function.
- *
- * @return       This function returns PMIC_STATUS if successful.
- */
-PMIC_STATUS pmic_rtc_event_unsub(t_rtc_int event, void *callback);
-
-/*!
- * This function is used to tell if PMIC RTC has been correctly loaded.
- *
- * @return       This function returns 1 if RTC was successfully loaded
- * 		 0 otherwise.
- */
-int pmic_rtc_loaded(void);
-
-#endif				/* __KERNEL__ */
-
-#endif				/* __ASM_ARCH_MXC_PMIC_RTC_H__ */
diff --git a/include/asm-arm/arch-mxc/pmic_status.h b/include/asm-arm/arch-mxc/pmic_status.h
deleted file mode 100644
index a928729..0000000
--- a/include/asm-arm/arch-mxc/pmic_status.h
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU Lesser General
- * Public License.  You may obtain a copy of the GNU Lesser General
- * Public License Version 2.1 or later at the following locations:
- *
- * http://www.opensource.org/licenses/lgpl-license.html
- * http://www.gnu.org/copyleft/lgpl.html
- */
-#ifndef __ASM_ARCH_MXC_PMIC_STATUS_H__
-#define __ASM_ARCH_MXC_PMIC_STATUS_H__
-#include <asm-generic/errno-base.h>
-#ifdef __KERNEL__
-#include <asm/uaccess.h>	/* copy_{from,to}_user() */
-#endif
-/*!
- * @file arch-mxc/pmic_status.h
- * @brief PMIC APIs return code definition.
- *
- * @ingroup PMIC_CORE
- */
-
-/*!
- * @enum PMIC_STATUS
- * @brief Define return values for all PMIC APIs.
- *
- * These return values are used by all of the PMIC APIs.
- *
- * @ingroup PMIC
- */
-typedef enum {
-	PMIC_SUCCESS = 0,	/*!< The requested operation was successfully
-				   completed.                                     */
-	PMIC_ERROR = -1,	/*!< The requested operation could not be completed
-				   due to an error.                               */
-	PMIC_PARAMETER_ERROR = -2,	/*!< The requested operation failed because
-					   one or more of the parameters was
-					   invalid.                             */
-	PMIC_NOT_SUPPORTED = -3,	/*!< The requested operation could not be
-					   completed because the PMIC hardware
-					   does not support it. */
-	PMIC_SYSTEM_ERROR_EINTR = -EINTR,
-
-	PMIC_MALLOC_ERROR = -5,	/*!< Error in malloc function             */
-	PMIC_UNSUBSCRIBE_ERROR = -6,	/*!< Error in un-subscribe event          */
-	PMIC_EVENT_NOT_SUBSCRIBED = -7,	/*!< Event occur and not subscribed       */
-	PMIC_EVENT_CALL_BACK = -8,	/*!< Error - bad call back                */
-	PMIC_CLIENT_NBOVERFLOW = -9,	/*!< The requested operation could not be
-					   completed because there are too many
-					   PMIC client requests */
-} PMIC_STATUS;
-
-/*
- * Bitfield macros that use rely on bitfield width/shift information.
- */
-#define BITFMASK(field) (((1U << (field ## _WID)) - 1) << (field ## _LSH))
-#define BITFVAL(field, val) ((val) << (field ## _LSH))
-#define BITFEXT(var, bit) ((var & BITFMASK(bit)) >> (bit ## _LSH))
-
-/*
- * Macros implementing error handling
- */
-#define CHECK_ERROR(a)			\
-do {					\
-		int ret = (a); 			\
-		if (ret != PMIC_SUCCESS)	\
-	return ret; 			\
-} while (0)
-
-#define CHECK_ERROR_KFREE(func, freeptrs) \
-do { \
-	int ret = (func); \
-	if (ret != PMIC_SUCCESS) { \
-		freeptrs;	\
-		return ret;	\
-	}	\
-} while (0);
-
-#endif				/* __ASM_ARCH_MXC_PMIC_STATUS_H__ */
diff --git a/include/linux/ipu.h b/include/linux/ipu.h
new file mode 100644
index 0000000..a28d44e
--- /dev/null
+++ b/include/linux/ipu.h
@@ -0,0 +1,1162 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+/*!
+ * @defgroup IPU MXC Image Processing Unit (IPU) Driver
+ */
+/*!
+ * @file arch-mxc/ipu.h
+ *
+ * @brief This file contains the IPU driver API declarations.
+ *
+ * @ingroup IPU
+ */
+
+#ifndef __ASM_ARCH_IPU_H__
+#define __ASM_ARCH_IPU_H__
+
+#include <linux/types.h>
+#ifdef __KERNEL__
+#include <linux/interrupt.h>
+#else
+#define bool char
+#define irqreturn_t int
+#define dma_addr_t int
+#define u32 unsigned int
+#define __u32 u32
+#endif
+
+/*!
+ * Enumeration of IPU rotation modes
+ */
+typedef enum {
+	/* Note the enum values correspond to BAM value */
+	IPU_ROTATE_NONE = 0,
+	IPU_ROTATE_VERT_FLIP = 1,
+	IPU_ROTATE_HORIZ_FLIP = 2,
+	IPU_ROTATE_180 = 3,
+	IPU_ROTATE_90_RIGHT = 4,
+	IPU_ROTATE_90_RIGHT_VFLIP = 5,
+	IPU_ROTATE_90_RIGHT_HFLIP = 6,
+	IPU_ROTATE_90_LEFT = 7,
+} ipu_rotate_mode_t;
+
+/*!
+ * Enumeration of Post Filter modes
+ */
+typedef enum {
+	PF_DISABLE_ALL = 0,
+	PF_MPEG4_DEBLOCK = 1,
+	PF_MPEG4_DERING = 2,
+	PF_MPEG4_DEBLOCK_DERING = 3,
+	PF_H264_DEBLOCK = 4,
+} pf_operation_t;
+
+/*!
+ * Enumeration of Synchronous (Memory-less) panel types
+ */
+typedef enum {
+	IPU_PANEL_SHARP_TFT,
+	IPU_PANEL_TFT,
+} ipu_panel_t;
+
+/*  IPU Pixel format definitions */
+/*  Four-character-code (FOURCC) */
+#define fourcc(a, b, c, d)\
+        (((__u32)(a)<<0)|((__u32)(b)<<8)|((__u32)(c)<<16)|((__u32)(d)<<24))
+
+/*!
+ * @name IPU Pixel Formats
+ *
+ * Pixel formats are defined with ASCII FOURCC code. The pixel format codes are
+ * the same used by V4L2 API.
+ */
+
+/*! @{ */
+/*! @name Generic or Raw Data Formats */
+/*! @{ */
+#define IPU_PIX_FMT_GENERIC fourcc('I', 'P', 'U', '0')	/*!< IPU Generic Data */
+#define IPU_PIX_FMT_GENERIC_32 fourcc('I', 'P', 'U', '1')	/*!< IPU Generic Data */
+/*! @} */
+/*! @name RGB Formats */
+/*! @{ */
+#define IPU_PIX_FMT_RGB332  fourcc('R', 'G', 'B', '1')	/*!<  8  RGB-3-3-2    */
+#define IPU_PIX_FMT_RGB555  fourcc('R', 'G', 'B', 'O')	/*!< 16  RGB-5-5-5    */
+#define IPU_PIX_FMT_RGB565  fourcc('R', 'G', 'B', 'P')	/*!< 1 6  RGB-5-6-5   */
+#define IPU_PIX_FMT_RGB666  fourcc('R', 'G', 'B', '6')	/*!< 18  RGB-6-6-6    */
+#define IPU_PIX_FMT_BGR666  fourcc('B', 'G', 'R', '6')	/*!< 18  BGR-6-6-6    */
+#define IPU_PIX_FMT_BGR24   fourcc('B', 'G', 'R', '3')	/*!< 24  BGR-8-8-8    */
+#define IPU_PIX_FMT_RGB24   fourcc('R', 'G', 'B', '3')	/*!< 24  RGB-8-8-8    */
+#define IPU_PIX_FMT_BGR32   fourcc('B', 'G', 'R', '4')	/*!< 32  BGR-8-8-8-8  */
+#define IPU_PIX_FMT_BGRA32  fourcc('B', 'G', 'R', 'A')	/*!< 32  BGR-8-8-8-8  */
+#define IPU_PIX_FMT_RGB32   fourcc('R', 'G', 'B', '4')	/*!< 32  RGB-8-8-8-8  */
+#define IPU_PIX_FMT_RGBA32  fourcc('R', 'G', 'B', 'A')	/*!< 32  RGB-8-8-8-8  */
+#define IPU_PIX_FMT_ABGR32  fourcc('A', 'B', 'G', 'R')	/*!< 32  ABGR-8-8-8-8 */
+/*! @} */
+/*! @name YUV Interleaved Formats */
+/*! @{ */
+#define IPU_PIX_FMT_YUYV    fourcc('Y', 'U', 'Y', 'V')	/*!< 16 YUV 4:2:2 */
+#define IPU_PIX_FMT_UYVY    fourcc('U', 'Y', 'V', 'Y')	/*!< 16 YUV 4:2:2 */
+#define IPU_PIX_FMT_Y41P    fourcc('Y', '4', '1', 'P')	/*!< 12 YUV 4:1:1 */
+#define IPU_PIX_FMT_YUV444  fourcc('Y', '4', '4', '4')	/*!< 24 YUV 4:4:4 */
+/* two planes -- one Y, one Cb + Cr interleaved  */
+#define IPU_PIX_FMT_NV12    fourcc('N', 'V', '1', '2') /* 12  Y/CbCr 4:2:0  */
+/*! @} */
+/*! @name YUV Planar Formats */
+/*! @{ */
+#define IPU_PIX_FMT_GREY    fourcc('G', 'R', 'E', 'Y')	/*!< 8  Greyscale */
+#define IPU_PIX_FMT_YVU410P fourcc('Y', 'V', 'U', '9')	/*!< 9  YVU 4:1:0 */
+#define IPU_PIX_FMT_YUV410P fourcc('Y', 'U', 'V', '9')	/*!< 9  YUV 4:1:0 */
+#define IPU_PIX_FMT_YVU420P fourcc('Y', 'V', '1', '2')	/*!< 12 YVU 4:2:0 */
+#define IPU_PIX_FMT_YUV420P fourcc('I', '4', '2', '0')	/*!< 12 YUV 4:2:0 */
+#define IPU_PIX_FMT_YUV420P2 fourcc('Y', 'U', '1', '2')	/*!< 12 YUV 4:2:0 */
+#define IPU_PIX_FMT_YVU422P fourcc('Y', 'V', '1', '6')	/*!< 16 YVU 4:2:2 */
+#define IPU_PIX_FMT_YUV422P fourcc('4', '2', '2', 'P')	/*!< 16 YUV 4:2:2 */
+/*! @} */
+
+/* IPU Driver channels definitions.	*/
+/* Note these are different from IDMA channels */
+#ifdef CONFIG_MXC_IPU_V1
+#define _MAKE_CHAN(num, in, out, sec)    ((num << 24) | (sec << 16) | (out << 8) | in)
+#define IPU_CHAN_ID(ch)         (ch >> 24)
+#define IPU_CHAN_SEC_DMA(ch)    ((uint32_t) (ch >> 16) & 0xFF)
+#define IPU_CHAN_OUT_DMA(ch)    ((uint32_t) (ch >> 8) & 0xFF)
+#define IPU_CHAN_IN_DMA(ch)     ((uint32_t) (ch & 0xFF))
+
+#else
+#define IPU_MAX_CH	32
+#define _MAKE_CHAN(num, v_in, g_in, a_in, out) \
+	((num << 24) | (v_in << 18) | (g_in << 12) | (a_in << 6) | out)
+#define _MAKE_ALT_CHAN(ch)		(ch | (IPU_MAX_CH << 24))
+#define IPU_CHAN_ID(ch)			(ch >> 24)
+#define IPU_CHAN_ALT(ch)		(ch & 0x02000000)
+#define IPU_CHAN_ALPHA_IN_DMA(ch)	((uint32_t) (ch >> 6) & 0x3F)
+#define IPU_CHAN_GRAPH_IN_DMA(ch)	((uint32_t) (ch >> 12) & 0x3F)
+#define IPU_CHAN_VIDEO_IN_DMA(ch)	((uint32_t) (ch >> 18) & 0x3F)
+#define IPU_CHAN_OUT_DMA(ch)		((uint32_t) (ch & 0x3F))
+#define NO_DMA 0x3F
+#define ALT	1
+#endif
+/*!
+ * Enumeration of IPU logical channels. An IPU logical channel is defined as a
+ * combination of an input (memory to IPU), output (IPU to memory), and/or
+ * secondary input IDMA channels and in some cases an Image Converter task.
+ * Some channels consist of only an input or output.
+ */
+typedef enum {
+	CHAN_NONE = -1,
+#ifdef CONFIG_MXC_IPU_V1
+	CSI_MEM = _MAKE_CHAN(1, 0xFF, 7, 0xFF),	/*!< CSI raw sensor data to memory */
+
+	CSI_PRP_ENC_MEM = _MAKE_CHAN(2, 0xFF, 0, 0xFF),	/*!< CSI to IC Encoder PreProcessing to Memory */
+	MEM_PRP_ENC_MEM = _MAKE_CHAN(3, 6, 0, 0xFF),	/*!< Memory to IC Encoder PreProcessing to Memory */
+	MEM_ROT_ENC_MEM = _MAKE_CHAN(4, 10, 8, 0xFF),	/*!< Memory to IC Encoder Rotation to Memory */
+
+	CSI_PRP_VF_MEM = _MAKE_CHAN(5, 0xFF, 1, 0xFF),	/*!< CSI to IC Viewfinder PreProcessing to Memory */
+	CSI_PRP_VF_ADC = _MAKE_CHAN(6, 0xFF, 1, 0xFF),	/*!< CSI to IC Viewfinder PreProcessing to ADC */
+	MEM_PRP_VF_MEM = _MAKE_CHAN(7, 6, 1, 3),	/*!< Memory to IC Viewfinder PreProcessing to Memory */
+	MEM_PRP_VF_ADC = _MAKE_CHAN(8, 6, 1, 3),	/*!< Memory to IC Viewfinder PreProcessing to ADC */
+	MEM_ROT_VF_MEM = _MAKE_CHAN(9, 11, 9, 0xFF),	/*!< Memory to IC Viewfinder Rotation to Memory */
+
+	MEM_PP_MEM = _MAKE_CHAN(10, 5, 2, 4),	/*!< Memory to IC PostProcessing to Memory */
+	MEM_ROT_PP_MEM = _MAKE_CHAN(11, 13, 12, 0xFF),	/*!< Memory to IC PostProcessing Rotation to Memory */
+	MEM_PP_ADC = _MAKE_CHAN(12, 5, 2, 4),	/*!< Memory to IC PostProcessing to ADC */
+
+	MEM_SDC_BG = _MAKE_CHAN(14, 14, 0xFF, 0xFF),	/*!< Memory to SDC Background plane */
+	MEM_SDC_FG = _MAKE_CHAN(15, 15, 0xFF, 0xFF),	/*!< Memory to SDC Foreground plane */
+	MEM_SDC_MASK = _MAKE_CHAN(16, 16, 0xFF, 0xFF),	/*!< Memory to SDC Mask */
+
+	MEM_BG_SYNC = MEM_SDC_BG,
+	MEM_FG_SYNC = MEM_SDC_FG,
+
+	ADC_SYS1 = _MAKE_CHAN(17, 18, 22, 20),	/*!< Memory to ADC System Channel 1 */
+	ADC_SYS2 = _MAKE_CHAN(18, 19, 23, 21),	/*!< Memory to ADC System Channel 2 */
+
+	MEM_PF_Y_MEM = _MAKE_CHAN(19, 26, 29, 24),	/*!< Y and PF Memory to Post-filter to Y Memory */
+	MEM_PF_U_MEM = _MAKE_CHAN(20, 27, 30, 25),	/*!< U and PF Memory to Post-filter to U Memory */
+	MEM_PF_V_MEM = _MAKE_CHAN(21, 28, 31, 0xFF),	/*!< V Memory to Post-filter to V Memory */
+
+	MEM_DC_SYNC = CHAN_NONE,
+	DIRECT_ASYNC0 = CHAN_NONE,
+	DIRECT_ASYNC1 = CHAN_NONE,
+#else
+	MEM_ROT_ENC_MEM = _MAKE_CHAN(1, 45, NO_DMA, NO_DMA, 48),
+	MEM_ROT_VF_MEM = _MAKE_CHAN(2, 46, NO_DMA, NO_DMA, 49),
+	MEM_ROT_PP_MEM = _MAKE_CHAN(3, 47, NO_DMA, NO_DMA, 50),
+
+	MEM_PRP_ENC_MEM = _MAKE_CHAN(4, 12, 14, 17, 20),
+	MEM_PRP_VF_MEM = _MAKE_CHAN(5, 12, 14, 17, 21),
+	MEM_PP_MEM = _MAKE_CHAN(6, 11, 15, 18, 22),
+
+	MEM_DC_SYNC = _MAKE_CHAN(7, 28, NO_DMA, NO_DMA, NO_DMA),
+	MEM_DC_ASYNC = _MAKE_CHAN(8, 41, NO_DMA, NO_DMA, NO_DMA),
+	MEM_BG_SYNC = _MAKE_CHAN(9, 23, NO_DMA, 51, NO_DMA),
+	MEM_FG_SYNC = _MAKE_CHAN(10, 27, NO_DMA, 31, NO_DMA),
+
+	MEM_BG_ASYNC0 = _MAKE_CHAN(11, 24, NO_DMA, 52, NO_DMA),
+	MEM_FG_ASYNC0 = _MAKE_CHAN(12, 29, NO_DMA, 33, NO_DMA),
+	MEM_BG_ASYNC1 = _MAKE_ALT_CHAN(MEM_BG_ASYNC0),
+	MEM_FG_ASYNC1 = _MAKE_ALT_CHAN(MEM_FG_ASYNC0),
+
+	DIRECT_ASYNC0 = _MAKE_CHAN(13, NO_DMA, NO_DMA, NO_DMA, NO_DMA),
+	DIRECT_ASYNC1 = _MAKE_CHAN(14, NO_DMA, NO_DMA, NO_DMA, NO_DMA),
+
+	CSI_MEM0 = _MAKE_CHAN(15, NO_DMA, NO_DMA, NO_DMA, 0),
+	CSI_MEM1 = _MAKE_CHAN(16, NO_DMA, NO_DMA, NO_DMA, 1),
+	CSI_MEM2 = _MAKE_CHAN(17, NO_DMA, NO_DMA, NO_DMA, 2),
+	CSI_MEM3 = _MAKE_CHAN(18, NO_DMA, NO_DMA, NO_DMA, 3),
+
+	CSI_MEM = CSI_MEM0,
+
+	CSI_PRP_ENC_MEM = _MAKE_CHAN(19, NO_DMA, NO_DMA, NO_DMA, 20),
+	CSI_PRP_VF_MEM = _MAKE_CHAN(20, NO_DMA, NO_DMA, NO_DMA, 21),
+
+	MEM_PP_ADC = CHAN_NONE,
+	ADC_SYS2 = CHAN_NONE,
+#endif
+
+} ipu_channel_t;
+
+/*!
+ * Enumeration of types of buffers for a logical channel.
+ */
+typedef enum {
+	IPU_OUTPUT_BUFFER = 0,	/*!< Buffer for output from IPU */
+	IPU_ALPHA_IN_BUFFER = 1,	/*!< Buffer for input to IPU */
+	IPU_GRAPH_IN_BUFFER = 2,	/*!< Buffer for input to IPU */
+	IPU_VIDEO_IN_BUFFER = 3,	/*!< Buffer for input to IPU */
+	IPU_INPUT_BUFFER = IPU_VIDEO_IN_BUFFER,
+	IPU_SEC_INPUT_BUFFER = IPU_GRAPH_IN_BUFFER,
+} ipu_buffer_t;
+
+#define IPU_PANEL_SERIAL		1
+#define IPU_PANEL_PARALLEL		2
+
+/*!
+ * Enumeration of DI ports for ADC.
+ */
+typedef enum {
+	DISP0,
+	DISP1,
+	DISP2,
+	DISP3
+} display_port_t;
+
+/*!
+ * Enumeration of ADC channel operation mode.
+ */
+typedef enum {
+	Disable,
+	WriteTemplateNonSeq,
+	ReadTemplateNonSeq,
+	WriteTemplateUnCon,
+	ReadTemplateUnCon,
+	WriteDataWithRS,
+	WriteDataWoRS,
+	WriteCmd
+} mcu_mode_t;
+
+/*!
+ * Enumeration of ADC channel addressing mode.
+ */
+typedef enum {
+	FullWoBE,
+	FullWithBE,
+	XY
+} display_addressing_t;
+
+/*!
+ * Union of initialization parameters for a logical channel.
+ */
+typedef union {
+	struct {
+		uint32_t csi;
+		bool mipi_en;
+		uint32_t mipi_id;
+	} csi_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		uint32_t csi;
+	} csi_prp_enc_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+	} mem_prp_enc_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+	} mem_rot_enc_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		bool graphics_combine_en;
+		bool global_alpha_en;
+		bool key_color_en;
+		uint32_t csi;
+	} csi_prp_vf_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		bool graphics_combine_en;
+		bool global_alpha_en;
+		bool key_color_en;
+		display_port_t disp;
+		uint32_t out_left;
+		uint32_t out_top;
+	} csi_prp_vf_adc;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		bool graphics_combine_en;
+		bool global_alpha_en;
+		bool key_color_en;
+	} mem_prp_vf_mem;
+	struct {
+		uint32_t temp;
+	} mem_prp_vf_adc;
+	struct {
+		uint32_t temp;
+	} mem_rot_vf_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		bool graphics_combine_en;
+		bool global_alpha_en;
+		bool key_color_en;
+	} mem_pp_mem;
+	struct {
+		uint32_t temp;
+	} mem_rot_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		bool graphics_combine_en;
+		bool global_alpha_en;
+		bool key_color_en;
+		display_port_t disp;
+		uint32_t out_left;
+		uint32_t out_top;
+	} mem_pp_adc;
+	struct {
+		pf_operation_t operation;
+	} mem_pf_mem;
+	struct {
+		uint32_t di;
+		bool interlaced;
+	} mem_dc_sync;
+	struct {
+		uint32_t temp;
+	} mem_sdc_fg;
+	struct {
+		uint32_t di;
+		bool interlaced;
+		uint32_t in_pixel_fmt;
+		uint32_t out_pixel_fmt;
+	} mem_dp_bg_sync;
+	struct {
+		uint32_t temp;
+	} mem_sdc_bg;
+	struct {
+		uint32_t di;
+		bool interlaced;
+		uint32_t in_pixel_fmt;
+		uint32_t out_pixel_fmt;
+	} mem_dp_fg_sync;
+	struct {
+		uint32_t di;
+	} direct_async;
+	struct {
+		display_port_t disp;
+		mcu_mode_t ch_mode;
+		uint32_t out_left;
+		uint32_t out_top;
+	} adc_sys1;
+	struct {
+		display_port_t disp;
+		mcu_mode_t ch_mode;
+		uint32_t out_left;
+		uint32_t out_top;
+	} adc_sys2;
+} ipu_channel_params_t;
+
+/*!
+ * Enumeration of IPU interrupt sources.
+ */
+enum ipu_irq_line {
+#ifdef CONFIG_MXC_IPU_V1
+	IPU_IRQ_DC_FC_1 = -1,
+
+	IPU_IRQ_PRP_ENC_OUT_EOF = 0,
+	IPU_IRQ_PRP_VF_OUT_EOF = 1,
+	IPU_IRQ_PP_OUT_EOF = 2,
+	IPU_IRQ_PRP_GRAPH_IN_EOF = 3,
+	IPU_IRQ_PP_GRAPH_IN_EOF = 4,
+	IPU_IRQ_PP_IN_EOF = 5,
+	IPU_IRQ_PRP_IN_EOF = 6,
+	IPU_IRQ_SENSOR_OUT_EOF = 7,
+	IPU_IRQ_PRP_ENC_ROT_OUT_EOF = 8,
+	IPU_IRQ_PRP_VF_ROT_OUT_EOF = 9,
+	IPU_IRQ_PRP_ENC_ROT_IN_EOF = 10,
+	IPU_IRQ_PRP_VF_ROT_IN_EOF = 11,
+	IPU_IRQ_PP_ROT_OUT_EOF = 12,
+	IPU_IRQ_PP_ROT_IN_EOF = 13,
+	IPU_IRQ_BG_SYNC_EOF = 14,
+	IPU_IRQ_SDC_BG_EOF = IPU_IRQ_BG_SYNC_EOF,
+	IPU_IRQ_FG_SYNC_EOF = 15,
+	IPU_IRQ_SDC_FG_EOF = IPU_IRQ_FG_SYNC_EOF,
+	IPU_IRQ_SDC_MASK_EOF = 16,
+	IPU_IRQ_SDC_BG_PART_EOF = 17,
+	IPU_IRQ_ADC_SYS1_WR_EOF = 18,
+	IPU_IRQ_ADC_SYS2_WR_EOF = 19,
+	IPU_IRQ_ADC_SYS1_CMD_EOF = 20,
+	IPU_IRQ_ADC_SYS2_CMD_EOF = 21,
+	IPU_IRQ_ADC_SYS1_RD_EOF = 22,
+	IPU_IRQ_ADC_SYS2_RD_EOF = 23,
+	IPU_IRQ_PF_QP_IN_EOF = 24,
+	IPU_IRQ_PF_BSP_IN_EOF = 25,
+	IPU_IRQ_PF_Y_IN_EOF = 26,
+	IPU_IRQ_PF_U_IN_EOF = 27,
+	IPU_IRQ_PF_V_IN_EOF = 28,
+	IPU_IRQ_PF_Y_OUT_EOF = 29,
+	IPU_IRQ_PF_U_OUT_EOF = 30,
+	IPU_IRQ_PF_V_OUT_EOF = 31,
+
+	IPU_IRQ_PRP_ENC_OUT_NF = 32,
+	IPU_IRQ_PRP_VF_OUT_NF = 33,
+	IPU_IRQ_PP_OUT_NF = 34,
+	IPU_IRQ_PRP_GRAPH_IN_NF = 35,
+	IPU_IRQ_PP_GRAPH_IN_NF = 36,
+	IPU_IRQ_PP_IN_NF = 37,
+	IPU_IRQ_PRP_IN_NF = 38,
+	IPU_IRQ_SENSOR_OUT_NF = 39,
+	IPU_IRQ_PRP_ENC_ROT_OUT_NF = 40,
+	IPU_IRQ_PRP_VF_ROT_OUT_NF = 41,
+	IPU_IRQ_PRP_ENC_ROT_IN_NF = 42,
+	IPU_IRQ_PRP_VF_ROT_IN_NF = 43,
+	IPU_IRQ_PP_ROT_OUT_NF = 44,
+	IPU_IRQ_PP_ROT_IN_NF = 45,
+	IPU_IRQ_SDC_FG_NF = 46,
+	IPU_IRQ_SDC_BG_NF = 47,
+	IPU_IRQ_SDC_MASK_NF = 48,
+	IPU_IRQ_SDC_BG_PART_NF = 49,
+	IPU_IRQ_ADC_SYS1_WR_NF = 50,
+	IPU_IRQ_ADC_SYS2_WR_NF = 51,
+	IPU_IRQ_ADC_SYS1_CMD_NF = 52,
+	IPU_IRQ_ADC_SYS2_CMD_NF = 53,
+	IPU_IRQ_ADC_SYS1_RD_NF = 54,
+	IPU_IRQ_ADC_SYS2_RD_NF = 55,
+	IPU_IRQ_PF_QP_IN_NF = 56,
+	IPU_IRQ_PF_BSP_IN_NF = 57,
+	IPU_IRQ_PF_Y_IN_NF = 58,
+	IPU_IRQ_PF_U_IN_NF = 59,
+	IPU_IRQ_PF_V_IN_NF = 60,
+	IPU_IRQ_PF_Y_OUT_NF = 61,
+	IPU_IRQ_PF_U_OUT_NF = 62,
+	IPU_IRQ_PF_V_OUT_NF = 63,
+
+	IPU_IRQ_BREAKRQ = 64,
+	IPU_IRQ_SDC_BG_OUT_EOF = 65,
+	IPU_IRQ_BG_SF_END = IPU_IRQ_SDC_BG_OUT_EOF,
+	IPU_IRQ_SDC_FG_OUT_EOF = 66,
+	IPU_IRQ_SDC_MASK_OUT_EOF = 67,
+	IPU_IRQ_ADC_SERIAL_DATA_OUT = 68,
+	IPU_IRQ_SENSOR_NF = 69,
+	IPU_IRQ_SENSOR_EOF = 70,
+	IPU_IRQ_SDC_DISP3_VSYNC = 80,
+	IPU_IRQ_ADC_DISP0_VSYNC = 81,
+	IPU_IRQ_ADC_DISP12_VSYNC = 82,
+	IPU_IRQ_ADC_PRP_EOF = 83,
+	IPU_IRQ_ADC_PP_EOF = 84,
+	IPU_IRQ_ADC_SYS1_EOF = 85,
+	IPU_IRQ_ADC_SYS2_EOF = 86,
+
+	IPU_IRQ_PRP_ENC_OUT_NFB4EOF_ERR = 96,
+	IPU_IRQ_PRP_VF_OUT_NFB4EOF_ERR = 97,
+	IPU_IRQ_PP_OUT_NFB4EOF_ERR = 98,
+	IPU_IRQ_PRP_GRAPH_IN_NFB4EOF_ERR = 99,
+	IPU_IRQ_PP_GRAPH_IN_NFB4EOF_ERR = 100,
+	IPU_IRQ_PP_IN_NFB4EOF_ERR = 101,
+	IPU_IRQ_PRP_IN_NFB4EOF_ERR = 102,
+	IPU_IRQ_SENSOR_OUT_NFB4EOF_ERR = 103,
+	IPU_IRQ_PRP_ENC_ROT_OUT_NFB4EOF_ERR = 104,
+	IPU_IRQ_PRP_VF_ROT_OUT_NFB4EOF_ERR = 105,
+	IPU_IRQ_PRP_ENC_ROT_IN_NFB4EOF_ERR = 106,
+	IPU_IRQ_PRP_VF_ROT_IN_NFB4EOF_ERR = 107,
+	IPU_IRQ_PP_ROT_OUT_NFB4EOF_ERR = 108,
+	IPU_IRQ_PP_ROT_IN_NFB4EOF_ERR = 109,
+	IPU_IRQ_SDC_FG_NFB4EOF_ERR = 110,
+	IPU_IRQ_SDC_BG_NFB4EOF_ERR = 111,
+	IPU_IRQ_SDC_MASK_NFB4EOF_ERR = 112,
+	IPU_IRQ_SDC_BG_PART_NFB4EOF_ERR = 113,
+	IPU_IRQ_ADC_SYS1_WR_NFB4EOF_ERR = 114,
+	IPU_IRQ_ADC_SYS2_WR_NFB4EOF_ERR = 115,
+	IPU_IRQ_ADC_SYS1_CMD_NFB4EOF_ERR = 116,
+	IPU_IRQ_ADC_SYS2_CMD_NFB4EOF_ERR = 117,
+	IPU_IRQ_ADC_SYS1_RD_NFB4EOF_ERR = 118,
+	IPU_IRQ_ADC_SYS2_RD_NFB4EOF_ERR = 119,
+	IPU_IRQ_PF_QP_IN_NFB4EOF_ERR = 120,
+	IPU_IRQ_PF_BSP_IN_NFB4EOF_ERR = 121,
+	IPU_IRQ_PF_Y_IN_NFB4EOF_ERR = 122,
+	IPU_IRQ_PF_U_IN_NFB4EOF_ERR = 123,
+	IPU_IRQ_PF_V_IN_NFB4EOF_ERR = 124,
+	IPU_IRQ_PF_Y_OUT_NFB4EOF_ERR = 125,
+	IPU_IRQ_PF_U_OUT_NFB4EOF_ERR = 126,
+	IPU_IRQ_PF_V_OUT_NFB4EOF_ERR = 127,
+
+	IPU_IRQ_BAYER_BUFOVF_ERR = 128,
+	IPU_IRQ_ENC_BUFOVF_ERR = 129,
+	IPU_IRQ_VF_BUFOVF_ERR = 130,
+	IPU_IRQ_ADC_PP_TEAR_ERR = 131,
+	IPU_IRQ_ADC_SYS1_TEAR_ERR = 132,
+	IPU_IRQ_ADC_SYS2_TEAR_ERR = 133,
+	IPU_IRQ_SDC_BGD_ERR = 134,
+	IPU_IRQ_SDC_FGD_ERR = 135,
+	IPU_IRQ_SDC_MASKD_ERR = 136,
+	IPU_IRQ_BAYER_FRM_LOST_ERR = 137,
+	IPU_IRQ_ENC_FRM_LOST_ERR = 138,
+	IPU_IRQ_VF_FRM_LOST_ERR = 139,
+	IPU_IRQ_ADC_LOCK_ERR = 140,
+	IPU_IRQ_DI_LLA_LOCK_ERR = 141,
+	IPU_IRQ_AHB_M1_ERR = 142,
+	IPU_IRQ_AHB_M12_ERR = 143,
+#else
+	IPU_IRQ_CSI0_OUT_EOF = 0,
+	IPU_IRQ_CSI1_OUT_EOF = 1,
+	IPU_IRQ_CSI2_OUT_EOF = 2,
+	IPU_IRQ_CSI3_OUT_EOF = 3,
+	IPU_IRQ_PP_IN_EOF = 11,
+	IPU_IRQ_PRP_IN_EOF = 12,
+	IPU_IRQ_PRP_GRAPH_IN_EOF = 14,
+	IPU_IRQ_PP_GRAPH_IN_EOF = 15,
+	IPU_IRQ_PRP_ALPHA_IN_EOF = 17,
+	IPU_IRQ_PP_ALPHA_IN_EOF = 18,
+	IPU_IRQ_PRP_ENC_OUT_EOF = 20,
+	IPU_IRQ_PRP_VF_OUT_EOF = 21,
+	IPU_IRQ_PP_OUT_EOF = 22,
+	IPU_IRQ_BG_SYNC_EOF = 23,
+	IPU_IRQ_BG_ASYNC_EOF = 24,
+	IPU_IRQ_FG_SYNC_EOF = 27,
+	IPU_IRQ_DC_SYNC_EOF = 28,
+	IPU_IRQ_FG_ASYNC_EOF = 29,
+	IPU_IRQ_FG_ALPHA_SYNC_EOF = 31,
+
+	IPU_IRQ_FG_ALPHA_ASYNC_EOF = 33,
+	IPU_IRQ_DC_READ_EOF = 40,
+	IPU_IRQ_DC_ASYNC_EOF = 41,
+	IPU_IRQ_DC_CMD1_EOF = 42,
+	IPU_IRQ_DC_CMD2_EOF = 43,
+	IPU_IRQ_DC_MASK_EOF = 44,
+	IPU_IRQ_PRP_ENC_ROT_OUT_EOF = 45,
+	IPU_IRQ_PRP_VF_ROT_OUT_EOF = 46,
+	IPU_IRQ_PP_ROT_OUT_EOF = 47,
+	IPU_IRQ_PRP_ENC_ROT_IN_EOF = 48,
+	IPU_IRQ_PRP_VF_ROT_IN_EOF = 49,
+	IPU_IRQ_PP_ROT_IN_EOF = 50,
+	IPU_IRQ_BG_ALPHA_SYNC_EOF = 51,
+	IPU_IRQ_BG_ALPHA_ASYNC_EOF = 52,
+
+	IPU_IRQ_DP_SF_START = 448 + 2,
+	IPU_IRQ_DP_SF_END = 448 + 3,
+	IPU_IRQ_BG_SF_END = IPU_IRQ_DP_SF_END,
+	IPU_IRQ_DC_FC_0 = 448 + 8,
+	IPU_IRQ_DC_FC_1 = 448 + 9,
+	IPU_IRQ_DC_FC_2 = 448 + 10,
+	IPU_IRQ_DC_FC_3 = 448 + 11,
+	IPU_IRQ_DC_FC_4 = 448 + 12,
+	IPU_IRQ_DC_FC_6 = 448 + 13,
+	IPU_IRQ_VSYNC_PRE_0 = 448 + 14,
+	IPU_IRQ_VSYNC_PRE_1 = 448 + 15,
+#endif
+
+	IPU_IRQ_COUNT
+};
+
+/*!
+ * Bitfield of Display Interface signal polarities.
+ */
+typedef struct {
+	unsigned datamask_en:1;
+	unsigned ext_clk:1;
+	unsigned interlaced:1;
+	unsigned odd_field_first:1;
+	unsigned clksel_en:1;
+	unsigned clkidle_en:1;
+	unsigned data_pol:1;	/* true = inverted */
+	unsigned clk_pol:1;	/* true = rising edge */
+	unsigned enable_pol:1;
+	unsigned Hsync_pol:1;	/* true = active high */
+	unsigned Vsync_pol:1;
+} ipu_di_signal_cfg_t;
+
+/*!
+ * Bitfield of CSI signal polarities and modes.
+ */
+
+typedef struct {
+	unsigned data_width:4;
+	unsigned clk_mode:3;
+	unsigned ext_vsync:1;
+	unsigned Vsync_pol:1;
+	unsigned Hsync_pol:1;
+	unsigned pixclk_pol:1;
+	unsigned data_pol:1;
+	unsigned sens_clksrc:1;
+	unsigned pack_tight:1;
+	unsigned force_eof:1;
+	unsigned data_en_pol:1;
+	unsigned data_fmt;
+	unsigned csi;
+	unsigned mclk;
+} ipu_csi_signal_cfg_t;
+
+/*!
+ * Enumeration of CSI data bus widths.
+ */
+enum {
+	IPU_CSI_DATA_WIDTH_4,
+	IPU_CSI_DATA_WIDTH_8,
+	IPU_CSI_DATA_WIDTH_10,
+	IPU_CSI_DATA_WIDTH_16,
+};
+
+/*!
+ * Enumeration of CSI clock modes.
+ */
+enum {
+	IPU_CSI_CLK_MODE_GATED_CLK,
+	IPU_CSI_CLK_MODE_NONGATED_CLK,
+	IPU_CSI_CLK_MODE_CCIR656_PROGRESSIVE,
+	IPU_CSI_CLK_MODE_CCIR656_INTERLACED,
+	IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_DDR,
+	IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_SDR,
+	IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_DDR,
+	IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_SDR,
+};
+
+enum {
+	IPU_CSI_MIPI_DI0,
+	IPU_CSI_MIPI_DI1,
+	IPU_CSI_MIPI_DI2,
+	IPU_CSI_MIPI_DI3,
+};
+
+typedef enum {
+	RGB,
+	YCbCr,
+	YUV
+} ipu_color_space_t;
+
+/*!
+ * Enumeration of ADC vertical sync mode.
+ */
+typedef enum {
+	VsyncNone,
+	VsyncInternal,
+	VsyncCSI,
+	VsyncExternal
+} vsync_t;
+
+typedef enum {
+	DAT,
+	CMD
+} cmddata_t;
+
+/*!
+ * Enumeration of ADC display update mode.
+ */
+typedef enum {
+	IPU_ADC_REFRESH_NONE,
+	IPU_ADC_AUTO_REFRESH,
+	IPU_ADC_AUTO_REFRESH_SNOOP,
+	IPU_ADC_SNOOPING,
+} ipu_adc_update_mode_t;
+
+/*!
+ * Enumeration of ADC display interface types (serial or parallel).
+ */
+enum {
+	IPU_ADC_IFC_MODE_SYS80_TYPE1,
+	IPU_ADC_IFC_MODE_SYS80_TYPE2,
+	IPU_ADC_IFC_MODE_SYS68K_TYPE1,
+	IPU_ADC_IFC_MODE_SYS68K_TYPE2,
+	IPU_ADC_IFC_MODE_3WIRE_SERIAL,
+	IPU_ADC_IFC_MODE_4WIRE_SERIAL,
+	IPU_ADC_IFC_MODE_5WIRE_SERIAL_CLK,
+	IPU_ADC_IFC_MODE_5WIRE_SERIAL_CS,
+};
+
+enum {
+	IPU_ADC_IFC_WIDTH_8,
+	IPU_ADC_IFC_WIDTH_16,
+};
+
+/*!
+ * Enumeration of ADC display interface burst mode.
+ */
+enum {
+	IPU_ADC_BURST_WCS,
+	IPU_ADC_BURST_WBLCK,
+	IPU_ADC_BURST_NONE,
+	IPU_ADC_BURST_SERIAL,
+};
+
+/*!
+ * Enumeration of ADC display interface RW signal timing modes.
+ */
+enum {
+	IPU_ADC_SER_NO_RW,
+	IPU_ADC_SER_RW_BEFORE_RS,
+	IPU_ADC_SER_RW_AFTER_RS,
+};
+
+/*!
+ * Bitfield of ADC signal polarities and modes.
+ */
+typedef struct {
+	unsigned data_pol:1;
+	unsigned clk_pol:1;
+	unsigned cs_pol:1;
+	unsigned rs_pol:1;
+	unsigned addr_pol:1;
+	unsigned read_pol:1;
+	unsigned write_pol:1;
+	unsigned Vsync_pol:1;
+	unsigned burst_pol:1;
+	unsigned burst_mode:2;
+	unsigned ifc_mode:3;
+	unsigned ifc_width:5;
+	unsigned ser_preamble_len:4;
+	unsigned ser_preamble:8;
+	unsigned ser_rw_mode:2;
+} ipu_adc_sig_cfg_t;
+
+/*!
+ * Enumeration of ADC template commands.
+ */
+enum {
+	RD_DATA,
+	RD_ACK,
+	RD_WAIT,
+	WR_XADDR,
+	WR_YADDR,
+	WR_ADDR,
+	WR_CMND,
+	WR_DATA,
+};
+
+/*!
+ * Enumeration of ADC template command flow control.
+ */
+enum {
+	SINGLE_STEP,
+	PAUSE,
+	STOP,
+};
+
+/*Define template constants*/
+#define     ATM_ADDR_RANGE      0x20	/*offset address of DISP */
+#define     TEMPLATE_BUF_SIZE   0x20	/*size of template */
+
+/*!
+ * Define to create ADC template command entry.
+ */
+#define ipu_adc_template_gen(oc, rs, fc, dat) ( ((rs) << 29) | ((fc) << 27) | \
+                                                ((oc) << 24) | (dat) )
+
+typedef struct {
+	u32 reg;
+	u32 value;
+} ipu_lpmc_reg_t;
+
+#define IPU_LPMC_REG_READ       0x80000000L
+
+#define CSI_MCLK_VF  1
+#define CSI_MCLK_ENC 2
+#define CSI_MCLK_RAW 4
+#define CSI_MCLK_I2C 8
+
+/* Common IPU API */
+int32_t ipu_init_channel(ipu_channel_t channel, ipu_channel_params_t * params);
+void ipu_uninit_channel(ipu_channel_t channel);
+
+static inline bool ipu_can_rotate_in_place(ipu_rotate_mode_t rot)
+{
+#ifdef CONFIG_MXC_IPU_V3D
+	return (rot < IPU_ROTATE_HORIZ_FLIP);
+#else
+	return (rot < IPU_ROTATE_90_RIGHT);
+#endif
+}
+
+int32_t ipu_init_channel_buffer(ipu_channel_t channel, ipu_buffer_t type,
+				uint32_t pixel_fmt,
+				uint16_t width, uint16_t height,
+				uint32_t stride,
+				ipu_rotate_mode_t rot_mode,
+				dma_addr_t phyaddr_0, dma_addr_t phyaddr_1,
+				uint32_t u_offset, uint32_t v_offset);
+
+int32_t ipu_update_channel_buffer(ipu_channel_t channel, ipu_buffer_t type,
+				  uint32_t bufNum, dma_addr_t phyaddr);
+
+int32_t ipu_select_buffer(ipu_channel_t channel,
+			  ipu_buffer_t type, uint32_t bufNum);
+
+int32_t ipu_link_channels(ipu_channel_t src_ch, ipu_channel_t dest_ch);
+int32_t ipu_unlink_channels(ipu_channel_t src_ch, ipu_channel_t dest_ch);
+
+int32_t ipu_enable_channel(ipu_channel_t channel);
+int32_t ipu_disable_channel(ipu_channel_t channel, bool wait_for_stop);
+
+int ipu_lowpwr_display_enable(void);
+int ipu_lowpwr_display_disable(void);
+
+void ipu_enable_irq(uint32_t irq);
+void ipu_disable_irq(uint32_t irq);
+void ipu_clear_irq(uint32_t irq);
+int ipu_request_irq(uint32_t irq,
+		    irqreturn_t(*handler) (int, void *),
+		    uint32_t irq_flags, const char *devname, void *dev_id);
+void ipu_free_irq(uint32_t irq, void *dev_id);
+bool ipu_get_irq_status(uint32_t irq);
+void ipu_set_csc_coefficients(ipu_channel_t channel, int32_t param[][3]);
+
+/* SDC API */
+int32_t ipu_sdc_init_panel(ipu_panel_t panel,
+			   uint32_t pixel_clk,
+			   uint16_t width, uint16_t height,
+			   uint32_t pixel_fmt,
+			   uint16_t hStartWidth, uint16_t hSyncWidth,
+			   uint16_t hEndWidth, uint16_t vStartWidth,
+			   uint16_t vSyncWidth, uint16_t vEndWidth,
+			   ipu_di_signal_cfg_t sig);
+
+int32_t ipu_sdc_set_global_alpha(bool enable, uint8_t alpha);
+int32_t ipu_sdc_set_color_key(ipu_channel_t channel, bool enable,
+			      uint32_t colorKey);
+int32_t ipu_sdc_set_brightness(uint8_t value);
+
+int32_t ipu_init_sync_panel(int disp,
+			    uint32_t pixel_clk,
+			    uint16_t width, uint16_t height,
+			    uint32_t pixel_fmt,
+			    uint16_t h_start_width, uint16_t h_sync_width,
+			    uint16_t h_end_width, uint16_t v_start_width,
+			    uint16_t v_sync_width, uint16_t v_end_width,
+			    uint32_t v_to_h_sync, ipu_di_signal_cfg_t sig);
+
+int32_t ipu_disp_set_window_pos(ipu_channel_t channel, int16_t x_pos,
+				int16_t y_pos);
+int32_t ipu_disp_set_global_alpha(ipu_channel_t channel, bool enable,
+				  uint8_t alpha);
+int32_t ipu_disp_set_color_key(ipu_channel_t channel, bool enable,
+			       uint32_t colorKey);
+
+int ipu_init_async_panel(int disp, int type, uint32_t cycle_time,
+			 uint32_t pixel_fmt, ipu_adc_sig_cfg_t sig);
+void ipu_disp_direct_write(ipu_channel_t channel, u32 value, u32 offset);
+void ipu_reset_disp_panel(void);
+
+/* ADC API */
+int32_t ipu_adc_write_template(display_port_t disp, uint32_t * pCmd,
+			       bool write);
+
+int32_t ipu_adc_set_update_mode(ipu_channel_t channel,
+				ipu_adc_update_mode_t mode,
+				uint32_t refresh_rate, unsigned long addr,
+				uint32_t * size);
+
+int32_t ipu_adc_get_snooping_status(uint32_t * statl, uint32_t * stath);
+
+int32_t ipu_adc_write_cmd(display_port_t disp, cmddata_t type,
+			  uint32_t cmd, const uint32_t * params,
+			  uint16_t numParams);
+
+int32_t ipu_adc_init_panel(display_port_t disp,
+			   uint16_t width, uint16_t height,
+			   uint32_t pixel_fmt,
+			   uint32_t stride,
+			   ipu_adc_sig_cfg_t sig,
+			   display_addressing_t addr,
+			   uint32_t vsync_width, vsync_t mode);
+
+int32_t ipu_adc_init_ifc_timing(display_port_t disp, bool read,
+				uint32_t cycle_time,
+				uint32_t up_time,
+				uint32_t down_time,
+				uint32_t read_latch_time, uint32_t pixel_clk);
+
+/* CMOS Sensor Interface API */
+int32_t ipu_csi_init_interface(uint16_t width, uint16_t height,
+			       uint32_t pixel_fmt, ipu_csi_signal_cfg_t sig);
+
+int32_t ipu_csi_enable_mclk(int src, bool flag, bool wait);
+
+static inline int32_t ipu_csi_enable_mclk_if(int src, uint32_t csi,
+		bool flag, bool wait)
+{
+#ifdef CONFIG_MXC_IPU_V1
+	return ipu_csi_enable_mclk(src, flag, wait);
+#else
+	return ipu_csi_enable_mclk(csi, flag, wait);
+#endif
+}
+
+int ipu_csi_read_mclk_flag(void);
+
+void ipu_csi_flash_strobe(bool flag);
+
+void ipu_csi_get_window_size(uint32_t *width, uint32_t *height, uint32_t csi);
+
+void ipu_csi_set_window_size(uint32_t width, uint32_t height, uint32_t csi);
+
+void ipu_csi_set_window_pos(uint32_t left, uint32_t top, uint32_t csi);
+
+/* Post Filter functions */
+int32_t ipu_pf_set_pause_row(uint32_t pause_row);
+
+uint32_t bytes_per_pixel(uint32_t fmt);
+
+/* New added for IPU-lib functionality*/
+int ipu_open(void);
+int ipu_register_generic_isr(int irq, void *dev);
+void ipu_close(void);
+
+typedef struct _ipu_channel_parm {
+	ipu_channel_t channel;
+	ipu_channel_params_t params;
+	bool flag;
+} ipu_channel_parm;
+
+typedef struct _ipu_channel_buf_parm {
+	ipu_channel_t channel;
+	ipu_buffer_t type;
+	uint32_t pixel_fmt;
+	uint16_t width;
+	uint16_t height;
+	uint16_t stride;
+	ipu_rotate_mode_t rot_mode;
+	dma_addr_t phyaddr_0;
+	dma_addr_t phyaddr_1;
+	uint32_t u_offset;
+	uint32_t v_offset;
+	uint32_t bufNum;
+} ipu_channel_buf_parm;
+
+typedef struct _ipu_channel_link {
+	ipu_channel_t src_ch;
+	ipu_channel_t dest_ch;
+} ipu_channel_link;
+
+typedef struct _ipu_channel_info {
+	ipu_channel_t channel;
+	bool stop;
+} ipu_channel_info;
+
+typedef struct ipu_irq_info {
+	uint32_t irq;
+	 irqreturn_t(*handler) (int, void *);
+	uint32_t irq_flags;
+	char *devname;
+	void *dev_id;
+} ipu_irq_info;
+
+typedef struct _ipu_sdc_panel_info {
+	ipu_panel_t panel;
+	uint32_t pixel_clk;
+	uint16_t width;
+	uint16_t height;
+	uint32_t pixel_fmt;
+	uint16_t hStartWidth;
+	uint16_t hSyncWidth;
+	uint16_t hEndWidth;
+	uint16_t vStartWidth;
+	uint16_t vSyncWidth;
+	uint16_t vEndWidth;
+	ipu_di_signal_cfg_t signal;
+} ipu_sdc_panel_info;
+
+typedef struct _ipu_sdc_window_pos {
+	ipu_channel_t channel;
+	int16_t x_pos;
+	int16_t y_pos;
+} ipu_sdc_window_pos;
+
+typedef struct _ipu_sdc_global_alpha {
+	bool enable;
+	uint8_t alpha;
+} ipu_sdc_global_alpha;
+
+typedef struct _ipu_sdc_color_key {
+	ipu_channel_t channel;
+	bool enable;
+	uint32_t colorKey;
+} ipu_sdc_color_key;
+
+typedef struct _ipu_adc_template {
+	display_port_t disp;
+	uint32_t *pCmd;
+	bool write;
+} ipu_adc_template;
+
+typedef struct _ipu_adc_update {
+	ipu_channel_t channel;
+	ipu_adc_update_mode_t mode;
+	uint32_t refresh_rate;
+	unsigned long addr;
+	uint32_t *size;
+} ipu_adc_update;
+
+typedef struct _ipu_adc_snoop {
+	uint32_t *statl;
+	uint32_t *stath;
+} ipu_adc_snoop;
+
+typedef struct _ipu_adc_cmd {
+	display_port_t disp;
+	cmddata_t type;
+	uint32_t cmd;
+	uint32_t *params;
+	uint16_t numParams;
+} ipu_adc_cmd;
+
+typedef struct _ipu_adc_panel {
+	display_port_t disp;
+	uint16_t width;
+	uint16_t height;
+	uint32_t pixel_fmt;
+	uint32_t stride;
+	ipu_adc_sig_cfg_t signal;
+	display_addressing_t addr;
+	uint32_t vsync_width;
+	vsync_t mode;
+} ipu_adc_panel;
+
+typedef struct _ipu_adc_ifc_timing {
+	display_port_t disp;
+	bool read;
+	uint32_t cycle_time;
+	uint32_t up_time;
+	uint32_t down_time;
+	uint32_t read_latch_time;
+	uint32_t pixel_clk;
+} ipu_adc_ifc_timing;
+
+typedef struct _ipu_csi_interface {
+	uint16_t width;
+	uint16_t height;
+	uint16_t pixel_fmt;
+	ipu_csi_signal_cfg_t signal;
+} ipu_csi_interface;
+
+typedef struct _ipu_csi_mclk {
+	int src;
+	bool flag;
+	bool wait;
+} ipu_csi_mclk;
+
+typedef struct _ipu_csi_window {
+	uint32_t left;
+	uint32_t top;
+} ipu_csi_window;
+
+typedef struct _ipu_csi_window_size {
+	uint32_t width;
+	uint32_t height;
+} ipu_csi_window_size;
+
+typedef struct _ipu_event_info {
+	int irq;
+	void *dev;
+} ipu_event_info;
+
+typedef struct _ipu_mem_info {
+	dma_addr_t paddr;
+	void *vaddr;
+	int size;
+} ipu_mem_info;
+
+/* IOCTL commands */
+
+#define IPU_INIT_CHANNEL              _IOW('I',0x1,ipu_channel_parm)
+#define IPU_UNINIT_CHANNEL            _IOW('I',0x2,ipu_channel_t)
+#define IPU_INIT_CHANNEL_BUFFER       _IOW('I',0x3,ipu_channel_buf_parm)
+#define IPU_UPDATE_CHANNEL_BUFFER     _IOW('I',0x4,ipu_channel_buf_parm)
+#define IPU_SELECT_CHANNEL_BUFFER     _IOW('I',0x5,ipu_channel_buf_parm)
+#define IPU_LINK_CHANNELS             _IOW('I',0x6,ipu_channel_link)
+#define IPU_UNLINK_CHANNELS           _IOW('I',0x7,ipu_channel_link)
+#define IPU_ENABLE_CHANNEL            _IOW('I',0x8,ipu_channel_t)
+#define IPU_DISABLE_CHANNEL           _IOW('I',0x9,ipu_channel_info)
+#define IPU_ENABLE_IRQ                _IOW('I',0xA,int)
+#define IPU_DISABLE_IRQ               _IOW('I',0xB,int)
+#define IPU_CLEAR_IRQ                 _IOW('I',0xC,int)
+#define IPU_FREE_IRQ                  _IOW('I',0xD,ipu_irq_info)
+#define IPU_REQUEST_IRQ_STATUS        _IOW('I',0xE,int)
+#define IPU_SDC_INIT_PANEL            _IOW('I',0xF,ipu_sdc_panel_info)
+#define IPU_SDC_SET_WIN_POS           _IOW('I',0x10,ipu_sdc_window_pos)
+#define IPU_SDC_SET_GLOBAL_ALPHA      _IOW('I',0x11,ipu_sdc_global_alpha)
+#define IPU_SDC_SET_COLOR_KEY         _IOW('I',0x12,ipu_sdc_color_key)
+#define IPU_SDC_SET_BRIGHTNESS        _IOW('I',0x13,int)
+#define IPU_ADC_WRITE_TEMPLATE        _IOW('I',0x14,ipu_adc_template)
+#define IPU_ADC_UPDATE                _IOW('I',0x15,ipu_adc_update)
+#define IPU_ADC_SNOOP                 _IOW('I',0x16,ipu_adc_snoop)
+#define IPU_ADC_CMD                   _IOW('I',0x17,ipu_adc_cmd)
+#define IPU_ADC_INIT_PANEL            _IOW('I',0x18,ipu_adc_panel)
+#define IPU_ADC_IFC_TIMING            _IOW('I',0x19,ipu_adc_ifc_timing)
+#define IPU_CSI_INIT_INTERFACE        _IOW('I',0x1A,ipu_csi_interface)
+#define IPU_CSI_ENABLE_MCLK           _IOW('I',0x1B,ipu_csi_mclk)
+#define IPU_CSI_READ_MCLK_FLAG        _IOR('I',0x1C,ipu_csi_mclk)
+#define IPU_CSI_FLASH_STROBE          _IOW('I',0x1D,ipu_csi_mclk)
+#define IPU_CSI_GET_WIN_SIZE          _IOR('I',0x1E,ipu_csi_window_size)
+#define IPU_CSI_SET_WIN_SIZE          _IOW('I',0x1F,ipu_csi_window_size)
+#define IPU_CSI_SET_WINDOW            _IOW('I',0x20,ipu_csi_window)
+#define IPU_PF_SET_PAUSE_ROW          _IOW('I',0x21, uint32_t)
+#define IPU_REGISTER_GENERIC_ISR      _IOW('I',0x22,ipu_event_info)
+#define IPU_GET_EVENT                 _IOR('I',0x23,ipu_event_info)
+#define IPU_ALOC_MEM		      _IOWR('I', 0x24, ipu_mem_info)
+#define IPU_FREE_MEM		      _IOW('I', 0x25, ipu_mem_info)
+
+#endif
diff --git a/include/linux/mxc_asrc.h b/include/linux/mxc_asrc.h
new file mode 100644
index 0000000..894b53b
--- /dev/null
+++ b/include/linux/mxc_asrc.h
@@ -0,0 +1,198 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mx35_asrc.h
+ *
+ * @brief MX35 Asynchronous Sample Rate Converter
+ *
+ * @ingroup ??
+ */
+
+#ifndef __MXC_ASRC_H__
+#define __MXC_ASRC_H__
+
+#define ASRC_IOC_MAGIC	'C'
+
+#define ASRC_REQ_PAIR	_IOWR(ASRC_IOC_MAGIC, 0, struct asrc_req)
+#define ASRC_CONIFG_PAIR	_IOWR(ASRC_IOC_MAGIC, 1, struct asrc_config)
+#define ASRC_RELEASE_PAIR	_IOW(ASRC_IOC_MAGIC, 2, enum asrc_pair_index)
+#define ASRC_QUERYBUF	_IOWR(ASRC_IOC_MAGIC, 3, struct asrc_buffer)
+#define ASRC_Q_INBUF	_IOW(ASRC_IOC_MAGIC, 4, struct asrc_buffer)
+#define ASRC_DQ_INBUF	_IOW(ASRC_IOC_MAGIC, 5, struct asrc_buffer)
+#define ASRC_Q_OUTBUF	_IOW(ASRC_IOC_MAGIC, 6, struct asrc_buffer)
+#define ASRC_DQ_OUTBUF	_IOW(ASRC_IOC_MAGIC, 7, struct asrc_buffer)
+#define ASRC_START_CONV	_IOW(ASRC_IOC_MAGIC, 8, enum asrc_pair_index)
+#define ASRC_STOP_CONV	_IOW(ASRC_IOC_MAGIC, 9, enum asrc_pair_index)
+
+enum asrc_pair_index {
+	ASRC_PAIR_A,
+	ASRC_PAIR_B,
+	ASRC_PAIR_C
+};
+
+enum asrc_inclk {
+	INCLK_NONE = 0x03,
+	INCLK_ESAI_RX = 0x00,
+	INCLK_SSI1_RX = 0x01,
+	INCLK_SSI2_RX = 0x02,
+	INCLK_SPDIF_RX = 0x04,
+	INCLK_MLB_CLK = 0x05,
+	INCLK_ESAI_TX = 0x08,
+	INCLK_SSI1_TX = 0x09,
+	INCLK_SSI2_TX = 0x0a,
+	INCLK_SPDIF_TX = 0x0c,
+	INCLK_ASRCK1_CLK = 0x0f,
+};
+
+enum asrc_outclk {
+	OUTCLK_NONE = 0x03,
+	OUTCLK_ESAI_TX = 0x00,
+	OUTCLK_SSI1_TX = 0x01,
+	OUTCLK_SSI2_TX = 0x02,
+	OUTCLK_SPDIF_TX = 0x04,
+	OUTCLK_MLB_CLK = 0x05,
+	OUTCLK_ESAI_RX = 0x08,
+	OUTCLK_SSI1_RX = 0x09,
+	OUTCLK_SSI2_RX = 0x0a,
+	OUTCLK_SPDIF_RX = 0x0c,
+	OUTCLK_ASRCK1_CLK = 0x0f,
+};
+
+struct asrc_config {
+	enum asrc_pair_index pair;
+	unsigned int channel_num;
+	unsigned int buffer_num;
+	unsigned int dma_buffer_size;
+	unsigned int input_sample_rate;
+	unsigned int output_sample_rate;
+	enum asrc_inclk inclk;
+	enum asrc_outclk outclk;
+};
+
+struct asrc_pair {
+	unsigned int start_channel;
+	unsigned int chn_num;
+	unsigned int chn_max;
+	unsigned int active;
+};
+
+struct asrc_req {
+	unsigned int chn_num;
+	enum asrc_pair_index index;
+};
+
+struct asrc_querybuf {
+	unsigned int buffer_index;
+	unsigned int input_length;
+	unsigned int output_length;
+	unsigned long input_offset;
+	unsigned long output_offset;
+};
+
+struct asrc_buffer {
+	unsigned int index;
+	unsigned int length;
+};
+
+#ifdef __KERNEL__
+
+#define ASRC_DMA_BUFFER_NUM 8
+
+#define ASRC_ASRCTR_REG 	0x00
+#define ASRC_ASRIER_REG 	0x04
+#define ASRC_ASRCNCR_REG 	0x0C
+#define ASRC_ASRCFG_REG 	0x10
+#define ASRC_ASRCSR_REG 	0x14
+#define ASRC_ASRCDR1_REG 	0x18
+#define ASRC_ASRCDR2_REG 	0x1C
+#define ASRC_ASRSTR_REG 	0x20
+#define ASRC_ASRRA_REG 		0x24
+#define ASRC_ASRRB_REG 		0x28
+#define ASRC_ASRRC_REG 		0x2C
+#define ASRC_ASRPM1_REG 	0x40
+#define ASRC_ASRPM2_REG 	0x44
+#define ASRC_ASRPM3_REG 	0x48
+#define ASRC_ASRPM4_REG 	0x4C
+#define ASRC_ASRPM5_REG 	0x50
+#define ASRC_ASRTFR1		0x54
+#define ASRC_ASRCCR_REG 	0x5C
+#define ASRC_ASRDIA_REG 	0x60
+#define ASRC_ASRDOA_REG 	0x64
+#define ASRC_ASRDIB_REG 	0x68
+#define ASRC_ASRDOB_REG 	0x6C
+#define ASRC_ASRDIC_REG 	0x70
+#define ASRC_ASRDOC_REG 	0x74
+#define ASRC_ASRIDRHA_REG 	0x80
+#define ASRC_ASRIDRLA_REG 	0x84
+#define ASRC_ASRIDRHB_REG 	0x88
+#define ASRC_ASRIDRLB_REG 	0x8C
+#define ASRC_ASRIDRHC_REG 	0x90
+#define ASRC_ASRIDRLC_REG 	0x94
+#define ASRC_ASR76K_REG 	0x98
+#define ASRC_ASR56K_REG 	0x9C
+
+struct dma_block {
+	unsigned int index;
+	unsigned int length;
+	unsigned char *dma_vaddr;
+	dma_addr_t dma_paddr;
+	struct list_head queue;
+};
+
+struct asrc_pair_params {
+	enum asrc_pair_index index;
+	struct list_head input_queue;
+	struct list_head input_done_queue;
+	struct list_head output_queue;
+	struct list_head output_done_queue;
+	wait_queue_head_t input_wait_queue;
+	wait_queue_head_t output_wait_queue;
+	unsigned int input_counter;
+	unsigned int output_counter;
+	unsigned int input_queue_empty;
+	unsigned int output_queue_empty;
+	unsigned int input_dma_channel;
+	unsigned int output_dma_channel;
+	unsigned int input_buffer_size;
+	unsigned int output_buffer_size;
+	unsigned int buffer_num;
+	unsigned int pair_hold;
+	unsigned int asrc_active;
+	struct dma_block input_dma[ASRC_DMA_BUFFER_NUM];
+	struct dma_block output_dma[ASRC_DMA_BUFFER_NUM];
+	struct semaphore busy_lock;
+};
+
+struct asrc_data {
+	struct asrc_pair asrc_pair[3];
+};
+
+char *asrc_pair_id[] = {
+	[0] = "ASRC RX PAIR A",
+	[1] = "ASRC TX PAIR A",
+	[2] = "ASRC RX PAIR B",
+	[3] = "ASRC TX PAIR B",
+	[4] = "ASRC RX PAIR C",
+	[5] = "ASRC TX PAIR C",
+};
+
+extern int asrc_req_pair(int chn_num, enum asrc_pair_index *index);
+extern void asrc_release_pair(enum asrc_pair_index index);
+extern int asrc_config_pair(struct asrc_config *config);
+extern void asrc_start_conv(enum asrc_pair_index index);
+extern void asrc_stop_conv(enum asrc_pair_index index);
+
+#endif				/* __kERNEL__ */
+
+#endif				/* __MXC_ASRC_H__ */
diff --git a/include/linux/mxc_mlb.h b/include/linux/mxc_mlb.h
new file mode 100644
index 0000000..b38ad8c
--- /dev/null
+++ b/include/linux/mxc_mlb.h
@@ -0,0 +1,51 @@
+/*
+ * mxc_mlb.h
+ *
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef _MXC_MLB_H
+#define _MXC_MLB_H
+
+/* define IOCTL command */
+#define MLB_SET_FPS		_IOW('S', 0x10, unsigned int)
+#define MLB_GET_VER		_IOR('S', 0x11, unsigned long)
+#define MLB_SET_DEVADDR		_IOR('S', 0x12, unsigned char)
+/*!
+ * set channel address for each logical channel
+ * the MSB 16bits is for tx channel, the left LSB is for rx channel
+ */
+#define MLB_CHAN_SETADDR	_IOW('S', 0x13, unsigned int)
+#define MLB_CHAN_STARTUP	_IO('S', 0x14)
+#define MLB_CHAN_SHUTDOWN	_IO('S', 0x15)
+#define MLB_CHAN_GETEVENT	_IOR('S', 0x16, unsigned long)
+
+/*!
+ * MLB event define
+ */
+enum {
+	MLB_EVT_TX_PROTO_ERR_CUR = 1 << 0,
+	MLB_EVT_TX_BRK_DETECT_CUR = 1 << 1,
+	MLB_EVT_TX_PROTO_ERR_PREV = 1 << 8,
+	MLB_EVT_TX_BRK_DETECT_PREV = 1 << 9,
+	MLB_EVT_RX_PROTO_ERR_CUR = 1 << 16,
+	MLB_EVT_RX_BRK_DETECT_CUR = 1 << 17,
+	MLB_EVT_RX_PROTO_ERR_PREV = 1 << 24,
+	MLB_EVT_RX_BRK_DETECT_PREV = 1 << 25,
+};
+
+#ifdef __KERNEL__
+extern void gpio_mlb_active(void);
+extern void gpio_mlb_inactive(void);
+#endif
+
+#endif				/* _MXC_MLB_H */
diff --git a/include/linux/mxc_pf.h b/include/linux/mxc_pf.h
new file mode 100644
index 0000000..6d38642
--- /dev/null
+++ b/include/linux/mxc_pf.h
@@ -0,0 +1,125 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+/*!
+ * @defgroup MXC_PF MPEG4/H.264 Post Filter Driver
+ */
+/*!
+ * @file arch-mxc/mxc_pf.h
+ *
+ * @brief MXC IPU MPEG4/H.264 Post-filtering driver
+ *
+ * User-level API for IPU Hardware MPEG4/H.264 Post-filtering.
+ *
+ * @ingroup MXC_PF
+ */
+#ifndef __INCLUDED_MXC_PF_H__
+#define __INCLUDED_MXC_PF_H__
+
+#define PF_MAX_BUFFER_CNT       17
+
+#define PF_WAIT_Y	0x0001
+#define PF_WAIT_U	0x0002
+#define PF_WAIT_V	0x0004
+#define PF_WAIT_ALL	(PF_WAIT_Y|PF_WAIT_U|PF_WAIT_V)
+
+/*!
+ * Structure for Post Filter initialization parameters.
+ */
+typedef struct {
+	uint16_t pf_mode;	/*!< Post filter operation mode */
+	uint16_t width;		/*!< Width of frame in pixels */
+	uint16_t height;	/*!< Height of frame in pixels */
+	uint16_t stride;	/*!< Stride of Y plane in pixels. Stride for U and V planes is half Y stride */
+	uint32_t qp_size;
+	unsigned long qp_paddr;
+} pf_init_params;
+
+/*!
+ * Structure for Post Filter buffer request parameters.
+ */
+typedef struct {
+	int count;		/*!< Number of buffers requested */
+	__u32 req_size;
+} pf_reqbufs_params;
+
+/*!
+ * Structure for Post Filter buffer request parameters.
+ */
+typedef struct {
+	int index;
+	int size;		/*!< Size of buffer allocated */
+	__u32 offset;		/*!< Buffer offset in driver memory. Set by QUERYBUF */
+	__u32 y_offset;		/*!< Optional starting relative offset of Y data
+				   from beginning of buffer. Set to 0 to use default
+				   calculated based on height and stride */
+	__u32 u_offset;		/*!< Optional starting relative offset of U data
+				   from beginning of buffer. Set to 0 to use default
+				   calculated based on height and stride */
+	__u32 v_offset;		/*!< Optional starting relative offset of V data
+				   from beginning of buffer. Set to 0 to use default
+				   calculated based on height and stride */
+} pf_buf;
+
+/*!
+ * Structure for Post Filter start parameters.
+ */
+typedef struct {
+	pf_buf in;		/*!< Input buffer address and offsets */
+	pf_buf out;		/*!< Output buffer address and offsets */
+	int qp_buf;
+	int wait;
+	uint32_t h264_pause_row;	/*!< Row to pause at for H.264 mode. 0 to disable pause */
+} pf_start_params;
+
+/*! @name User Client Ioctl Interface */
+/*! @{ */
+
+/*!
+ * IOCTL to Initialize the Post Filter.
+ */
+#define PF_IOCTL_INIT           _IOW('F',0x0, pf_init_params)
+
+/*!
+ * IOCTL to Uninitialize the Post Filter.
+ */
+#define PF_IOCTL_UNINIT         _IO('F',0x1)
+
+/*!
+ * IOCTL to set the buffer mode and allocate buffers if driver allocated.
+ */
+#define PF_IOCTL_REQBUFS        _IOWR('F',0x2, pf_reqbufs_params)
+
+/*!
+ * IOCTL to set the buffer mode and allocate buffers if driver allocated.
+ */
+#define PF_IOCTL_QUERYBUF       _IOR('F',0x2, pf_buf)
+
+/*!
+ * IOCTL to start post filtering on a frame of data. This ioctl may block until
+ * processing is done or return immediately.
+ */
+#define PF_IOCTL_START          _IOWR('F',0x3, pf_start_params)
+
+/*!
+ * IOCTL to resume post-filtering after an intra frame pause in H.264 mode.
+ */
+#define PF_IOCTL_RESUME         _IOW('F',0x4, int)
+
+/*!
+ * IOCTL to wait for post-filtering to complete.
+ */
+#define PF_IOCTL_WAIT           _IOW('F',0x5, int)
+/*! @} */
+
+#endif				/* __INCLUDED_MXC_PF_H__ */
diff --git a/include/linux/mxc_scc2_driver.h b/include/linux/mxc_scc2_driver.h
new file mode 100644
index 0000000..f8a24f2
--- /dev/null
+++ b/include/linux/mxc_scc2_driver.h
@@ -0,0 +1,973 @@
+
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef SCC_DRIVER_H
+#define SCC_DRIVER_H
+
+/*
+ * NAMING CONVENTIONS
+ * ==================
+ * (A note to maintainers and other interested parties)
+ *
+ * Use scc_ or SCC_ prefix for 'high-level' interface routines and the types
+ * passed to those routines.  Try to avoid #defines in these interfaces.
+ *
+ * Use SMN_ or SCM_ prefix for the #defines used with scc_read_register() and
+ * scc_write_register, or values passed/retrieved from those routines.
+ */
+
+/*! @file mxc_scc2_driver.h
+ *
+ * @brief (Header file to use the SCC2 driver.)
+ *
+ * The SCC2 driver is available to other kernel modules directly.  Secure
+ * Partition functionality is extended to users through the SHW API.  Other
+ * functionality of the SCC2 is limited to kernel-space users.
+ *
+ * With the exception of #scc_monitor_security_failure(), all routines are
+ * 'synchronous', i.e. they will not return to their caller until the requested
+ * action is complete, or fails to complete.  Some of these functions could
+ * take quite a while to perform, depending upon the request.
+ *
+ * Routines are provided to:
+ * @li trigger a security-violation alarm - #scc_set_sw_alarm()
+ * @li get configuration and version information - #scc_get_configuration()
+ * @li zeroize memory - #scc_zeroize_memories()
+ * @li Work with secure partitions: #scc_allocate_partition()
+ *     #scc_engage_partition() #scc_diminish_permissions() 
+ *     #scc_release_partition()
+ * @li Encrypt or decrypt regions of data: #scc_encrypt_region()
+ *     #scc_decrypt_region()
+ * @li monitor the Security Failure alarm - #scc_monitor_security_failure()
+ * @li stop monitoring Security Failure alarm -
+ *     #scc_stop_monitoring_security_failure()
+ * @li write registers of the SCC - #scc_write_register()
+ * @li read registers of the SCC - #scc_read_register()
+ *
+ * The SCC2 encrypts and decrypts using Triple DES with an internally stored
+ * key.  When the SCC2 is in Secure mode, it uses its secret, unique-per-chip
+ * key.  When it is in Non-Secure mode, it uses a default key.  This ensures
+ * that secrets stay secret if the SCC2 is not in Secure mode.
+ *
+ * Not all functions that could be provided in a 'high level' manner have been
+ * implemented.  Among the missing are interfaces to the ASC/AIC components and
+ * the timer functions.  These and other features must be accessed through
+ * #scc_read_register() and #scc_write_register(), using the @c \#define values
+ * provided.
+ *
+ * Here is a glossary of acronyms used in the SCC2 driver documentation:
+ * - CBC - Cipher Block Chaining.  A method of performing a block cipher.
+ *    Each block is encrypted using some part of the result of the previous
+ *    block's encryption.  It needs an 'initialization vector' to seed the
+ *    operation.
+ * - ECB - Electronic Code Book.  A method of performing a block cipher.
+ *    With a given key, a given block will always encrypt to the same value.
+ * - DES - Data Encryption Standard.  (8-byte) Block cipher algorithm which
+ *    uses 56-bit keys.  In SCC2, this key is constant and unique to the device.
+ *    SCC uses the "triple DES" form of this algorithm.
+ * - AIC - Algorithm Integrity Checker.
+ * - ASC - Algorithm Sequence Checker.
+ * - SMN - Security Monitor.  The part of the SCC2 responsible for monitoring
+ *    for security problems and notifying the CPU and other PISA components.
+ * - SCM - Secure Memory.  The part of the SCC2 which handles the cryptography.
+ * - SCC - Security Controller.  Central security mechanism for PISA.
+ * - PISA - Platform-Independent Security Architecture.
+ */
+
+/* Temporarily define compile-time flags to make Doxygen happy. */
+#ifdef DOXYGEN_HACK
+/** @defgroup scccompileflags SCC Driver compile-time flags
+ *
+ * These preprocessor flags should be set, if desired, in a makefile so
+ * that they show up on the compiler command line.
+ */
+/** @addtogroup scccompileflags */
+
+/** @{ */
+/**
+ * Compile-time flag to change @ref smnregs and @ref scmregs
+ * offset values for the SCC's implementation on the MX.21 board.
+ *
+ * This must also be set properly for any code which calls the
+ * scc_read_register() or scc_write_register() functions or references the
+ * register offsets.
+ */
+#define TAHITI
+/** @} */
+#undef TAHITI
+
+#endif				/* DOXYGEN_HACK */
+
+/*! Major Version of the driver.  Used for
+    scc_configuration->driver_major_version */
+#define SCC_DRIVER_MAJOR_VERSION    2
+/*! Old Minor Version of the driver. */
+#define SCC_DRIVER_MINOR_VERSION_0    0
+/*! Minor Version of the driver.  Used for
+    scc_configuration->driver_minor_version */
+#define SCC_DRIVER_MINOR_VERSION_2    2
+
+
+/*!
+ *  Interrupt line number of SCM interrupt.
+ */
+#define INT_SCC_SCM         MXC_INT_SCC_SCM
+
+/*!
+ *  Interrupt line number of the SMN interrupt.
+ */
+#define INT_SCC_SMN         MXC_INT_SCC_SMN
+
+/**
+ * @typedef scc_return_t
+ */
+/** Common status return values from SCC driver functions. */
+	typedef enum scc_return_t {
+		SCC_RET_OK = 0,	 /**< Function succeeded  */
+		SCC_RET_FAIL,	 /**< Non-specific failure */
+		SCC_RET_VERIFICATION_FAILED,
+				 /**< Decrypt validation failed */
+		SCC_RET_TOO_MANY_FUNCTIONS,
+				 /**< At maximum registered functions */
+		SCC_RET_BUSY,	 /**< SCC is busy and cannot handle request */
+		/**< Encryption or decryption failed because@c count_out_bytes
+			says that @c data_out is too small to hold the value. */
+		SCC_RET_INSUFFICIENT_SPACE,
+	} scc_return_t;
+
+/**
+ * @typedef scc_partition_status_t
+ */
+/** Partition status information. */
+	typedef enum scc_partition_status_t {
+		SCC_PART_S_UNUSABLE,
+				  /**< Partition not implemented */
+		SCC_PART_S_UNAVAILABLE,
+				  /**< Partition owned by other host */
+		SCC_PART_S_AVAILABLE,
+				  /**< Partition available */
+		SCC_PART_S_ALLOCATED,
+				  /**< Partition owned by host but not engaged*/
+		SCC_PART_S_ENGAGED,
+				  /**< Partition owned by host and engaged */
+	} scc_partition_status_t;
+
+/**
+ * Configuration information about SCC and the driver.
+ *
+ * This struct/typedef contains information from the SCC and the driver to
+ * allow the user of the driver to determine the size of the SCC's memories and
+ * the version of the SCC and the driver.
+ */
+	typedef struct scc_config_t {
+		int driver_major_version;
+				/**< Major version of the SCC driver code  */
+		int driver_minor_version;
+				/**< Minor version of the SCC driver code  */
+		int scm_version; /**< Version from SCM Configuration register */
+		int smn_version; /**< Version from SMN Status register */
+		/**< Number of bytes per block of RAM; also
+			block size of the crypto algorithm. */
+		int block_size_bytes;
+		int partition_size_bytes;
+				/**< Number of bytes in each partition */
+		int partition_count;
+				/**< Number of partitions on this platform */
+	} scc_config_t;
+
+/**
+ * @typedef scc_enc_dec_t
+ */
+/**
+ * Determine whether SCC will run its cryptographic
+ * function as an encryption or decryption.
+ */
+	typedef enum scc_enc_dec_t {
+		SCC_ENCRYPT,	/**< Encrypt (from Red to Black) */
+		SCC_DECRYPT	/**< Decrypt (from Black to Red) */
+	} scc_enc_dec_t;
+
+/**
+ * @typedef scc_verify_t
+ */
+/**
+ * Tell the driver whether it is responsible for verifying the integrity of a
+ * secret.  During an encryption, using other than #SCC_VERIFY_MODE_NONE will
+ * cause a check value to be generated and appended to the plaintext before
+ * encryption.  During decryption, the check value will be verified after
+ * decryption, and then stripped from the message.
+ */
+	typedef enum scc_verify_t {
+    /** No verification value added or checked.  Input plaintext data must be
+     *  be a multiple of the blocksize (#scc_get_configuration()).  */
+		SCC_VERIFY_MODE_NONE,
+    /** Driver will generate/validate a 2-byte CCITT CRC.  Input plaintext
+    		will be padded to a multiple of the blocksize, adding 3-10 bytes
+    		to the resulting output ciphertext.  Upon decryption, this padding
+    		will be stripped, and the CRC will be verified. */
+		SCC_VERIFY_MODE_CCITT_CRC
+	} scc_verify_t;
+
+/**
+ * @typedef scc_cypher_mode_t
+ */
+/**
+ * Select the cypher mode to use for partition cover/uncover operations.
+ */
+
+	typedef enum scc_cypher_mode_t {
+		SCC_CYPHER_MODE_ECB = 1,
+				   /**< ECB mode */
+		SCC_CYPHER_MODE_CBC = 2,
+				   /**< CBC mode */
+	} scc_cypher_mode_t;
+
+/**
+ * Allocate a partition of secure memory
+ *
+ * @param       smid_value  Value to use for the SMID register.  Must be 0 for
+ *                          kernel mode ownership.
+ * @param[out]  part_no     (If successful) Assigned partition number.
+ * @param[out]  part_base   Kernel virtual address of the partition.
+ * @param[out]  part_phys   Physical address of the partition.
+ *
+ * @return      SCC_RET_OK if successful.
+ */
+	extern scc_return_t
+	    scc_allocate_partition(uint32_t smid_value,
+				   int *part_no,
+				   void **part_base, uint32_t *part_phys);
+
+/* Note: This function has to be run in the same context (userspace or kernel
+ * mode) as the process that will be using the partition.  Because the SCC2 API
+ * is not accessible in user mode, this function is also provided as a macro in
+ * in fsl_shw.h.  Kernel-mode users that include this file are able to use this
+ * version of the function without having to include the whole SHW API.  If the
+ * macro definition was defined before we got here, un-define it so this
+ * version will be used instead.
+ */
+
+#ifdef scc_engage_partition
+#undef scc_engage_partition
+#endif
+
+/**
+ * Engage partition of secure memory
+ *
+ * @param part_base (kernel) Virtual
+ * @param UMID NULL, or 16-byte UMID for partition security
+ * @param permissions ORed values of the type SCM_PERM_* which will be used as
+ *                    initial partition permissions.  SHW API users should use
+ *                    the FSL_PERM_* definitions instead.
+ *
+ * @return SCC_RET_OK if successful.
+ */
+	extern scc_return_t
+	    scc_engage_partition(void *part_base,
+				 const uint8_t *UMID, uint32_t permissions);
+
+/**
+ * Release a partition of secure memory
+ *
+ * @param   part_base   Kernel virtual address of the partition to be released.
+ *
+ * @return  SCC_RET_OK if successful.
+ */
+	extern scc_return_t scc_release_partition(void *part_base);
+
+/**
+ * Diminish the permissions on a partition of secure memory
+ *
+ * @param part_base   Kernel virtual address of the partition.
+ *
+ * @param permissions ORed values of the type SCM_PERM_* which will be used as
+ *                    initial partition permissions.  SHW API users should use
+ *                    the FSL_PERM_* definitions instead.
+ *
+ * @return  SCC_RET_OK if successful.
+ */
+	extern scc_return_t
+	    scc_diminish_permissions(void *part_base, uint32_t permissions);
+
+/**
+ * Query the status of a partition of secure memory
+ *
+ * @param part_base   Kernel virtual address of the partition.
+ *
+ * @return  SCC_RET_OK if successful.
+ */
+	extern scc_partition_status_t scc_partition_status(void *part_base);
+
+/**
+ * Calculate the physical address from the kernel virtual address.
+ */
+	extern uint32_t scc_virt_to_phys(void *address);
+/*scc_return_t
+scc_verify_slot_access(uint64_t owner_id, uint32_t slot, uint32_t access_len);*/
+
+
+/**
+ * Encrypt a region of secure memory.
+ *
+ * @param   part_base    Kernel virtual address of the partition.
+ * @param   offset_bytes Offset from the start of the partition to the plaintext
+ *                       data.
+ * @param   byte_count   Length of the region (octets).
+ * @param   black_data   Physical location to store the encrypted data.
+ * @param   IV           Value to use for the Initialization Vector.
+ * @param   cypher_mode  Cyphering mode to use, specified by type
+ *                       #scc_cypher_mode_t
+ *
+ * @return  SCC_RET_OK if successful.
+ */
+	extern scc_return_t
+	    scc_encrypt_region(uint32_t part_base, uint32_t offset_bytes,
+			       uint32_t byte_count, uint8_t *black_data,
+			       uint32_t *IV, scc_cypher_mode_t cypher_mode);
+
+/**
+ * Decrypt a region into secure memory
+ *
+ * @param   part_base    Kernel virtual address of the partition.
+ * @param   offset_bytes Offset from the start of the partition to store the
+ *                       plaintext data.
+ * @param   byte_count   Length of the region (octets).
+ * @param   black_data   Physical location of the encrypted data.
+ * @param   IV           Value to use for the Initialization Vector.
+ * @param   cypher_mode  Cyphering mode to use, specified by type
+ *                       #scc_cypher_mode_t
+ *
+ * @return  SCC_RET_OK if successful.
+ */
+	extern scc_return_t
+	    scc_decrypt_region(uint32_t part_base, uint32_t offset_bytes,
+			       uint32_t byte_count, uint8_t *black_data,
+			       uint32_t *IV, scc_cypher_mode_t cypher_mode);
+
+/**
+ * Retrieve configuration information from the SCC.
+ *
+ * This function always succeeds.
+ *
+ * @return   A pointer to the configuration information.  This is a pointer to
+ *           static memory and must not be freed.  The values never change, and
+ *           the return value will never be null.
+ */
+	extern scc_config_t *scc_get_configuration(void);
+
+/**
+ * Zeroize Red and Black memories of the SCC.  This will start the Zeroizing
+ * process.  The routine will return when the memories have zeroized or failed
+ * to do so.  The driver will poll waiting for this to occur, so this
+ * routine must not be called from interrupt level.  Some future version of
+ * driver may elect instead to sleep.
+ *
+ * @return 0 or error if initialization fails.
+ */
+	extern scc_return_t scc_zeroize_memories(void);
+
+/**
+ * Signal a software alarm to the SCC.  This will take the SCC and other PISA
+ * parts out of Secure mode and into Security Failure mode.  The SCC will stay
+ * in failed mode until a reboot.
+ *
+ * @internal
+ * If the SCC is not already in fail state, simply write the
+ * #SMN_COMMAND_SET_SOFTWARE_ALARM bit in #SMN_COMMAND_REG.  Since there is no
+ * reason to wait for the interrupt to bounce back, simply act as though
+ * one did.
+ */
+	extern void scc_set_sw_alarm(void);
+
+/**
+ * This routine will register a function to be called should a Security Failure
+ * be signalled by the SCC (Security Monitor).
+ *
+ * The callback function may be called from interrupt level, it may be called
+ * from some process' task.  It should therefore not take a long time to
+ * perform its operation, and it may not sleep.
+ *
+ * @param  callback_func  Function pointer to routine which will receive
+ *                        notification of the security failure.
+ * @return         0 if function was successfully registered, non-zero on
+ *                 failure.  See #scc_return_t.
+ *
+ * @internal
+ *  There is a fixed global static array which keeps track of the requests to
+ *  monitor the failure.
+ *
+ *  Add @c callback_func to the first empty slot in #scc_callbacks[].  If there
+ *  is no room, return #SCC_RET_TOO_MANY_FUNCTIONS.
+ */
+	extern scc_return_t scc_monitor_security_failure(void
+							 callback_func(void));
+
+/**
+ * This routine will deregister a function previously registered with
+ * #scc_monitor_security_failure().
+ *
+ * @param callback_func Function pointer to routine previously registered with
+ *                      #scc_stop_monitoring_security_failure().
+ */
+	extern void scc_stop_monitoring_security_failure(void
+							 callback_func(void));
+
+/**
+ * Read value from an SCC register.
+ * The offset will be checked for validity (range) as well as whether it is
+ * accessible (e.g. not busy, not in failed state) at the time of the call.
+ *
+ * @param[in]   register_offset  The (byte) offset within the SCC block
+ *                               of the register to be queried.  See
+ *                              @ref scmregs and @ref smnregs.
+ * @param[out]  value            Pointer to where value from the register
+ *                               should be placed.
+ * @return      0 if OK, non-zero on error.  See #scc_return_t.
+ *
+ * @internal
+ *  Verify that the register_offset is a) valid, b) refers to a readable
+ *  register, and c) the SCC is in a state which would allow a read of this
+ *  register.
+ */
+	extern scc_return_t scc_read_register(int register_offset,
+					      uint32_t * value);
+
+/**
+ * Write a new value into an SCC register.
+ * The offset will be checked for validity (range) as well as whether it is
+ * accessible (e.g. not busy, not in failed state) at the time of the call.
+ *
+ * @param[in]  register_offset  The (byte) offset within the SCC block
+ *                              of the register to be modified.  See
+ *                              @ref scmregs and @ref smnregs
+ * @param[in]  value            The value to store into the register.
+ * @return     0 if OK, non-zero on error.  See #scc_return_t.
+ *
+ * @internal
+ *  Verify that the register_offset is a) valid, b) refers to a writeable
+ *  register, and c) the SCC is in a state which would allow a write to this
+ *  register.
+ */
+	extern scc_return_t scc_write_register(int register_offset,
+					       uint32_t value);
+
+/**
+ * @defgroup scmregs SCM Registers
+ *
+ * These values are offsets into the SCC for the Secure Memory
+ * (SCM) registers.  They are used in the @c register_offset parameter of
+ * #scc_read_register() and #scc_write_register().
+ */
+/** @addtogroup scmregs */
+/** @{ */
+/** Offset of SCM Version ID Register */
+#define SCM_VERSION_REG		0x000
+/** Offset of SCM Interrupt Control Register */
+#define SCM_INT_CTL_REG		0x008
+/** Offset of SCM Status Register */
+#define SCM_STATUS_REG		0x00c
+/** Offset of SCM Error Status Register */
+#define SCM_ERR_STATUS_REG	0x010
+/** Offset of SCM Fault Address Register */
+#define SCM_FAULT_ADR_REG	0x014
+/** Offset of SCM Partition Owners Register */
+#define SCM_PART_OWNERS_REG	0x018
+/** Offset of SCM Partitions Engaged Register */
+#define SCM_PART_ENGAGED_REG	0x01c
+/** Offset of SCM Unique Number 0 Register */
+#define SCM_UNIQUE_ID0_REG	0x020
+/** Offset of SCM Unique Number 1 Register */
+#define SCM_UNIQUE_ID1_REG	0x024
+/** Offset of SCM Unique Number 2 Register */
+#define SCM_UNIQUE_ID2_REG	0x028
+/** Offset of SCM Unique Number 3 Register */
+#define SCM_UNIQUE_ID3_REG	0x02c
+/** Offset of SCM Zeroize Command Register */
+#define SCM_ZCMD_REG		0x050
+/** Offset of SCM Cipher Command Register */
+#define SCM_CCMD_REG		0x054
+/** Offset of SCM Cipher Black RAM Start Address Register */
+#define SCM_C_BLACK_ST_REG	0x058
+/** Offset of SCM Internal Debug Register */
+#define SCM_DBG_STATUS_REG	0x05c
+/** Offset of SCM Cipher IV 0 Register */
+#define SCM_AES_CBC_IV0_REG	0x060
+/** Offset of SCM Cipher IV 1 Register */
+#define SCM_AES_CBC_IV1_REG	0x064
+/** Offset of SCM Cipher IV 2 Register */
+#define SCM_AES_CBC_IV2_REG	0x068
+/** Offset of SCM Cipher IV 3 Register */
+#define SCM_AES_CBC_IV3_REG	0x06c
+/** Offset of SCM SMID Partition 0 Register */
+#define SCM_SMID0_REG		0x080
+/** Offset of SCM Partition 0 Access Permissions Register */
+#define SCM_ACC0_REG		0x084
+/** Offset of SCM SMID Partition 1 Register */
+#define SCM_SMID1_REG		0x088
+/** Offset of SCM Partition 1 Access Permissions Register */
+#define SCM_ACC1_REG		0x08c
+/** Offset of SCM SMID Partition 2 Register */
+#define SCM_SMID2_REG		0x090
+/** Offset of SCM Partition 2 Access Permissions Register */
+#define SCM_ACC2_REG		0x094
+/** Offset of SCM SMID Partition 3 Register */
+#define SCM_SMID3_REG		0x098
+/** Offset of SCM Partition 3 Access Permissions Register */
+#define SCM_ACC3_REG		0x09c
+/** Offset of SCM SMID Partition 4 Register */
+#define SCM_SMID4_REG		0x0a0
+/** Offset of SCM Partition 4 Access Permissions Register */
+#define SCM_ACC4_REG		0x0a4
+/** Offset of SCM SMID Partition 5 Register */
+#define SCM_SMID5_REG		0x0a8
+/** Offset of SCM Partition 5 Access Permissions Register */
+#define SCM_ACC5_REG		0x0ac
+/** Offset of SCM SMID Partition 6 Register */
+#define SCM_SMID6_REG		0x0b0
+/** Offset of SCM Partition 6 Access Permissions Register */
+#define SCM_ACC6_REG		0x0b4
+/** Offset of SCM SMID Partition 7 Register */
+#define SCM_SMID7_REG		0x0b8
+/** Offset of SCM Partition 7 Access Permissions Register */
+#define SCM_ACC7_REG		0x0bc
+/** Offset of SCM SMID Partition 8 Register */
+#define SCM_SMID8_REG		0x0c0
+/** Offset of SCM Partition 8 Access Permissions Register */
+#define SCM_ACC8_REG		0x0c4
+/** Offset of SCM SMID Partition 9 Register */
+#define SCM_SMID9_REG		0x0c8
+/** Offset of SCM Partition 9 Access Permissions Register */
+#define SCM_ACC9_REG		0x0cc
+/** Offset of SCM SMID Partition 10 Register */
+#define SCM_SMID10_REG		0x0d0
+/** Offset of SCM Partition 10 Access Permissions Register */
+#define SCM_ACC10_REG		0x0d4
+/** Offset of SCM SMID Partition 11 Register */
+#define SCM_SMID11_REG		0x0d8
+/** Offset of SCM Partition 11 Access Permissions Register */
+#define SCM_ACC11_REG		0x0dc
+/** Offset of SCM SMID Partition 12 Register */
+#define SCM_SMID12_REG		0x0e0
+/** Offset of SCM Partition 12 Access Permissions Register */
+#define SCM_ACC12_REG		0x0e4
+/** Offset of SCM SMID Partition 13 Register */
+#define SCM_SMID13_REG		0x0e8
+/** Offset of SCM Partition 13 Access Permissions Register */
+#define SCM_ACC13_REG		0x0ec
+/** Offset of SCM SMID Partition 14 Register */
+#define SCM_SMID14_REG		0x0f0
+/** Offset of SCM Partition 14 Access Permissions Register */
+#define SCM_ACC14_REG		0x0f4
+/** Offset of SCM SMID Partition 15 Register */
+#define SCM_SMID15_REG		0x0f8
+/** Offset of SCM Partition 15 Access Permissions Register */
+#define SCM_ACC15_REG		0x0fc
+/** @} */
+
+/** Number of bytes of register space for the SCM. */
+#define SCM_REG_BANK_SIZE	0x100
+
+/** Number of bytes of register space for the SCM. */
+#define SCM_REG_BANK_SIZE	0x100
+
+/** Offset of the SMN registers */
+#define SMN_ADDR_OFFSET		0x100
+
+/**
+ * @defgroup smnregs SMN Registers
+ *
+ * These values are offsets into the SCC for the Security Monitor
+ * (SMN) registers.  They are used in the @c register_offset parameter of the
+ * #scc_read_register() and #scc_write_register().
+ */
+/** @addtogroup smnregs */
+/** @{ */
+/** Offset of SMN Status Register */
+#define SMN_STATUS_REG		(SMN_ADDR_OFFSET+0x00000000)
+/** Offset of SMH Command Register */
+#define SMN_COMMAND_REG		(SMN_ADDR_OFFSET+0x00000004)
+/** Offset of SMH Sequence Start Register */
+#define SMN_SEQ_START_REG	(SMN_ADDR_OFFSET+0x00000008)
+/** Offset of SMH Sequence End Register */
+#define SMN_SEQ_END_REG		(SMN_ADDR_OFFSET+0x0000000c)
+/** Offset of SMH Sequence Check Register */
+#define SMN_SEQ_CHECK_REG	(SMN_ADDR_OFFSET+0x00000010)
+/** Offset of SMH BitBank Count Register */
+#define SMN_BB_CNT_REG		(SMN_ADDR_OFFSET+0x00000014)
+/** Offset of SMH BitBank Increment Register */
+#define SMN_BB_INC_REG		(SMN_ADDR_OFFSET+0x00000018)
+/** Offset of SMH BitBank Decrement Register */
+#define SMN_BB_DEC_REG		(SMN_ADDR_OFFSET+0x0000001c)
+/** Offset of SMH Compare Register */
+#define SMN_COMPARE_REG		(SMN_ADDR_OFFSET+0x00000020)
+/** Offset of SMH Plaintext Check Register */
+#define SMN_PT_CHK_REG		(SMN_ADDR_OFFSET+0x00000024)
+/** Offset of SMH Ciphertext Check Register */
+#define SMN_CT_CHK_REG		(SMN_ADDR_OFFSET+0x00000028)
+/** Offset of SMH Timer Initial Value Register */
+#define SMN_TIMER_IV_REG	(SMN_ADDR_OFFSET+0x0000002c)
+/** Offset of SMH Timer Control Register */
+#define SMN_TIMER_CTL_REG	(SMN_ADDR_OFFSET+0x00000030)
+/** Offset of SMH Security Violation Register */
+#define SMN_SEC_VIO_REG		(SMN_ADDR_OFFSET+0x00000034)
+/** Offset of SMH Timer Register */
+#define SMN_TIMER_REG		(SMN_ADDR_OFFSET+0x00000038)
+/** Offset of SMH High-Assurance Control Register */
+#define SMN_HAC_REG		(SMN_ADDR_OFFSET+0x0000003c)
+/** Number of bytes allocated to the SMN registers */
+#define SMN_REG_BANK_SIZE	0x40
+/** @} */
+
+/** Number of bytes of total register space for the SCC. */
+#define SCC_ADDRESS_RANGE	(SMN_ADDR_OFFSET + SMN_REG_BANK_SIZE)
+
+/**
+ * @defgroup smnstatusregdefs SMN Status Register definitions (SMN_STATUS)
+ */
+/** @addtogroup smnstatusregdefs */
+/** @{ */
+/** SMN version id. */
+#define SMN_STATUS_VERSION_ID_MASK        0xfc000000
+/**  number of bits to shift #SMN_STATUS_VERSION_ID_MASK to get it to LSB */
+#define SMN_STATUS_VERSION_ID_SHIFT       28
+/** Illegal bus master access attempted. */
+#define SMN_STATUS_ILLEGAL_MASTER         0x01000000
+/** Scan mode entered/exited since last reset. */
+#define SMN_STATUS_SCAN_EXIT              0x00800000
+/** Some security peripheral is initializing */
+#define SMN_STATUS_PERIP_INIT             0x00010000
+/** Internal error detected in SMN. */
+#define SMN_STATUS_SMN_ERROR              0x00008000
+/** SMN has an outstanding interrupt. */
+#define SMN_STATUS_SMN_STATUS_IRQ         0x00004000
+/** Software Alarm was triggered. */
+#define SMN_STATUS_SOFTWARE_ALARM         0x00002000
+/** Timer has expired. */
+#define SMN_STATUS_TIMER_ERROR            0x00001000
+/** Plaintext/Ciphertext compare failed. */
+#define SMN_STATUS_PC_ERROR               0x00000800
+/** Bit Bank detected overflow or underflow */
+#define SMN_STATUS_BITBANK_ERROR          0x00000400
+/** Algorithm Sequence Check failed. */
+#define SMN_STATUS_ASC_ERROR              0x00000200
+/** Security Policy Block detected error. */
+#define SMN_STATUS_SECURITY_POLICY_ERROR  0x00000100
+/** Security Violation Active error. */
+#define SMN_STATUS_SEC_VIO_ACTIVE_ERROR   0x00000080
+/** Processor booted from internal ROM. */
+#define SMN_STATUS_INTERNAL_BOOT          0x00000020
+/** SMN's internal state. */
+#define SMN_STATUS_STATE_MASK             0x0000001F
+/** Number of bits to shift #SMN_STATUS_STATE_MASK to get it to LSB. */
+#define SMN_STATUS_STATE_SHIFT            0
+/** @} */
+
+/**
+ * @defgroup sccscmstates SMN Model Secure State Controller States (SMN_STATE_MASK)
+ */
+/** @addtogroup sccscmstates */
+/** @{ */
+/** This is the first state of the SMN after power-on reset  */
+#define SMN_STATE_START         0x0
+/** The SMN is zeroizing its RAM during reset */
+#define SMN_STATE_ZEROIZE_RAM   0x5
+/** SMN has passed internal checks, and is waiting for Software check-in */
+#define SMN_STATE_HEALTH_CHECK  0x6
+/** Fatal Security Violation.  SMN is locked, SCM is inoperative. */
+#define SMN_STATE_FAIL          0x9
+/** SCC is in secure state.  SCM is using secret key. */
+#define SMN_STATE_SECURE        0xA
+/** Due to non-fatal error, device is not secure.  SCM is using default key. */
+#define SMN_STATE_NON_SECURE    0xC
+/** @} */
+
+/** @{ */
+/** SCM Status bit: Key Status is Default Key in Use */
+#define SCM_STATUS_KST_DEFAULT_KEY	0x80000000
+/** SCM Status bit: Key Status is (reserved) */
+#define SCM_STATUS_KST_RESERVED1	0x40000000
+/** SCM Status bit: Key status is Wrong Key */
+#define SCM_STATUS_KST_WRONG_KEY	0x20000000
+/** SCM Status bit: Bad Key detected */
+#define SCM_STATUS_KST_BAD_KEY	0x10000000
+/** SCM Status bit: Error has occurred */
+#define SCM_STATUS_ERR		0x00008000
+/** SCM Status bit: Monitor State is Failed */
+#define SCM_STATUS_MSS_FAIL	0x00004000
+/** SCM Status bit: Monitor State is Secure */
+#define SCM_STATUS_MSS_SEC	0x00002000
+/** SCM Status bit: Secure Storage is Failed */
+#define SCM_STATUS_RSS_FAIL	0x00000400
+/** SCM Status bit: Secure Storage is Secure */
+#define SCM_STATUS_RSS_SEC	0x00000200
+/** SCM Status bit: Secure Storage is Initializing */
+#define SCM_STATUS_RSS_INIT	0x00000100
+/** SCM Status bit: Unique Number Valid */
+#define SCM_STATUS_UNV		0x00000080
+/** SCM Status bit: Big Endian mode */
+#define SCM_STATUS_BIG		0x00000040
+/** SCM Status bit: Using Secret Key */
+#define SCM_STATUS_USK		0x00000020
+/** SCM Status bit: Ram is being blocked */
+#define SCM_STATUS_BAR		0x00000010
+/** Bit mask of SRS */
+#define SCM_STATUS_SRS_MASK	0x0000000F
+/** Number of bits to shift SRS to/from MSb */
+#define SCM_STATUS_SRS_SHIFT	0
+/** @} */
+
+#define SCM_STATUS_SRS_RESET	0x0	/**< Reset, Zeroise All */
+#define SCM_STATUS_SRS_READY	0x1	/**< All Ready */
+#define SCM_STATUS_SRS_ZBUSY	0x2	/**< Zeroize Busy (Partition Only) */
+#define SCM_STATUS_SRS_CBUSY	0x3	/**< Cipher Busy */
+#define SCM_STATUS_SRS_ABUSY	0x4	/**< All Busy */
+#define SCM_STATUS_SRS_ZDONE	0x5	/**< Zeroize Done, Cipher Ready */
+#define SCM_STATUS_SRS_CDONE	0x6	/**< Cipher Done, Zeroize Ready */
+#define SCM_STATUS_SRS_ZDONE2	0x7	/**< Zeroize Done, Cipher Busy */
+#define SCM_STATUS_SRS_CDONE2	0x8	/**< Cipher Done, Zeroize Busy */
+#define SCM_STATUS_SRS_ADONE	0xD	/**< All Done */
+
+/* Format of the SCM VERSION ID REGISTER */
+#define SCM_VER_BPP_MASK    0xFF000000	/**< Bytes Per Partition Mask */
+#define SCM_VER_BPP_SHIFT   24		/**< Bytes Per Partition Shift */
+#define SCM_VER_BPCB_MASK   0x001F0000	/**< Bytes Per Cipher Block Mask */
+#define SCM_VER_BPCB_SHIFT  16		/**< Bytes Per Cipher Block Shift */
+#define SCM_VER_NP_MASK     0x0000F000	/**< Number of Partitions Mask */
+#define SCM_VER_NP_SHIFT    12		/**< Number of Partitions Shift */
+#define SCM_VER_MAJ_MASK    0x00000F00	/**< Major Version Mask */
+#define SCM_VER_MAJ_SHIFT   8		/**< Major Version Shift */
+#define SCM_VER_MIN_MASK    0x000000FF	/**< Minor Version Mask */
+#define SCM_VER_MIN_SHIFT   0		/**< Minor Version Shift */
+
+/**< SCC Hardware version supported by this driver */
+#define SCM_MAJOR_VERSION_2 2
+
+/* Format of the SCM ERROR STATUS REGISTER */
+#define SCM_ERRSTAT_MID_MASK    0x00F00000  /**< Master ID Mask */
+#define SCM_ERRSTAT_MID_SHIFT   20	    /**< Master ID Shift */
+#define SCM_ERRSTAT_ILM         0x00080000  /**< Illegal Master */
+#define SCM_ERRSTAT_SUP         0x00008000  /**< Supervisor Access */
+#define SCM_ERRSTAT_ERC_MASK    0x00000F00  /**< Error Code Mask */
+#define SCM_ERRSTAT_ERC_SHIFT   8	    /**< Error Code Shift */
+#define SCM_ERRSTAT_SMS_MASK    0x000000F0  /**< Secure Monitor State Mask */
+#define SCM_ERRSTAT_SMS_SHIFT   4	    /**< Secure Monitor State Shift */
+#define SCM_ERRSTAT_SRS_MASK    0x0000000F  /**< Secure Ram State Mask */
+#define SCM_ERRSTAT_SRS_SHIFT   0	    /**< Secure Ram State Shift */
+
+/* SCM ERROR STATUS REGISTER ERROR CODES */
+#define SCM_ERCD_UNK_ADDR       0x1 /**< Unknown Address */
+#define SCM_ERCD_UNK_CMD        0x2 /**< Unknown Command */
+#define SCM_ERCD_READ_PERM      0x3 /**< Read Permission Error */
+#define SCM_ERCD_WRITE_PERM     0x4 /**< Write Permission Error */
+#define SCM_ERCD_DMA_ERROR      0x5 /**< DMA Error */
+#define SCM_ERCD_BLK_OVFL       0x6 /**< Encryption Block Length Overflow */
+#define SCM_ERCD_NO_KEY         0x7 /**< Key Not Engaged */
+#define SCM_ERCD_ZRZ_OVFL       0x8 /**< Zeroize Command Queue Overflow */
+#define SCM_ERCD_CPHR_OVFL      0x9 /**< Cipher Command Queue Overflow */
+#define SCM_ERCD_PROC_INTR      0xA /**< Process Interrupted */
+#define SCM_ERCD_WRNG_KEY       0xB /**< Wrong Key */
+#define SCM_ERCD_DEVICE_BUSY    0xC /**< Device Busy */
+#define SCM_ERCD_UNALGN_ADDR    0xD /**< DMA Unaligned Address */
+
+/* Format of the CIPHER COMMAND REGISTER */
+#define SCM_CCMD_LENGTH_MASK	0xFFF00000 /**< Cipher Length Mask */
+#define SCM_CCMD_LENGTH_SHIFT	20	   /**< Cipher Length Shift */
+#define SCM_CCMD_OFFSET_MASK	0x000FFF00 /**< Block Offset Mask */
+#define SCM_CCMD_OFFSET_SHIFT	8	   /**< Block Offset Shift */
+#define SCM_CCMD_PART_MASK	0x000000F0     /**< Partition Number Mask */
+#define SCM_CCMD_PART_SHIFT	4	       /**< Partition Number Shift */
+#define SCM_CCMD_CCMD_MASK	0x0000000F     /**< Cipher Command Mask */
+#define SCM_CCMD_CCMD_SHIFT	0	       /**< Cipher Command Shift */
+
+/* Values for SCM_CCMD_CCMD field */
+#define SCM_CCMD_AES_DEC_ECB 1 /**< Decrypt without Chaining (ECB) */
+#define SCM_CCMD_AES_ENC_ECB 3 /**< Encrypt without Chaining (ECB) */
+#define SCM_CCMD_AES_DEC_CBC 5 /**< Decrypt with Chaining (CBC) */
+#define SCM_CCMD_AES_ENC_CBC 7 /**< Encrypt with Chaining (CBC) */
+
+#define SCM_CCMD_AES     1     /**< Use AES Mode */
+#define SCM_CCMD_DEC     0     /**< Decrypt */
+#define SCM_CCMD_ENC     2     /**< Encrypt */
+#define SCM_CCMD_ECB     0     /**< Perform operation without chaining (ECB) */
+#define SCM_CCMD_CBC     4     /**< Perform operation with chaining (CBC) */
+
+/* Format of the ZEROIZE COMMAND REGISTER */
+#define SCM_ZCMD_PART_MASK	0x000000F0  /**< Target Partition Mask */
+#define SCM_ZCMD_PART_SHIFT	4	    /**< Target Partition Shift */
+#define SCM_ZCMD_CCMD_MASK	0x0000000F  /**< Zeroize Command Mask */
+#define SCM_ZCMD_CCMD_SHIFT	0	    /**< Zeroize Command Shift */
+
+/* MASTER ACCESS PERMISSIONS REGISTER */
+/* Note that API users should use the FSL_PERM_ defines instead of these */
+/** SCM Access Permission: Do not zeroize/deallocate partition
+	on SMN Fail state */
+#define SCM_PERM_NO_ZEROIZE	0x10000000
+/** SCM Access Permission: Ignore Supervisor/User mode
+	in permission determination */
+#define SCM_PERM_HD_SUP_DISABLE	0x00000800
+/** SCM Access Permission: Allow Read Access to  Host Domain */
+#define SCM_PERM_HD_READ	0x00000400
+/** SCM Access Permission: Allow Write Access to  Host Domain */
+#define SCM_PERM_HD_WRITE	0x00000200
+/** SCM Access Permission: Allow Execute Access to  Host Domain */
+#define SCM_PERM_HD_EXECUTE	0x00000100
+/** SCM Access Permission: Allow Read Access to Trusted Host Domain */
+#define SCM_PERM_TH_READ	0x00000040
+/** SCM Access Permission: Allow Write Access to Trusted Host Domain */
+#define SCM_PERM_TH_WRITE	0x00000020
+/** SCM Access Permission: Allow Read Access to Other/World Domain */
+#define SCM_PERM_OT_READ	0x00000004
+/** SCM Access Permission: Allow Write Access to Other/World Domain */
+#define SCM_PERM_OT_WRITE	0x00000002
+/** SCM Access Permission: Allow Execute Access to Other/World Domain */
+#define SCM_PERM_OT_EXECUTE	0x00000001
+/**< Valid bits that can be set in the Permissions register */
+#define SCM_PERM_MASK 0xC0000F67
+
+/* Zeroize Command register definitions */
+#define ZCMD_DEALLOC_PART 3	 /**< Deallocate Partition */
+#define Z_INT_EN	0x00000002   /**< Zero Interrupt Enable */
+
+/**
+ * @defgroup scmpartitionownersregdefs SCM Partition Owners Register
+ */
+/** @addtogroup scmpartitionownersregdefs */
+/** @{ */
+/** Number of bits to shift partition number to get to its field. */
+#define SCM_POWN_SHIFT   2
+/** Mask for a field once the register has been shifted. */
+#define SCM_POWN_MASK    3
+/** Partition is free */
+#define SCM_POWN_PART_FREE       0
+/** Partition is unable to be allocated */
+#define SCM_POWN_PART_UNUSABLE   1
+/** Partition is owned by another master */
+#define SCM_POWN_PART_OTHER      2
+/** Partition is owned by this master */
+#define SCM_POWN_PART_OWNED      3
+/** @} */
+
+/**
+ * @defgroup smnpartitionsengagedregdefs SCM Partitions Engaged Register
+ */
+/** @addtogroup smnpartitionsengagedregdefs */
+/** @{ */
+/** Number of bits to shift partition number to get to its field. */
+#define SCM_PENG_SHIFT   1
+/** Engaged value for a field once the register has been shifted. */
+#define SCM_PENG_ENGAGED    1
+/** @} */
+
+/** Number of bytes between each subsequent SMID register */
+#define SCM_SMID_WIDTH      8
+
+/**
+ * @defgroup smncommandregdefs SMN Command Register Definitions (SMN_COMMAND_REG)
+ */
+/** @addtogroup smncommandregdefs */
+/** @{ */
+
+/** These bits are unimplemented or reserved */
+#define SMN_COMMAND_ZEROS_MASK   0xfffffff0
+#define SMN_COMMAND_CLEAR_INTERRUPT     0x8 /**< Clear SMN Interrupt */
+#define SMN_COMMAND_CLEAR_BIT_BANK      0x4 /**< Clear SMN Bit Bank */
+#define SMN_COMMAND_ENABLE_INTERRUPT    0x2 /**< Enable SMN Interrupts */
+#define SMN_COMMAND_SET_SOFTWARE_ALARM  0x1 /**< Set Software Alarm */
+/** @} */
+
+/**
+ * @defgroup smntimercontroldefs SMN Timer Control Register definitions (SMN_TIMER_CONTROL)
+ */
+/** @addtogroup smntimercontroldefs */
+/** @{ */
+/** These bits are reserved or zero */
+#define SMN_TIMER_CTRL_ZEROS_MASK 0xfffffffc
+/** Load the timer from #SMN_TIMER_IV_REG */
+#define SMN_TIMER_LOAD_TIMER             0x2
+/** Setting to zero stops the Timer */
+#define SMN_TIMER_STOP_MASK              0x1
+/** Setting this value starts the timer */
+#define SMN_TIMER_START_TIMER            0x1
+/** @} */
+
+/**
+ * @defgroup scmchainmodedefs SCM_CHAINING_MODE_MASK - Bit definitions
+ */
+/** @addtogroup scmchainmodedefs */
+/** @{ */
+#define SCM_CBC_MODE            0x2 /**< Cipher block chaining */
+#define SCM_ECB_MODE            0x0 /**< Electronic codebook. */
+/** @} */
+
+/* Bit definitions in the SCM_CIPHER_MODE_MASK */
+/**
+ * @defgroup scmciphermodedefs SCM_CIPHER_MODE_MASK - Bit definitions
+ */
+/** @addtogroup scmciphermodedefs */
+/** @{ */
+#define SCM_DECRYPT_MODE        0x1 /**< decrypt from black to red memory */
+#define SCM_ENCRYPT_MODE        0x0 /**< encrypt from red to black memory */
+/** @} */
+
+/**
+ * @defgroup smndbgdetdefs SMN Debug Detector Status Register (SCM_DEBUG_DETECT_STAT)
+ */
+/** @addtogroup smndbgdetdefs */
+/** @{ */
+#define SMN_DBG_ZEROS_MASK  0xfffff000 /**< These bits are zero or reserved */
+#define SMN_DBG_D12             0x0800 /**< Error detected on Debug Port D12 */
+#define SMN_DBG_D11             0x0400 /**< Error detected on Debug Port D11 */
+#define SMN_DBG_D10             0x0200 /**< Error detected on Debug Port D10 */
+#define SMN_DBG_D9              0x0100 /**< Error detected on Debug Port D9 */
+#define SMN_DBG_D8              0x0080 /**< Error detected on Debug Port D8 */
+#define SMN_DBG_D7              0x0040 /**< Error detected on Debug Port D7 */
+#define SMN_DBG_D6              0x0020 /**< Error detected on Debug Port D6 */
+#define SMN_DBG_D5              0x0010 /**< Error detected on Debug Port D5 */
+#define SMN_DBG_D4              0x0008 /**< Error detected on Debug Port D4 */
+#define SMN_DBG_D3              0x0004 /**< Error detected on Debug Port D3 */
+#define SMN_DBG_D2              0x0002 /**< Error detected on Debug Port D2 */
+#define SMN_DBG_D1              0x0001 /**< Error detected on Debug Port D1 */
+/** @} */
+
+/** Mask for the usable bits of the Sequence Start Register
+    (#SMN_SEQ_START_REG) */
+#define SMN_SEQUENCE_START_MASK    0x0000ffff
+
+/** Mask for the usable bits of the Sequence End Register
+    (#SMN_SEQ_END_REG) */
+#define SMN_SEQUENCE_END_MASK      0x0000ffff
+
+/** Mask for the usable bits of the Sequence Check Register
+    (#SMN_SEQ_CHECK_REG) */
+#define SMN_SEQUENCE_CHECK_MASK    0x0000ffff
+
+/** Mask for the usable bits of the Bit Counter Register
+    (#SMN_BB_CNT_REG) */
+#define SMN_BIT_COUNT_MASK         0x000007ff
+
+/** Mask for the usable bits of the Bit Bank Increment Size Register
+    (#SMN_BB_INC_REG) */
+#define SMN_BITBANK_INC_SIZE_MASK  0x000007ff
+
+/** Mask for the usable bits of the Bit Bank Decrement Register
+    (#SMN_BB_DEC_REG) */
+#define SMN_BITBANK_DECREMENT_MASK 0x000007ff
+
+/** Mask for the usable bits of the Compare Size Register
+    (#SMN_COMPARE_REG) */
+#define SMN_COMPARE_SIZE_MASK      0x0000003f
+
+/*! @} */
+
+#endif				/* SCC_DRIVER_H */
diff --git a/include/linux/mxc_scc_driver.h b/include/linux/mxc_scc_driver.h
new file mode 100644
index 0000000..5f1e1bb
--- /dev/null
+++ b/include/linux/mxc_scc_driver.h
@@ -0,0 +1,1031 @@
+
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_SCC_DRIVER_H__
+#define __ASM_ARCH_MXC_SCC_DRIVER_H__
+
+/* Start marker for C++ compilers */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * NAMING CONVENTIONS
+ * ==================
+ * (A note to maintainers and other interested parties)
+ *
+ * Use scc_ or SCC_ prefix for 'high-level' interface routines and the types
+ * passed to those routines.  Try to avoid #defines in these interfaces.
+ *
+ * Use SMN_ or SCM_ prefix for the #defines used with scc_read_register() and
+ * scc_write_register, or values passed/retrieved from those routines.
+ */
+
+/*!
+ * @defgroup MXCSCC SCC Driver
+ *
+ * @ingroup MXCSECDRVRS
+ */
+
+/*!
+ * @file arch-mxc/mxc_scc_driver.h
+ *
+ * @brief (Header file to use the SCC driver.)
+ *
+ * The SCC driver will only be available to other kernel modules.  That is,
+ * there will be no node file in /dev, no way for a user-mode program to access
+ * the driver, no way for a user program to access the device directly.
+ *
+ * With the exception of #scc_monitor_security_failure(), all routines are
+ * 'synchronous', i.e. they will not return to their caller until the requested
+ * action is complete, or fails to complete.  Some of these functions could
+ * take quite a while to perform, depending upon the request.
+ *
+ * Routines are provided to:
+ * @li encrypt or decrypt secrets - #scc_crypt()
+ * @li trigger a security-violation alarm - #scc_set_sw_alarm()
+ * @li get configuration and version information - #scc_get_configuration()
+ * @li zeroize memory - #scc_zeroize_memories()
+ * @li Work on wrapped and stored secret values: #scc_alloc_slot(),
+ *     #scc_dealloc_slot(), scc_load_slot(), #scc_decrypt_slot(),
+ *     #scc_encrypt_slot(), #scc_get_slot_info()
+
+ * @li monitor the Security Failure alarm - #scc_monitor_security_failure()
+ * @li stop monitoring Security Failure alarm -
+ *     #scc_stop_monitoring_security_failure()
+ * @li write registers of the SCC - #scc_write_register()
+ * @li read registers of the SCC - #scc_read_register()
+ *
+ * The driver does not allow "storage" of data in either the Red or Black
+ * memories.  Any decrypted secret is returned to the user, and if the user
+ * wants to use it at a later point, the encrypted form must again be passed
+ * to the driver, and it must be decrypted again.
+ *
+ * The SCC encrypts and decrypts using Triple DES with an internally stored
+ * key.  When the SCC is in Secure mode, it uses its secret, unique-per-chip
+ * key.  When it is in Non-Secure mode, it uses a default key.  This ensures
+ * that secrets stay secret if the SCC is not in Secure mode.
+ *
+ * Not all functions that could be provided in a 'high level' manner have been
+ * implemented.  Among the missing are interfaces to the ASC/AIC components and
+ * the timer functions.  These and other features must be accessed through
+ * #scc_read_register() and #scc_write_register(), using the @c \#define values
+ * provided.
+ *
+ * Here is a glossary of acronyms used in the SCC driver documentation:
+ * - CBC - Cipher Block Chaining.  A method of performing a block cipher.
+ *    Each block is encrypted using some part of the result of the previous
+ *    block's encryption.  It needs an 'initialization vector' to seed the
+ *    operation.
+ * - ECB - Electronic Code Book.  A method of performing a block cipher.
+ *    With a given key, a given block will always encrypt to the same value.
+ * - DES - Data Encryption Standard.  (8-byte) Block cipher algorithm which
+ *    uses 56-bit keys.  In SCC, this key is constant and unique to the device.
+ *    SCC uses the "triple DES" form of this algorithm.
+ * - AIC - Algorithm Integrity Checker.
+ * - ASC - Algorithm Sequence Checker.
+ * - SMN - Security Monitor.  The part of the SCC responsible for monitoring
+ *    for security problems and notifying the CPU and other PISA components.
+ * - SCM - Secure Memory.  The part of the SCC which handles the cryptography.
+ * - SCC - Security Controller.  Central security mechanism for PISA.
+ * - PISA - Platform-Independent Security Architecture.
+ */
+
+/* Temporarily define compile-time flags to make Doxygen happy. */
+#ifdef DOXYGEN_HACK
+/*! @defgroup scccompileflags SCC Driver compile-time flags
+ *
+ * These preprocessor flags should be set, if desired, in a makefile so
+ * that they show up on the compiler command line.
+ */
+/*! @addtogroup scccompileflags */
+
+/*! @{ */
+/*!
+ * Compile-time flag to change @ref smnregs and @ref scmregs
+ * offset values for the SCC's implementation on the MX.21 board.
+ *
+ * This must also be set properly for any code which calls the
+ * scc_read_register() or scc_write_register() functions or references the
+ * register offsets.
+ */
+#define TAHITI
+/*! @} */
+#undef TAHITI
+
+#endif				/* DOXYGEN_HACK */
+
+/*! Major Version of the driver.  Used for
+    scc_configuration->driver_major_version */
+#define SCC_DRIVER_MAJOR_VERSION_1 1
+/*! Old Minor Version of the driver. */
+#define SCC_DRIVER_MINOR_VERSION_0 0
+/*! Old Minor Version of the driver. */
+#define SCC_DRIVER_MINOR_VERSION_4 4
+/*! Old Minor Version of the driver. */
+#define SCC_DRIVER_MINOR_VERSION_5 5
+/*! Old Minor Version of the driver. */
+#define SCC_DRIVER_MINOR_VERSION_6 6
+/*! Minor Version of the driver.  Used for
+    scc_configuration->driver_minor_version */
+#define SCC_DRIVER_MINOR_VERSION_8 8
+
+
+/*!
+ * @typedef scc_return_t 
+ */
+/*! Common status return values from SCC driver functions. */
+	typedef enum scc_return_t {
+		SCC_RET_OK = 0,	/*!< Function succeeded  */
+		SCC_RET_FAIL,	/*!< Non-specific failure */
+		SCC_RET_VERIFICATION_FAILED,	/*!< Decrypt validation failed */
+		SCC_RET_TOO_MANY_FUNCTIONS,	/*!< At maximum registered functions */
+		SCC_RET_BUSY,	/*!< SCC is busy and cannot handle request */
+		SCC_RET_INSUFFICIENT_SPACE,	/*!< Encryption or decryption failed because
+							   @c count_out_bytes says that @c data_out is
+							   too small to hold the value. */
+	} scc_return_t;
+
+/*!
+ * Configuration information about SCC and the driver.
+ *
+ * This struct/typedef contains information from the SCC and the driver to
+ * allow the user of the driver to determine the size of the SCC's memories and
+ * the version of the SCC and the driver.
+ */
+	typedef struct scc_config_t {
+		int driver_major_version;	/*!< Major version of the SCC driver code  */
+		int driver_minor_version;	/*!< Minor version of the SCC driver code  */
+		int scm_version;	/*!< Version from SCM Configuration register */
+		int smn_version;	/*!< Version from SMN Status register */
+		int block_size_bytes;	/*!< Number of bytes per block of RAM; also
+					   block size of the crypto algorithm. */
+		int black_ram_size_blocks;	/*!< Number of blocks of Black RAM */
+		int red_ram_size_blocks;	/*!< Number of blocks of Red RAM */
+	} scc_config_t;
+
+/*!
+ * @typedef scc_enc_dec_t 
+ */
+/*!
+ * Determine whether SCC will run its cryptographic
+ * function as an encryption or decryption.  Used as an argument to
+ * #scc_crypt().
+ */
+	typedef enum scc_enc_dec_t {
+		SCC_ENCRYPT,	/*!< Encrypt (from Red to Black) */
+		SCC_DECRYPT	/*!< Decrypt (from Black to Red) */
+	} scc_enc_dec_t;
+
+/*
+ * @typedef scc_crypto_mode_t 
+ */
+/*!
+ * Determine whether SCC will run its cryptographic function in ECB (electronic
+ * codebook) or CBC (cipher-block chaining) mode.  Used as an argument to
+ * #scc_crypt().
+ */
+	typedef enum scc_crypto_mode_t {
+		SCC_ECB_MODE,	/*!< Electronic Codebook Mode */
+		SCC_CBC_MODE	/*!< Cipher Block Chaining Mode  */
+	} scc_crypto_mode_t;
+
+/*!
+ * @typedef scc_verify_t 
+ */
+/*!
+ * Tell the driver whether it is responsible for verifying the integrity of a
+ * secret.  During an encryption, using other than #SCC_VERIFY_MODE_NONE will
+ * cause a check value to be generated and appended to the plaintext before
+ * encryption.  During decryption, the check value will be verified after
+ * decryption, and then stripped from the message.
+ */
+	typedef enum scc_verify_t {
+		/*! No verification value added or checked.  Input plaintext data must be
+		 *  be a multiple of the blocksize (#scc_get_configuration()).  */
+		SCC_VERIFY_MODE_NONE,
+		/*! Driver will generate/validate a 2-byte CCITT CRC.  Input plaintext will
+		   be padded to a multiple of the blocksize, adding 3-10 bytes to the
+		   resulting output ciphertext.  Upon decryption, this padding will be
+		   stripped, and the CRC will be verified. */
+		SCC_VERIFY_MODE_CCITT_CRC
+	} scc_verify_t;
+
+/*!
+ * Determine if the given credentials match that of the key slot.
+ *
+ * @param[in]  owner_id     A value which will control access to the slot.
+ * @param[in]  slot         Key Slot to query
+ * @param[in]  access_len   Length of the key
+ *
+ * @return     0 on success, non-zero on failure.  See #scc_return_t.
+ */
+	 scc_return_t
+	    scc_verify_slot_access(uint64_t owner_id, uint32_t slot,
+				   uint32_t access_len);
+
+/*!
+ * Retrieve configuration information from the SCC.
+ *
+ * This function always succeeds.
+ *
+ * @return   A pointer to the configuration information.  This is a pointer to
+ *           static memory and must not be freed.  The values never change, and
+ *           the return value will never be null.
+ */
+	extern scc_config_t *scc_get_configuration(void);
+
+/*!
+ * Zeroize Red and Black memories of the SCC.  This will start the Zeroizing
+ * process.  The routine will return when the memories have zeroized or failed
+ * to do so.  The driver will poll waiting for this to occur, so this
+ * routine must not be called from interrupt level.  Some future version of
+ * driver may elect instead to sleep.
+ *
+ * @return 0 or error if initialization fails.
+ */
+	extern scc_return_t scc_zeroize_memories(void);
+
+/*!
+ * Perform a Triple DES encryption or decryption operation.
+ *
+ * This routine will cause the SCM to perform an encryption or decryption with
+ * its internal key.  If the SCC's #SMN_STATUS register shows that the SCC is
+ * in #SMN_STATE_SECURE, then the Secret Key will be used.  If it is
+ * #SMN_STATE_NON_SECURE (or health check), then the Default Key will be used.
+ *
+ * This function will perform in a variety of ways, depending upon the values
+ * of @c direction, @c crypto_mode, and @c check_mode.  If
+ * #SCC_VERIFY_MODE_CCITT_CRC mode is requested, upon successful completion,
+ * the @c count_in_bytes will be different from the returned value of @c
+ * count_out_bytes.  This is because the two-byte CRC and some amount of
+ * padding (at least one byte) will either be added or stripped.
+ *
+ * This function will not return until the SCC has performed the operation (or
+ * reported failure to do so).  It must therefore not be called from interrupt
+ * level.  In the current version, it will poll the SCC for completion.  In
+ * future versions, it may sleep.
+ *
+ * @param[in]    count_in_bytes The number of bytes to move through the crypto
+ *                            function.  Must be greater than zero.
+ *
+ * @param[in]    data_in      Pointer to the array of bytes to be used as input
+ *                            to the crypto function.
+ *
+ * @param[in]    init_vector  Pointer to the block-sized (8 byte) array of
+ *                            bytes which form the initialization vector for
+ *                            this operation.  A non-null value is required
+ *                            when @c crypto_mode has the value #SCC_CBC_MODE;
+ *                            the value is ignored in #SCC_ECB_MODE.
+ *
+ * @param[in]    direction    Direct the driver to perform encryption or
+ *                            decryption.
+ *
+ * @param[in]    crypto_mode  Run the crypto function in ECB or CBC mode.
+ *
+ * @param[in]    check_mode   During encryption, generate and append a check
+ *                            value to the plaintext and pad the resulting
+ *                            data.  During decryption, validate the plaintext
+ *                            with that check value and remove the padding.
+ *
+ * @param[in,out] count_out_bytes On input, the number of bytes available for
+ *                            copying to @c data_out.  On return, the number of
+ *                            bytes copied to @c data_out.
+ *
+ * @param[out] data_out       Pointer to the array of bytes that are where the
+ *                            output of the crypto function are to be placed.
+ *                            For encryption, this must be able to hold a
+ *                            longer ciphertext than the plaintext message at
+ *                            @c data_in.  The driver will append a 'pad' of
+ *                            1-8 bytes to the message, and if @c check_mode is
+ *                            used, additional bytes may be added, the number
+ *                            depending upon the type of check being requested.
+ *
+ * @return     0 on success, non-zero on failure.  See #scc_return_t.
+ *
+ * @internal
+ * This function will verify SCC state and the functions parameters.  It will
+ * acquire the crypto lock, and set up some SCC registers and variables common
+ * to encryption and decryption.  A rough check will be made to verify that
+ * enough space is available in @c count_out_bytes.  Upon success, either the
+ * #scc_encrypt or #scc_decrypt routine will be called to do the actual work.
+ * The crypto lock will then be released.
+ */
+extern scc_return_t scc_crypt(unsigned long count_in_bytes,
+				      const uint8_t * data_in,
+				      const uint8_t * init_vector,
+				      scc_enc_dec_t direction,
+				      scc_crypto_mode_t crypto_mode,
+				      scc_verify_t check_mode,
+				      uint8_t * data_out,
+				      unsigned long *count_out_bytes);
+
+
+/*!
+ * Allocate a key slot for a stored key (or other stored value).
+ *
+ * This feature is to allow decrypted secret values to be kept in RED RAM.
+ * This can all visibility of the data only by Sahara.
+ *
+ * @param   value_size_bytes  Size, in bytes, of RED key/value.  Currently only
+ *                            a size up to 32 bytes is supported.
+ *
+ * @param      owner_id       A value which will control access to the slot.
+ *                            It must be passed into to any subsequent calls to
+ *                            use the assigned slot.
+ *
+ * @param[out] slot           The slot number for the key.
+ *
+ * @return     0 on success, non-zero on failure.  See #scc_return_t.
+ */
+	extern scc_return_t scc_alloc_slot(uint32_t value_size_bytes,
+					   uint64_t owner_id, uint32_t * slot);
+
+/*!
+ * Deallocate the key slot of a stored key or secret value.
+ *
+ * @param      owner_id       The id which owns the @c slot.
+ *
+ * @param      slot           The slot number for the key.
+
+ * @return     0 on success, non-zero on failure.  See #scc_return_t.
+ */
+	extern scc_return_t scc_dealloc_slot(uint64_t owner_id, uint32_t slot);
+
+/*!
+ * Load a value into a slot.
+ *
+ * @param owner_id      Value of owner of slot
+ * @param slot          Handle of slot
+ * @param key_data      Data to load into the slot
+ * @param key_length    Length, in bytes, of @c key_data to copy to SCC.
+ *
+ * @return SCC_RET_OK on success.  SCC_RET_FAIL will be returned if slot
+ * specified cannot be accessed for any reason, or SCC_RET_INSUFFICIENT_SPACE
+ * if @c key_length exceeds the size of the slot.
+ */
+	extern scc_return_t scc_load_slot(uint64_t owner_id, uint32_t slot,
+					  const uint8_t * key_data,
+					  uint32_t key_length);
+/*!
+ * Read a value from a slot.
+ *
+ * @param owner_id      Value of owner of slot
+ * @param slot          Handle of slot
+ * @param key_length    Length, in bytes, of @c key_data to copy from SCC.
+ * @param key_data      Location to write the key
+ *
+ * @return SCC_RET_OK on success.  SCC_RET_FAIL will be returned if slot
+ * specified cannot be accessed for any reason, or SCC_RET_INSUFFICIENT_SPACE
+ * if @c key_length exceeds the size of the slot.
+ */
+	extern scc_return_t scc_read_slot(uint64_t owner_id, uint32_t slot,
+					  uint32_t key_length,
+					  uint8_t * key_data);
+
+/*!
+ * Allocate a key slot to fit the requested size.
+ *
+ * @param owner_id      Value of owner of slot
+ * @param slot          Handle of slot
+ * @param length        Length, in bytes, of @c black_data
+ * @param black_data    Location to store result of encrypting RED data in slot
+ *
+ * @return SCC_RET_OK on success, SCC_RET_FAIL if slot specified cannot be
+ *         accessed for any reason.
+ */
+	extern scc_return_t scc_encrypt_slot(uint64_t owner_id, uint32_t slot,
+					     uint32_t length,
+					     uint8_t * black_data);
+
+/*!
+ * Decrypt some black data and leave result in the slot.
+ *
+ * @param owner_id      Value of owner of slot
+ * @param slot          Handle of slot
+ * @param length        Length, in bytes, of @c black_data
+ * @param black_data    Location of data to dencrypt and store in slot
+ *
+ * @return SCC_RET_OK on success, SCC_RET_FAIL if slot specified cannot be
+ *         accessed for any reason.
+ */
+	extern scc_return_t scc_decrypt_slot(uint64_t owner_id, uint32_t slot,
+					     uint32_t length,
+					     const uint8_t * black_data);
+
+/*!
+ * Get attributes of data in RED slot.
+ *
+ * @param      owner_id         The id which owns the @c slot.
+ *
+ * @param      slot             The slot number for the key.
+ *
+ * @param[out] address          Physical address of RED value.
+ *
+ * @param[out] value_size_bytes Length, in bytes, of RED value,
+ *                              or NULL if unneeded..
+ *
+ * @param[out] slot_size_bytes  Length, in bytes, of slot size,
+ *                              or NULL if unneeded..
+ *
+ * @return     0 on success, non-zero on failure.  See #scc_return_t.
+ */
+	extern scc_return_t scc_get_slot_info(uint64_t owner_id, uint32_t slot,
+					      uint32_t *address,
+					      uint32_t *value_size_bytes,
+					      uint32_t *slot_size_bytes);
+
+/*!
+ * Signal a software alarm to the SCC.  This will take the SCC and other PISA
+ * parts out of Secure mode and into Security Failure mode.  The SCC will stay
+ * in failed mode until a reboot.
+ *
+ * @internal
+ * If the SCC is not already in fail state, simply write the
+ * #SMN_COMMAND_SET_SOFTWARE_ALARM bit in #SMN_COMMAND.  Since there is no
+ * reason to wait for the interrupt to bounce back, simply act as though
+ * one did.
+ */
+	extern void scc_set_sw_alarm(void);
+
+/*!
+ * This routine will register a function to be called should a Security Failure
+ * be signalled by the SCC (Security Monitor).
+ *
+ * The callback function may be called from interrupt level, it may be called
+ * from some process' task.  It should therefore not take a long time to
+ * perform its operation, and it may not sleep.
+ *
+ * @param  callback_func  Function pointer to routine which will receive
+ *                        notification of the security failure.
+ * @return         0 if function was successfully registered, non-zero on
+ *                 failure.  See #scc_return_t.
+ *
+ * @internal
+ *  There is a fixed global static array which keeps track of the requests to
+ *  monitor the failure.
+ *
+ *  Add @c callback_func to the first empty slot in #scc_callbacks[].  If there
+ *  is no room, return #SCC_RET_TOO_MANY_FUNCTIONS.
+ */
+	extern scc_return_t scc_monitor_security_failure(void
+							 callback_func(void));
+
+/*!
+ * This routine will deregister a function previously registered with
+ * #scc_monitor_security_failure().
+ *
+ * @param callback_func Function pointer to routine previously registered with
+ *                      #scc_stop_monitoring_security_failure().
+ */
+	extern void scc_stop_monitoring_security_failure(void
+							 callback_func(void));
+
+/*!
+ * Read value from an SCC register.
+ * The offset will be checked for validity (range) as well as whether it is
+ * accessible (e.g. not busy, not in failed state) at the time of the call.
+ *
+ * @param[in]   register_offset  The (byte) offset within the SCC block
+ *                               of the register to be queried. See
+ *                              @ref scmregs and @ref smnregs.
+ * @param[out]  value            Pointer to where value from the register
+ *                               should be placed.
+ * @return      0 if OK, non-zero on error.  See #scc_return_t.
+ *
+ * @internal
+ *  Verify that the register_offset is a) valid, b) refers to a readable
+ *  register, and c) the SCC is in a state which would allow a read of this
+ *  register.
+ */
+	extern scc_return_t scc_read_register(int register_offset,
+					      uint32_t * value);
+
+/*!
+ * Write a new value into an SCC register.
+ * The offset will be checked for validity (range) as well as whether it is
+ * accessible (e.g. not busy, not in failed state) at the time of the call.
+ *
+ * @param[in]  register_offset  The (byte) offset within the SCC block
+ *                              of the register to be modified. See
+ *                              @ref scmregs and @ref smnregs.
+ * @param[in]  value            The value to store into the register.
+ * @return     0 if OK, non-zero on error.  See #scc_return_t.
+ *
+ * @internal
+ *  Verify that the register_offset is a) valid, b) refers to a writeable
+ *  register, and c) the SCC is in a state which would allow a write to this
+ *  register.
+ */
+	extern scc_return_t scc_write_register(int register_offset,
+					       uint32_t value);
+
+/*
+ * NOTE TO MAINTAINERS
+ *
+ * All of the doxygen comments for the register offset values are in this the
+ * following comment section.  Any changes to register names or definitions
+ * must be reflected in this section and in both the TAHITI and non-TAHITI
+ *version of the memory map.
+ */
+
+/*!
+ * @defgroup scmregs SCM Registers
+ *
+ * These values are offsets into the SCC for the Secure Memory
+ * (SCM) registers.  They are used in the @c register_offset parameter of
+ * #scc_read_register() and #scc_write_register().
+ */
+/*! @addtogroup scmregs */
+/*! @{ */
+/*! @def SCM_RED_START
+ * Starting block offset in red memory for cipher function. */
+
+/*! @def SCM_BLACK_START
+ * Starting block offset in black memory for cipher function. */
+
+/*! @def SCM_LENGTH
+ * Number of blocks to process during cipher function */
+
+/*! @def SCM_CONTROL
+ * SCM Control register.
+ * See @ref scmcontrolregdefs "SCM Control Register definitions" for details.
+ */
+
+/*! @def SCM_STATUS
+ * SCM Status register.
+ * See @ref scmstatusregdefs "SCM Status Register Definitions" for details.
+ */
+
+/*! @def SCM_ERROR_STATUS
+ * SCM Error Status Register.
+ * See @ref scmerrstatdefs "SCM Error Status Register definitions" for
+ * details. */
+
+/*! @def SCM_INTERRUPT_CTRL
+ * SCM Interrupt Control Register.
+ * See @ref scminterruptcontroldefs "SCM Interrupt Control Register definitions"
+ * for details.
+ */
+
+/*! @def SCM_CONFIGURATION
+ * SCM Configuration Register.
+ * See @ref scmconfigdefs "SCM Configuration Register Definitions" for
+ * details.
+ */
+
+/*! @def SCM_INIT_VECTOR_0
+ * Upper Half of the Initialization Vector */
+
+/*! @def SCM_INIT_VECTOR_1
+ * Lower Half of the Initialization Vector */
+
+/*! @def SCM_RED_MEMORY
+ * Starting location of first block of Red memory */
+
+/*! @def SCM_BLACK_MEMORY
+ * Starting location of first block of Black memory */
+
+	/*! @} *//* end of SCM group */
+
+/*!
+ * @defgroup smnregs SMN Registers
+ *
+ * These values are offsets into the SCC for the Security Monitor
+ * (SMN) registers.  They are used in the @c register_offset parameter of the
+ * #scc_read_register() and #scc_write_register().
+ */
+/*! @addtogroup smnregs */
+/*! @{ */
+/*! @def SMN_STATUS
+ * Status register for SMN.
+ * See @ref smnstatusregdefs "SMN Status Register definitions" for further
+ * information.
+ */
+
+/*! @def SMN_COMMAND
+ * Command register for SMN. See
+ * @ref smncommandregdefs "Command Register Definitions" for further
+ * information.
+ */
+
+/*! @def SMN_SEQUENCE_START
+ * Sequence Start register for ASC. See #SMN_SEQUENCE_START_MASK
+ */
+
+/*! @def SMN_SEQUENCE_END
+ * Sequence End register for ASC. See #SMN_SEQUENCE_CHECK_MASK
+ */
+
+/*! @def SMN_SEQUENCE_CHECK
+ * Sequence Check register for ASC. See #SMN_SEQUENCE_END_MASK
+ */
+
+/*! @def SMN_BIT_COUNT
+ * Bit Bank Repository for AIC. See #SMN_BIT_COUNT_MASK
+ */
+
+/*! @def SMN_BITBANK_INC_SIZE
+ * Bit Bank Increment Size for AIC. See #SMN_BITBANK_INC_SIZE_MASK
+ */
+
+/*! @def SMN_BITBANK_DECREMENT
+ * Bit Bank Decrement for AIC. See #SMN_BITBANK_DECREMENT_MASK
+ */
+
+/*! @def SMN_COMPARE_SIZE
+ * Compare Size register for Plaintext/Ciphertext checker.  See
+ * #SMN_COMPARE_SIZE_MASK */
+
+/*! @def SMN_PLAINTEXT_CHECK
+ * Plaintext Check register for Plaintext/Ciphertext checker.
+ */
+
+/*! @def SMN_CIPHERTEXT_CHECK
+ * Ciphertext Check register for Plaintext/Ciphertext checker.
+ */
+
+/*! @def SMN_TIMER_IV
+ * Timer Initial Value register
+ */
+
+/*! @def SMN_TIMER_CONTROL
+ * Timer Control register.
+ * See @ref smntimercontroldefs "SMN Timer Control Register definitions".
+ */
+
+/*! @def SMN_DEBUG_DETECT_STAT
+ * Debug Detector Status Register
+ * See @ref smndbgdetdefs "SMN Debug Detector Status Register"for definitions.
+ */
+
+/*! @def SMN_TIMER
+ * Current value of the Timer Register
+ */
+
+	/*! @} *//* end of SMN group */
+
+/*
+ * SCC MEMORY MAP
+ *
+ */
+
+/* SCM registers */
+#define SCM_RED_START           0x00000000	/*          read/write       */
+#define SCM_BLACK_START         0x00000004	/*          read/write       */
+#define SCM_LENGTH              0x00000008	/*          read/write       */
+#define SCM_CONTROL             0x0000000C	/*          read/write       */
+#define SCM_STATUS              0x00000010	/*          read only        */
+#define SCM_ERROR_STATUS        0x00000014	/*          read/write       */
+#define SCM_INTERRUPT_CTRL      0x00000018	/*          read/write       */
+#define SCM_CONFIGURATION       0x0000001C	/*          read only        */
+#define SCM_INIT_VECTOR_0       0x00000020	/*          read/write       */
+#define SCM_INIT_VECTOR_1       0x00000024	/*          read/write       */
+#define SCM_RED_MEMORY          0x00000400	/*          read/write       */
+#define SCM_BLACK_MEMORY        0x00000800	/*          read/write       */
+
+/* SMN Registers */
+#define SMN_STATUS              0x00001000	/*          read/write       */
+#define SMN_COMMAND             0x00001004	/*          read/write       */
+#define SMN_SEQUENCE_START      0x00001008	/*          read/write       */
+#define SMN_SEQUENCE_END        0x0000100C	/*          read/write       */
+#define SMN_SEQUENCE_CHECK      0x00001010	/*          read/write       */
+#define SMN_BIT_COUNT           0x00001014	/*          read only        */
+#define SMN_BITBANK_INC_SIZE    0x00001018	/*          read/write       */
+#define SMN_BITBANK_DECREMENT   0x0000101C	/*          write only       */
+#define SMN_COMPARE_SIZE        0x00001020	/*          read/write       */
+#define SMN_PLAINTEXT_CHECK     0x00001024	/*          read/write       */
+#define SMN_CIPHERTEXT_CHECK    0x00001028	/*          read/write       */
+#define SMN_TIMER_IV            0x0000102C	/*          read/write       */
+#define SMN_TIMER_CONTROL       0x00001030	/*          read/write       */
+#define SMN_DEBUG_DETECT_STAT   0x00001034	/*          read/write       */
+#define SMN_TIMER               0x00001038	/*          read only        */
+
+/*! Total address space of the SCC, in bytes */
+#define SCC_ADDRESS_RANGE    0x103c
+
+/*!
+ * @defgroup smnstatusregdefs SMN Status Register definitions (SMN_STATUS)
+ */
+/*! @addtogroup smnstatusregdefs */
+/*! @{ */
+/*! SMN version id. */
+#define SMN_STATUS_VERSION_ID_MASK        0xfc000000
+/*!  number of bits to shift #SMN_STATUS_VERSION_ID_MASK to get it to LSB */
+#define SMN_STATUS_VERSION_ID_SHIFT       26
+/*! Cacheable access to SMN attempted.  */
+#define SMN_STATUS_CACHEABLE_ACCESS       0x02000000
+/*! Illegal bus master access attempted. */
+#define SMN_STATUS_ILLEGAL_MASTER         0x01000000
+/*! Scan mode entered/exited since last reset. */
+#define SMN_STATUS_SCAN_EXIT              0x00800000
+/*! Unaligned access attempted. */
+#define SMN_STATUS_UNALIGNED_ACCESS       0x00400000
+/*! Bad byte offset access attempted. */
+#define SMN_STATUS_BYTE_ACCESS            0x00200000
+/*! Illegal address access attempted. */
+#define SMN_STATUS_ILLEGAL_ADDRESS        0x00100000
+/*! User access attempted. */
+#define SMN_STATUS_USER_ACCESS            0x00080000
+/*! SCM is using DEFAULT key.  */
+#define SMN_STATUS_DEFAULT_KEY            0x00040000
+/*! SCM detects weak or bad key.  */
+#define SMN_STATUS_BAD_KEY                0x00020000
+/*! Illegal access to SCM detected. */
+#define SMN_STATUS_ILLEGAL_ACCESS         0x00010000
+/*! Internal error detected in SCM. */
+#define SMN_STATUS_SCM_ERROR              0x00008000
+/*! SMN has an outstanding interrupt. */
+#define SMN_STATUS_SMN_STATUS_IRQ         0x00004000
+/*! Software Alarm was triggered. */
+#define SMN_STATUS_SOFTWARE_ALARM         0x00002000
+/*! Timer has expired. */
+#define SMN_STATUS_TIMER_ERROR            0x00001000
+/*! Plaintext/Ciphertext compare failed. */
+#define SMN_STATUS_PC_ERROR               0x00000800
+/*! Bit Bank detected overflow or underflow */
+#define SMN_STATUS_BITBANK_ERROR          0x00000400
+/*! Algorithm Sequence Check failed. */
+#define SMN_STATUS_ASC_ERROR              0x00000200
+/*! Security Policy Block detected error. */
+#define SMN_STATUS_SECURITY_POLICY_ERROR  0x00000100
+/*! At least one Debug signal is active. */
+#define SMN_STATUS_DEBUG_ACTIVE           0x00000080
+/*! SCM failed to zeroize its memory. */
+#define SMN_STATUS_ZEROIZE_FAIL           0x00000040
+/*! Processor booted from internal ROM. */
+#define SMN_STATUS_INTERNAL_BOOT          0x00000020
+/*! SMN's internal state. */
+#define SMN_STATUS_STATE_MASK             0x0000001F
+/*! Number of bits to shift #SMN_STATUS_STATE_MASK to get it to LSB. */
+#define SMN_STATUS_STATE_SHIFT            0
+/*! @} */
+
+/*!
+ * @defgroup sccscmstates SMN Model Secure State Controller States (SMN_STATE_MASK)
+ */
+/*! @addtogroup sccscmstates */
+/*! @{ */
+/*! This is the first state of the SMN after power-on reset  */
+#define SMN_STATE_START         0x0
+/*! The SMN is zeroizing its RAM during reset */
+#define SMN_STATE_ZEROIZE_RAM   0x5
+/*! SMN has passed internal checks, and is waiting for Software check-in */
+#define SMN_STATE_HEALTH_CHECK  0x6
+/*! Fatal Security Violation.  SMN is locked, SCM is inoperative. */
+#define SMN_STATE_FAIL          0x9
+/*! SCC is in secure state.  SCM is using secret key. */
+#define SMN_STATE_SECURE        0xA
+/*! Due to non-fatal error, device is not secure.  SCM is using default key. */
+#define SMN_STATE_NON_SECURE    0xC
+/*! @} */
+
+/*!
+ * @defgroup scmconfigdefs SCM Configuration Register definitions (SCM_CONFIGURATION)
+ **/
+/*! @addtogroup scmconfigdefs */
+/*! @{ */
+/*! Version number of the Secure Memory. */
+#define SCM_CFG_VERSION_ID_MASK         0xf8000000
+/*! Number of bits to shift #SCM_CFG_VERSION_ID_MASK to get it to LSB. */
+#define SCM_CFG_VERSION_ID_SHIFT        27
+/*! Version one value for SCC configuration */
+#define SCM_VERSION_1    1
+/*! Size, in blocks, of Red memory. */
+#define SCM_CFG_BLACK_SIZE_MASK         0x07fe0000
+/*! Number of bits to shift #SCM_CFG_BLACK_SIZE_MASK to get it to LSB. */
+#define SCM_CFG_BLACK_SIZE_SHIFT        17
+/*! Size, in blocks, of Black memory. */
+#define SCM_CFG_RED_SIZE_MASK           0x0001ff80
+/*! Number of bits to shift #SCM_CFG_RED_SIZE_MASK to get it to LSB. */
+#define SCM_CFG_RED_SIZE_SHIFT          7
+/*! Number of bytes per block. */
+#define SCM_CFG_BLOCK_SIZE_MASK         0x0000007f
+/*! Number of bits to shift #SCM_CFG_BLOCK_SIZE_MASK to get it to LSB. */
+#define SCM_CFG_BLOCK_SIZE_SHIFT        0
+/*! @} */
+
+/*!
+ * @defgroup smncommandregdefs SMN Command Register Definitions (SMN_COMMAND)
+ */
+/*! @addtogroup smncommandregdefs */
+/*! @{ */
+#define SMN_COMMAND_ZEROS_MASK   0xffffff70	/*!< These bits are unimplemented
+						   or reserved */
+#define SMN_COMMAND_TAMPER_LOCK         0x10 /*!< Lock Tamper Detect Bit */
+#define SMN_COMMAND_CLEAR_INTERRUPT     0x8	/*!< Clear SMN Interrupt */
+#define SMN_COMMAND_CLEAR_BIT_BANK      0x4	/*!< Clear SMN Bit Bank */
+#define SMN_COMMAND_ENABLE_INTERRUPT    0x2	/*!< Enable SMN Interrupts */
+#define SMN_COMMAND_SET_SOFTWARE_ALARM  0x1	/*!< Set Software Alarm */
+/*! @} */
+
+/*!
+ * @defgroup smntimercontroldefs SMN Timer Control Register definitions (SMN_TIMER_CONTROL)
+ */
+/*! @addtogroup smntimercontroldefs */
+/*! @{ */
+/*! These bits are reserved or zero */
+#define SMN_TIMER_CTRL_ZEROS_MASK 0xfffffffc
+/*! Load the timer from #SMN_TIMER_IV */
+#define SMN_TIMER_LOAD_TIMER             0x2
+/*! Setting to zero stops the Timer */
+#define SMN_TIMER_STOP_MASK              0x1
+/*! Setting this value starts the timer */
+#define SMN_TIMER_START_TIMER            0x1
+/*! @} */
+
+/*!
+ * @defgroup scminterruptcontroldefs SCM Interrupt Control Register definitions (SCM_INTERRUPT_CTRL)
+ *
+ * These are the bit definitions for the #SCM_INTERRUPT_CTRL register.
+ */
+/*! @addtogroup scminterruptcontroldefs */ 
+/*! @{ */
+/*! Clear SCM memory */
+#define SCM_INTERRUPT_CTRL_ZEROIZE_MEMORY      0x4
+/*! Clear outstanding SCM interrupt */
+#define SCM_INTERRUPT_CTRL_CLEAR_INTERRUPT     0x2
+/*! Inhibit SCM interrupts */
+#define SCM_INTERRUPT_CTRL_MASK_INTERRUPTS     0x1
+/*! @} */
+
+/*!
+ * @defgroup scmcontrolregdefs SCM Control Register definitions (SCM_CONTROL).
+ * These values are used with the #SCM_CONTROL register.
+ */
+/*! @addtogroup scmcontrolregdefs */
+/*! @{ */
+/*! These bits are zero or reserved */
+#define SCM_CONTROL_ZEROS_MASK    0xfffffff8
+/*! Setting this will start encrypt/decrypt */
+#define SCM_CONTROL_START_CIPHER        0x04
+/*! CBC/ECB flag.
+ * See @ref scmchainmodedefs "Chaining Mode bit definitions."
+ */
+#define SCM_CONTROL_CHAINING_MODE_MASK  0x02
+/*! Encrypt/decrypt choice.
+ * See @ref scmciphermodedefs "Cipher Mode bit definitions." */
+#define SCM_CONTROL_CIPHER_MODE_MASK    0x01
+/*! @} */
+
+/*!
+ * @defgroup scmchainmodedefs  SCM_CHAINING_MODE_MASK - Bit definitions
+ */
+/*! @addtogroup scmchainmodedefs */
+/*! @{ */
+#define SCM_CBC_MODE            0x2	/*!< Cipher block chaining */
+#define SCM_ECB_MODE            0x0	/*!< Electronic codebook. */
+/*! @} */
+
+/* Bit definitions in the SCM_CIPHER_MODE_MASK */
+/*!
+ * @defgroup scmciphermodedefs SCM_CIPHER_MODE_MASK - Bit definitions
+ */
+/*! @{ */
+#define SCM_DECRYPT_MODE        0x1	/*!< decrypt from black to red memory */
+#define SCM_ENCRYPT_MODE        0x0	/*!< encrypt from red to black memory */
+/*! @} */
+
+/*!
+ * @defgroup scmstatusregdefs  SCM Status Register (SCM_STATUS).
+ * Bit and field definitions of the SCM_STATUS register.
+ */
+/*! @addtogroup scmstatusregdefs */
+/*! @{ */
+/*! These bits are zero or reserved */
+#define SCM_STATUS_ZEROS_MASK        0xffffe000
+/*! Ciphering failed due to length error. */
+#define SCM_STATUS_LENGTH_ERROR          0x1000
+/*! SMN has stopped blocking access to the SCM */
+#define SCM_STATUS_BLOCK_ACCESS_REMOVED  0x0800
+/*! Ciphering done. */
+#define SCM_STATUS_CIPHERING_DONE        0x0400
+/*! Zeroizing done. */
+#define SCM_STATUS_ZEROIZING_DONE        0x0200
+/*! SCM wants attention. Interrupt status is available. */
+#define SCM_STATUS_INTERRUPT_STATUS      0x0100
+/*! Secret Key is in use. */
+#define SCM_STATUS_SECRET_KEY            0x0080
+/*! Secret Key is in use.  Deprecated.  Use #SCM_STATUS_SECRET_KEY. */
+#define SCM_STATUS_DEFAULT_KEY           0x0080
+/*! Internal error to SCM. */
+#define SCM_STATUS_INTERNAL_ERROR        0x0040
+/*! Secret key is not valid. */
+#define SCM_STATUS_BAD_SECRET_KEY        0x0020
+/*! Failed to zeroize memory. */
+#define SCM_STATUS_ZEROIZE_FAILED        0x0010
+/*! SMN is blocking access to Secure Memory. */
+#define SCM_STATUS_SMN_BLOCKING_ACCESS   0x0008
+/*! SCM is current encrypting or decrypting data. */
+#define SCM_STATUS_CIPHERING             0x0004
+/*! SCM is currently zeroizing data. */
+#define SCM_STATUS_ZEROIZING             0x0002
+/*! SCM is busy and access to memory is blocked. */
+#define SCM_STATUS_BUSY                  0x0001
+/*! @} */
+
+/*!
+ * @defgroup scmerrstatdefs SCM Error Status Register (SCM_ERROR_STATUS)
+ *
+ * These definitions are associated with the SCM Error Status Register
+ * (SCM_ERROR_STATUS).
+ */
+/*! @addtogroup scmerrstatdefs */
+/*! @{ */
+/*! These bits are zero or reserved */
+#define SCM_ERR_ZEROS_MASK      0xffffc000
+/*! Cacheable access to SCM was attempted */
+#define SCM_ERR_CACHEABLE_ACCESS    0x2000
+/*! Access attempted by illegal bus master */
+#define SCM_ERR_ILLEGAL_MASTER      0x1000
+/*! Unaligned access attempted */
+#define SCM_ERR_UNALIGNED_ACCESS    0x0800
+/*! Byte or half-word access attempted */
+#define SCM_ERR_BYTE_ACCESS         0x0400
+/*! Illegal address attempted */
+#define SCM_ERR_ILLEGAL_ADDRESS     0x0200
+/*! User access attempted */
+#define SCM_ERR_USER_ACCESS         0x0100
+/*! Access attempted while SCM was using default key */
+#define SCM_ERR_SECRET_KEY_IN_USE   0x0080
+/*! Access attempted while SCM had internal error */
+#define SCM_ERR_INTERNAL_ERROR      0x0040
+/*! Access attempted while SCM was detecting Bad Key */
+#define SCM_ERR_BAD_SECRET_KEY      0x0020
+/*! The SCM failed to Zeroize memory */
+#define SCM_ERR_ZEROIZE_FAILED      0x0010
+/*! Access attempted while SMN was Blocking Access */
+#define SCM_ERR_SMN_BLOCKING_ACCESS 0x0008
+/*! Access attempted while SCM was CIPHERING */
+#define SCM_ERR_CIPHERING           0x0004
+/*! Access attempted while SCM was ZEROIZING */
+#define SCM_ERR_ZEROIZING           0x0002
+/*! Access attempted while SCM was BUSY */
+#define SCM_ERR_BUSY                0x0001
+/*! @} */
+
+/*!
+ * @defgroup smndbgdetdefs SMN Debug Detector Status Register
+ * (SCM_DEBUG_DETECT_STAT)
+ */
+/*! @addtogroup smndbgdetdefs */
+/*! @{ */
+#define SMN_DBG_ZEROS_MASK  0xfffff000	/*!< These bits are zero or reserved */
+#define SMN_DBG_D12             0x0800	/*!< Error detected on Debug Port D12 */
+#define SMN_DBG_D11             0x0400	/*!< Error detected on Debug Port D11 */
+#define SMN_DBG_D10             0x0200	/*!< Error detected on Debug Port D10 */
+#define SMN_DBG_D9              0x0100	/*!< Error detected on Debug Port D9 */
+#define SMN_DBG_D8              0x0080	/*!< Error detected on Debug Port D8 */
+#define SMN_DBG_D7              0x0040	/*!< Error detected on Debug Port D7 */
+#define SMN_DBG_D6              0x0020	/*!< Error detected on Debug Port D6 */
+#define SMN_DBG_D5              0x0010	/*!< Error detected on Debug Port D5 */
+#define SMN_DBG_D4              0x0008	/*!< Error detected on Debug Port D4 */
+#define SMN_DBG_D3              0x0004	/*!< Error detected on Debug Port D3 */
+#define SMN_DBG_D2              0x0002	/*!< Error detected on Debug Port D2 */
+#define SMN_DBG_D1              0x0001	/*!< Error detected on Debug Port D1 */
+/*! @} */
+
+/*! Mask for the usable bits of the Sequence Start Register
+    (#SMN_SEQUENCE_START) */
+#define SMN_SEQUENCE_START_MASK    0x0000ffff
+
+/*! Mask for the usable bits of the Sequence End Register
+    (#SMN_SEQUENCE_END) */
+#define SMN_SEQUENCE_END_MASK      0x0000ffff
+
+/*! Mask for the usable bits of the Sequence Check Register
+    (#SMN_SEQUENCE_CHECK) */
+#define SMN_SEQUENCE_CHECK_MASK    0x0000ffff
+
+/*! Mask for the usable bits of the Bit Counter Register
+    (#SMN_BIT_COUNT) */
+#define SMN_BIT_COUNT_MASK         0x000007ff
+
+/*! Mask for the usable bits of the Bit Bank Increment Size Register
+    (#SMN_BITBANK_INC_SIZE) */
+#define SMN_BITBANK_INC_SIZE_MASK  0x000007ff
+
+/*! Mask for the usable bits of the Bit Bank Decrement Register
+    (#SMN_BITBANK_DECREMENT) */
+#define SMN_BITBANK_DECREMENT_MASK 0x000007ff
+
+/*! Mask for the usable bits of the Compare Size Register
+    (#SMN_COMPARE_SIZE) */
+#define SMN_COMPARE_SIZE_MASK      0x0000003f
+
+/* Close out marker for C++ compilers */
+#ifdef __cplusplus
+}
+#endif
+#endif				/* __ASM_ARCH_MXC_SCC_DRIVER_H__ */
diff --git a/include/linux/mxc_v4l2.h b/include/linux/mxc_v4l2.h
new file mode 100644
index 0000000..b897374
--- /dev/null
+++ b/include/linux/mxc_v4l2.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+/*!
+ * @file arch-mxc/mxc_v4l2.h
+ *
+ * @brief mxc V4L2 private structures
+ *
+ * @ingroup MXC_V4L2_CAPTURE
+ */
+
+#ifndef __ASM_ARCH_MXC_V4L2_H__
+#define __ASM_ARCH_MXC_V4L2_H__
+
+#define V4L2_CID_MXC_ROT		(V4L2_CID_PRIVATE_BASE + 0)
+#define V4L2_CID_MXC_FLASH		(V4L2_CID_PRIVATE_BASE + 1)
+
+#define V4L2_MXC_ROTATE_NONE			0
+#define V4L2_MXC_ROTATE_VERT_FLIP		1
+#define V4L2_MXC_ROTATE_HORIZ_FLIP		2
+#define V4L2_MXC_ROTATE_180			3
+#define V4L2_MXC_ROTATE_90_RIGHT		4
+#define V4L2_MXC_ROTATE_90_RIGHT_VFLIP		5
+#define V4L2_MXC_ROTATE_90_RIGHT_HFLIP		6
+#define V4L2_MXC_ROTATE_90_LEFT			7
+
+struct v4l2_mxc_offset {
+	uint32_t u_offset;
+	uint32_t v_offset;
+};
+
+#endif
diff --git a/include/linux/mxcfb.h b/include/linux/mxcfb.h
new file mode 100644
index 0000000..259ec8b
--- /dev/null
+++ b/include/linux/mxcfb.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+/*
+ * @file arch-mxc/   mxcfb.h
+ *
+ * @brief Global header file for the MXC Frame buffer
+ *
+ * @ingroup Framebuffer
+ */
+#ifndef __ASM_ARCH_MXCFB_H__
+#define __ASM_ARCH_MXCFB_H__
+
+#include <linux/fb.h>
+
+#define FB_SYNC_OE_ACT_HIGH	0x80000000
+#define FB_SYNC_CLK_INVERT	0x40000000
+#define FB_SYNC_DATA_INVERT	0x20000000
+#define FB_SYNC_CLK_IDLE_EN	0x10000000
+#define FB_SYNC_SHARP_MODE	0x08000000
+#define FB_SYNC_SWAP_RGB	0x04000000
+
+struct mxcfb_gbl_alpha {
+	int enable;
+	int alpha;
+};
+
+struct mxcfb_color_key {
+	int enable;
+	__u32 color_key;
+};
+
+struct mxcfb_pos {
+	__u16 x;
+	__u16 y;
+};
+
+#define MXCFB_WAIT_FOR_VSYNC	_IOW('F', 0x20, u_int32_t)
+#define MXCFB_SET_GBL_ALPHA     _IOW('F', 0x21, struct mxcfb_gbl_alpha)
+#define MXCFB_SET_CLR_KEY       _IOW('F', 0x22, struct mxcfb_color_key)
+#define MXCFB_SET_OVERLAY_POS   _IOW('F', 0x24, struct mxcfb_pos)
+
+#ifdef __KERNEL__
+
+extern struct fb_videomode mxcfb_modedb[];
+extern int mxcfb_modedb_sz;
+
+enum {
+	MXCFB_REFRESH_OFF,
+	MXCFB_REFRESH_AUTO,
+	MXCFB_REFRESH_PARTIAL,
+};
+
+struct mxcfb_rect {
+	u32 top;
+	u32 left;
+	u32 width;
+	u32 height;
+};
+
+int mxcfb_set_refresh_mode(struct fb_info *fbi, int mode,
+			   struct mxcfb_rect *update_region);
+
+#endif				/* __KERNEL__ */
+#endif
diff --git a/include/linux/pmic_adc.h b/include/linux/pmic_adc.h
new file mode 100644
index 0000000..8cc8729
--- /dev/null
+++ b/include/linux/pmic_adc.h
@@ -0,0 +1,455 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_PMIC_ADC_H__
+#define __ASM_ARCH_MXC_PMIC_ADC_H__
+
+/*!
+ * @defgroup PMIC_ADC PMIC Digitizer Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file arch-mxc/pmic_adc.h
+ * @brief This is the header of PMIC ADC driver.
+ *
+ * @ingroup PMIC_ADC
+ */
+
+#include <linux/ioctl.h>
+#include <linux/pmic_status.h>
+#include <linux/pmic_external.h>
+
+/*!
+ * @name IOCTL user space interface
+ */
+
+/*! @{ */
+/*!
+ * Initialize ADC.
+ * Argument type: none.
+ */
+#define PMIC_ADC_INIT                   _IO('p', 0xb0)
+/*!
+ * De-initialize ADC.
+ * Argument type: none.
+ */
+#define PMIC_ADC_DEINIT                 _IO('p', 0xb1)
+/*!
+ * Convert one channel.
+ * Argument type: pointer to t_adc_convert_param.
+ */
+#define PMIC_ADC_CONVERT                _IOWR('p', 0xb2, int)
+/*!
+ * Convert one channel eight samples.
+ * Argument type: pointer to t_adc_convert_param.
+ */
+#define PMIC_ADC_CONVERT_8X             _IOWR('p', 0xb3, int)
+/*!
+ * Convert multiple channels.
+ * Argument type: pointer to t_adc_convert_param.
+ */
+#define PMIC_ADC_CONVERT_MULTICHANNEL   _IOWR('p', 0xb4, int)
+/*!
+ * Set touch screen operation mode.
+ * Argument type: t_touch_mode.
+ */
+#define PMIC_ADC_SET_TOUCH_MODE         _IOW('p', 0xb5, int)
+/*!
+ * Get touch screen operation mode.
+ * Argument type: pointer to t_touch_mode.
+ */
+#define PMIC_ADC_GET_TOUCH_MODE         _IOR('p', 0xb6, int)
+/*!
+ * Get touch screen sample.
+ * Argument type: pointer to t_touch_sample.
+ */
+#define PMIC_ADC_GET_TOUCH_SAMPLE       _IOWR('p', 0xb7, int)
+/*!
+ * Get battery current.
+ * Argument type: pointer to unsigned short.
+ */
+#define PMIC_ADC_GET_BATTERY_CURRENT    _IOR('p', 0xb8, int)
+/*!
+ * Activate comparator.
+ * Argument type: pointer to t_adc_comp_param.
+ */
+#define PMIC_ADC_ACTIVATE_COMPARATOR    _IOW('p', 0xb9, int)
+/*!
+ * De-active comparator.
+ * Argument type: none.
+ */
+#define PMIC_ADC_DEACTIVE_COMPARATOR    _IOW('p', 0xba, int)
+
+/*!
+ * Install touch screen read interface.
+ */
+#define TOUCH_SCREEN_READ_INSTALL       _IOWR('D',4, int)
+/*!
+ * Remove touch screen read interface.
+ */
+#define TOUCH_SCREEN_READ_UNINSTALL     _IOWR('D',5, int)
+
+/*! @{ */
+/*!
+ * @name Touch Screen minimum and maximum values
+ */
+#define TS_X_MIN                80	/*! < Minimum X */
+#define TS_Y_MIN                80	/*! < Minimum Y */
+
+#define TS_X_MAX                1000	/*! < Maximum X */
+#define TS_Y_MAX                1000	/*! < Maximum Y */
+/*! @} */
+/*!
+ * This enumeration defines input channels for PMIC ADC
+ */
+
+typedef enum {
+	BATTERY_VOLTAGE,
+	BATTERY_CURRENT,
+	CHARGE_VOLTAGE,
+	CHARGE_CURRENT,
+	APPLICATION_SUPPLY,
+	TS_X_POS1,
+	TS_X_POS2,
+	TS_Y_POS1,
+	TS_Y_POS2,
+	GEN_PURPOSE_AD4,
+	GEN_PURPOSE_AD5,
+	GEN_PURPOSE_AD6,
+	GEN_PURPOSE_AD7,
+	GEN_PURPOSE_AD8,
+	GEN_PURPOSE_AD9,
+	GEN_PURPOSE_AD10,
+	GEN_PURPOSE_AD11,
+	USB_ID,
+	LICELL,
+	RAWEXTBPLUSSENSE,
+	MPBSENSE,
+	BATSENSE,
+	GND,
+	THERMISTOR,
+	DIE_TEMP
+} t_channel;
+
+/*!
+ * This enumeration defines reason of ADC Comparator interrupt.
+ */
+typedef enum {
+	/*!
+	 * Greater than WHIGH
+	 */
+	GTWHIGH,
+	/*!
+	 * Less than WLOW
+	 */
+	LTWLOW,
+} t_comp_exception;
+
+/*!
+ * ADC comparator callback function type
+ */
+typedef void (*t_comparator_cb) (t_comp_exception reason);
+
+/*!
+ * This enumeration defines the touch screen operation modes.
+ */
+typedef enum {
+	/*!
+	 * Touch Screen X position
+	 */
+	TS_X_POSITION = 0,
+	/*!
+	 * Touch Screen Y position
+	 */
+	TS_Y_POSITION = 1,
+	/*!
+	 * Pressure
+	 */
+	TS_PRESSURE = 2,
+	/*!
+	 * Plate X
+	 */
+	TS_PLATE_X = 3,
+	/*!
+	 * Plate Y
+	 */
+	TS_PLATE_Y = 4,
+	/*!
+	 * Standby
+	 */
+	TS_STANDBY = 5,
+	/*!
+	 * No touch screen, TSX1, TSX2, TSY1 and TSY2 are used as  general
+	 * purpose A/D inputs.
+	 */
+	TS_NONE = 6,
+} t_touch_mode;
+/*!
+ * This structure is used to report touch screen value.
+ */
+typedef struct {
+/*!
+	 * Touch Screen X position
+	 */
+	unsigned int x_position;
+	/*!
+	 * Touch Screen X position1
+	 */
+	unsigned int x_position1;
+	/*!
+	 * Touch Screen X position2
+	 */
+	unsigned int x_position2;
+	/*!
+	 * Touch Screen X position3
+	 */
+	unsigned int x_position3;
+	/*!
+	 * Touch Screen Y position
+	 */
+	unsigned int y_position;
+	/*!
+	 * Touch Screen Y position1
+	 */
+	unsigned int y_position1;
+	/*!
+	 * Touch Screen Y position2
+	 */
+	unsigned int y_position2;
+	/*!
+	 * Touch Screen Y position3
+	 */
+	unsigned int y_position3;
+	/*!
+	 * Touch Screen contact value
+	 */
+	unsigned int contact_resistance;
+} t_touch_screen;
+
+/*!
+ * This enumeration defines ADC conversion modes.
+ */
+typedef enum {
+	/*!
+	 * Sample 8 channels, 1 sample per channel
+	 */
+	ADC_8CHAN_1X = 0,
+	/*!
+	 * Sample 1 channel 8 times
+	 */
+	ADC_1CHAN_8X,
+} t_conversion_mode;
+
+/*!
+ * This structure is used with IOCTL code \a PMIC_ADC_CONVERT,
+ * \a PMIC_ADC_CONVERT_8X and \a PMIC_ADC_CONVERT_MULTICHANNEL.
+ */
+
+typedef struct {
+	/*!
+	 * channel or channels to be sampled.
+	 */
+	t_channel channel;
+	/*!
+	 * holds up to 16 sampling results
+	 */
+	unsigned short result[16];
+} t_adc_convert_param;
+
+/*!
+ * This structure is used to activate/deactivate ADC comparator.
+ */
+typedef struct {
+	/*!
+	 * wlow.
+	 */
+	unsigned char wlow;
+	/*!
+	 * whigh.
+	 */
+	unsigned char whigh;
+	/*!
+	 * channel to monitor
+	 */
+	t_channel channel;
+	/*!
+	 * callback function.
+	 */
+	t_comparator_cb callback;
+} t_adc_comp_param;
+
+/* EXPORTED FUNCTIONS */
+
+#ifdef __KERNEL__
+/*!
+ * This function initializes all ADC registers with default values. This
+ * function also registers the interrupt events.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_init(void);
+
+/*!
+ * This function disables the ADC, de-registers the interrupt events.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_deinit(void);
+
+/*!
+ * This function triggers a conversion and returns one sampling result of one
+ * channel.
+ *
+ * @param        channel   The channel to be sampled
+ * @param        result    The pointer to the conversion result. The memory
+ *                         should be allocated by the caller of this function.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_adc_convert(t_channel channel, unsigned short *result);
+
+/*!
+ * This function triggers a conversion and returns eight sampling results of
+ * one channel.
+ *
+ * @param        channel   The channel to be sampled
+ * @param        result    The pointer to array to store eight sampling results.
+ *                         The memory should be allocated by the caller of this
+ *                         function.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_adc_convert_8x(t_channel channel, unsigned short *result);
+
+/*!
+ * This function triggers a conversion and returns sampling results of each
+ * specified channel.
+ *
+ * @param        channels  This input parameter is bitmap to specify channels
+ *                         to be sampled.
+ * @param        result    The pointer to array to store sampling result.
+ *                         The order of the result in the array is from lowest
+ *                         channel number to highest channel number of the
+ *                         sampled channels.
+ *                         The memory should be allocated by the caller of this
+ *                         function.
+ *			   Note that the behavior of this function might differ
+ *			   from one platform to another regarding especially
+ *			   channels order.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_adc_convert_multichnnel(t_channel channels,
+					 unsigned short *result);
+
+/*!
+ * This function sets touch screen operation mode.
+ *
+ * @param        touch_mode   Touch screen operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_set_touch_mode(t_touch_mode touch_mode);
+
+/*!
+ * This function retrieves the current touch screen operation mode.
+ *
+ * @param        touch_mode   Pointer to the retrieved touch screen operation
+ *                            mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_get_touch_mode(t_touch_mode * touch_mode);
+
+/*!
+ * This function retrieves the current touch screen operation mode.
+ *
+ * @param        touch_sample Pointer to touch sample.
+ * @param        wait	Indicates if this function needs to block or not.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_get_touch_sample(t_touch_screen * ts_value, int wait);
+
+/*!
+ * This function starts a Battery Current mode conversion.
+ *
+ * @param        mode      Conversion mode.
+ * @param        result    Battery Current measurement result.
+ *                         if \a mode = ADC_8CHAN_1X, the result is \n
+ *                             result[0] = (BATTP - BATT_I) \n
+ *                         if \a mode = ADC_1CHAN_8X, the result is \n
+ *                             result[0] = BATTP \n
+ *                             result[1] = BATT_I \n
+ *                             result[2] = BATTP \n
+ *                             result[3] = BATT_I \n
+ *                             result[4] = BATTP \n
+ *                             result[5] = BATT_I \n
+ *                             result[6] = BATTP \n
+ *                             result[7] = BATT_I
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_get_battery_current(t_conversion_mode mode,
+					 unsigned short *result);
+
+/*!
+ * This function actives the comparator.  When comparator is activated and ADC
+ * is enabled, the 8th converted value will be digitally compared against the
+ * window defined by WLOW and WHIGH registers.
+ *
+ * @param        low      Comparison window low threshold (WLOW).
+ * @param        high     Comparison window high threshold (WHIGH).
+ * @param        callback Callback function to be called when the converted
+ *                        value is beyond the comparison window.  The callback
+ *                        function will pass a parameter of type
+ *                        \b t_comp_expection to indicate the reason of
+ *                        comparator exception.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_adc_active_comparator(unsigned char low,
+				       unsigned char high,
+				       t_channel channel,
+				       t_comparator_cb callback);
+
+/*!
+ * This function de-actives the comparator.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_deactive_comparator(void);
+
+/*!
+ * This function enables the touch screen read interface.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_adc_install_ts(void);
+
+/*!
+ * This function disables the touch screen read interface.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_adc_remove_ts(void);
+
+int is_pmic_adc_ready(void);
+
+#endif				/* _KERNEL */
+#endif				/* __ASM_ARCH_MXC_PMIC_ADC_H__ */
diff --git a/include/linux/pmic_battery.h b/include/linux/pmic_battery.h
new file mode 100644
index 0000000..b32136d
--- /dev/null
+++ b/include/linux/pmic_battery.h
@@ -0,0 +1,419 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_BATTERY_H__
+#define __ASM_ARCH_MXC_PMIC_BATTERY_H__
+
+/*!
+ * @defgroup PMIC_BATTERY PMIC Battery Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file arch-mxc/pmic_battery.h
+ * @brief This is the header of PMIC Battery driver.
+ *
+ * @ingroup PMIC_BATTERY
+ */
+
+#include <linux/ioctl.h>
+#include <linux/pmic_status.h>
+#include <linux/pmic_external.h>
+
+/*!
+ * @name IOCTL user space interface
+ */
+
+/*! @{ */
+/*!
+ * Enable and disable charger.
+ * Argument type: pointer to t_charger_setting
+ */
+#define PMIC_BATT_CHARGER_CONTROL              _IOW('p', 0xc0, int)
+/*!
+ * Set charger configuration.
+ * Argument type: pointer to t_charger_setting
+ */
+#define PMIC_BATT_SET_CHARGER                  _IOW('p', 0xc1, int)
+/*!
+ * Get charger configuration.
+ * Argument type: pointer to t_charger_setting
+ */
+#define PMIC_BATT_GET_CHARGER                  _IOR('p', 0xc2, int)
+/*!
+ * Get charger current.
+ * Argument type: pointer to t_charger_setting
+ */
+#define PMIC_BATT_GET_CHARGER_CURRENT          _IOR('p', 0xc3, int)
+/*!
+ * Set EOL control
+ * Argument type: pointer to t_eol_setting
+ */
+#define PMIC_BATT_EOL_CONTROL                   _IOW('p', 0xc4, int)
+/*!
+ * Enable and disable charging LED.
+ * Argument type: bool
+ */
+#define PMIC_BATT_LED_CONTROL                   _IOW('p', 0xc5, int)
+/*!
+ * Enable and disable reverse supply.
+ * Argument type: bool
+ */
+#define PMIC_BATT_REV_SUPP_CONTROL              _IOW('p', 0xc6, int)
+/*!
+ * Enable and disable unregulated charging mode.
+ * Argument type: bool
+ */
+#define PMIC_BATT_UNREG_CONTROL                 _IOW('p', 0xc7, int)
+
+/*!
+ * Set the output controls.
+ * Argument type: t_control
+ */
+#define PMIC_BATT_SET_OUT_CONTROL                _IOW('p', 0xc8, int)
+/*!
+ * Set the over voltage threshold.
+ * Argument type: int
+ */
+#define PMIC_BATT_SET_THRESHOLD	                 _IOW('p', 0xc9, int)
+
+/*!
+ * Get the charger voltage.
+ * Argument type: int
+ */
+#define PMIC_BATT_GET_CHARGER_VOLTAGE		_IOR('p', 0xca, int)
+/*!
+ * Get the battery voltage.
+ * Argument type: int
+ */
+#define PMIC_BATT_GET_BATTERY_VOLTAGE		_IOR('p', 0xcb, int)
+/*!
+ * Get the battery current.
+ * Argument type: int
+ */
+#define PMIC_BATT_GET_BATTERY_CURRENT		_IOR('p', 0xcc, int)
+/*!
+ * Get the charger sensor.
+ * Argument type: int
+ */
+#define PMIC_BATT_GET_CHARGER_SENSOR		_IOR('p', 0xcd, int)
+/*!
+ * Get the battery temperature.
+ * Argument type: int
+ */
+#define PMIC_BATT_GET_BATTERY_TEMPERATURE	_IOR('p', 0xce, int)
+/*! @} */
+
+/*!
+ * This enumeration defines battery chargers.
+ */
+typedef enum {
+	BATT_MAIN_CHGR = 0,	/*!< Main battery charger */
+	BATT_CELL_CHGR,		/*!< Cell battery charger */
+	BATT_TRCKLE_CHGR	/*!< Trickle charger (only available on mc13783) */
+} t_batt_charger;
+
+/*!
+ * This enumeration defines the bp threshold.
+ */
+typedef enum {
+	BATT_BP_0 = 0,		/*!< LOBATL UVDET + 0.2 */
+	BATT_BP_1,		/*!< LOBATL UVDET + 0.3 */
+	BATT_BP_2,		/*!< LOBATL UVDET + 0.4 */
+	BATT_BP_3		/*!< LOBATL UVDET + 0.5 */
+} t_bp_threshold;
+
+/*!
+ * This enumeration of all types of output controls
+ */
+typedef enum {
+	/*!
+	 * controlled hardware
+	 */
+	CONTROL_HARDWARE = 0,
+	/*!
+	 * BPFET is driven low, BATTFET is driven high
+	 */
+	CONTROL_BPFET_LOW,
+	/*!
+	 * BPFET is driven high, BATTFET is driven low
+	 */
+	CONTROL_BPFET_HIGH,
+} t_control;
+
+/*!
+ * This enumeration define all battery interrupt
+ */
+typedef enum {
+	/*!
+	 * Charge detection interrupt
+	 */
+	BAT_IT_CHG_DET,
+	/*!
+	 * Charge over voltage detection it
+	 */
+	BAT_IT_CHG_OVERVOLT,
+	/*!
+	 * Charge path reverse current it
+	 */
+	BAT_IT_CHG_REVERSE,
+	/*!
+	 * Charge path short circuitin revers supply mode it
+	 */
+	BAT_IT_CHG_SHORT_CIRCUIT,
+	/*!
+	 * Charger has switched its mode (CC to CV or CV to CC)
+	 */
+	BAT_IT_CCCV,
+	/*!
+	 * Charge current has dropped below its threshold
+	 */
+	BAT_IT_BELOW_THRESHOLD,
+} t_batt_event;
+
+/*!
+ * This structure is used for the following battery changer control
+ * IOCTLs:
+ * - PMIC_BATT_CHARGER_CONTROL
+ * - PMIC_BATT_SET_CHARGER
+ * - PMIC_BATT_GET_CHARGER
+ */
+typedef struct {
+	/*!
+	 * Charger
+	 */
+	t_batt_charger chgr;
+	/*!
+	 * Turn on charger
+	 */
+	bool on;
+	/*!
+	 * Charging voltage
+	 */
+	unsigned char c_voltage;
+	/*!
+	 * Charging current
+	 */
+	unsigned char c_current;
+} t_charger_setting;
+
+/*!
+ * This structure is used for EOL setting IOCTL PMIC_BATT_EOL_CONTROL
+ */
+typedef struct {
+	/*!
+	 * Enable EOL comparator
+	 */
+	bool enable;
+	/*!
+	 * c_voltage threshold - Used on SC55112
+	 */
+	unsigned char threshold;
+	/*!
+	 * bp threshold - Used on mc13783
+	 */
+	t_bp_threshold typical;
+} t_eol_setting;
+
+/* EXPORTED FUNCTIONS */
+
+#ifdef __KERNEL__
+
+/*START: for 3ds hw event*/
+/*!
+ * Battery event type enum
+ */
+enum {
+	BAT_EVENT_CHARGER_PLUG = 0x01,
+	BAT_EVENT_CHARGER_UNPLUG = 0x02,
+	BAT_EVENT_CHARGER_OVERVOLTAGE = 0x04,
+	BAT_EVENT_BATTERY_LOW = 0x08,
+	BAT_EVENT_POWER_FAILED = 0x10,
+	BAT_EVENT_CHARGER_FULL = 0x20,
+} t_bat_event;
+/*END: for 3ds hw event*/
+
+/*!
+ * This function is used to start charging a battery. For different charger,
+ * different c_voltage and current range are supported. \n
+ *
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ * @param      c_voltage     Charging voltage.
+ * @param      c_current     Charging current.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_enable_charger(t_batt_charger chgr,
+				     unsigned char c_voltage,
+				     unsigned char c_current);
+
+/*!
+ * This function turns off a charger.
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_disable_charger(t_batt_charger chgr);
+
+/*!
+ * This function is used to change the charger setting.
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ * @param      c_voltage   Charging voltage.
+ * @param      c_current   Charging current.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_charger(t_batt_charger chgr,
+				  unsigned char c_voltage,
+				  unsigned char c_current);
+
+/*!
+ * This function is used to retrieve the charger setting.
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ * @param      c_voltage   Output parameter for charging c_voltage setting.
+ * @param      c_current   Output parameter for charging current setting.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_get_charger_setting(t_batt_charger chgr,
+					  unsigned char *c_voltage,
+					  unsigned char *c_current);
+
+/*!
+ * This function is retrieves the main battery charging current.
+ *
+ * @param      c_current     Output parameter for charging current setting.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_batt_get_charge_current(unsigned short *c_current);
+
+/*!
+ * This function enables End-of-Life comparator.
+ *
+ * @param      threshold  End-of-Life threshold.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_enable_eol(unsigned char threshold);
+
+/*!
+ * This function enables End-of-Life comparator.
+ *
+ * @param      typical  Falling Edge Threshold threshold.
+ *                      @verbatim
+                        BPDET   UVDET   LOBATL
+                        ____    _____   ___________
+                        0       2.6     UVDET + 0.2
+                        1       2.6     UVDET + 0.3
+                        2       2.6     UVDET + 0.4
+                        3       2.6     UVDET + 0.5
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_bp_enable_eol(t_bp_threshold typical);
+
+/*!
+ * This function disables End-of-Life comparator.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_disable_eol(void);
+
+/*!
+ * This function sets the output controls.
+ * It sets the FETOVRD and FETCTRL bits of mc13783
+ *
+ * @param        control        type of control.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_set_out_control(t_control control);
+
+/*!
+ * This function sets over voltage threshold.
+ *
+ * @param        threshold      value of over voltage threshold.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_set_threshold(int threshold);
+
+/*!
+ * This function controls charge LED.
+ *
+ * @param      on   If on is true, LED will be turned on,
+ *                  or otherwise, LED will be turned off.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_led_control(bool on);
+
+/*!
+ * This function sets reverse supply mode.
+ *
+ * @param      enable     If enable is true, reverse supply mode is enable,
+ *                        or otherwise, reverse supply mode is disabled.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_reverse_supply(bool enable);
+
+/*!
+ * This function sets unregulated charging mode on main battery.
+ *
+ * @param      enable     If enable is true, unregulated charging mode is
+ *                        enable, or otherwise, disabled.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_unregulated(bool enable);
+
+/*!
+ * This function sets a 5K pull down at CHRGRAW.
+ * To be used in the dual path charging configuration.
+ *
+ * @param      enable     If enable is true, 5k pull down is
+ *                        enable, or otherwise, disabled.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_5k_pull(bool enable);
+
+/*!
+ * This function is used to subscribe on battery event IT.
+ *
+ * @param        event          type of event.
+ * @param        callback       event callback function.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_event_subscribe(t_batt_event event, void *callback);
+
+/*!
+ * This function is used to un subscribe on battery event IT.
+ *
+ * @param        event          type of event.
+ * @param        callback       event callback function.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_event_unsubscribe(t_batt_event event, void *callback);
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_PMIC_BATTERY_H__ */
diff --git a/include/linux/pmic_external.h b/include/linux/pmic_external.h
new file mode 100644
index 0000000..ea5f5d4
--- /dev/null
+++ b/include/linux/pmic_external.h
@@ -0,0 +1,1131 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_EXTERNAL_H__
+#define __ASM_ARCH_MXC_PMIC_EXTERNAL_H__
+
+#ifdef __KERNEL__
+#include <linux/list.h>
+#endif
+
+/*!
+ * @defgroup PMIC_DRVRS PMIC Drivers
+ */
+
+/*!
+ * @defgroup PMIC_CORE PMIC Protocol Drivers
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file arch-mxc/pmic_external.h
+ * @brief This file contains interface of PMIC protocol driver.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+#include <linux/ioctl.h>
+#include <linux/pmic_status.h>
+
+/*!
+ * This is the enumeration of versions of PMIC
+ */
+typedef enum {
+	PMIC_MC13783 = 1,	/*!< MC13783 */
+	PMIC_SC55112 = 2,	/*!< SC55112 */
+	PMIC_MC13892 = 3,
+	PMIC_MC34704 = 4
+} pmic_id_t;
+
+/*!
+ * @struct pmic_version_t
+ * @brief PMIC version and revision
+ */
+typedef struct {
+	/*!
+	 * PMIC version identifier.
+	 */
+	pmic_id_t id;
+	/*!
+	 * Revision of the PMIC.
+	 */
+	int revision;
+} pmic_version_t;
+
+/*!
+ * struct pmic_event_callback_t
+ * @brief This structure contains callback function pointer and its
+ * parameter to be used when un/registering and launching a callback
+ * for an event.
+ */
+typedef struct {
+	/*!
+	 * call back function
+	 */
+	void (*func) (void *);
+
+	/*!
+	 * call back function parameter
+	 */
+	void *param;
+} pmic_event_callback_t;
+
+/*!
+ * This structure is used with IOCTL.
+ * It defines register, register value, register mask and event number
+ */
+typedef struct {
+	/*!
+	 * register number
+	 */
+	int reg;
+	/*!
+	 * value of register
+	 */
+	unsigned int reg_value;
+	/*!
+	 * mask of bits, only used with PMIC_WRITE_REG
+	 */
+	unsigned int reg_mask;
+} register_info;
+
+/*!
+ * @name IOCTL definitions for sc55112 core driver
+ */
+/*! @{ */
+/*! Read a PMIC register */
+#define PMIC_READ_REG          _IOWR('P', 0xa0, register_info*)
+/*! Write a PMIC register */
+#define PMIC_WRITE_REG         _IOWR('P', 0xa1, register_info*)
+/*! Subscribe a PMIC interrupt event */
+#define PMIC_SUBSCRIBE         _IOR('P', 0xa2, int)
+/*! Unsubscribe a PMIC interrupt event */
+#define PMIC_UNSUBSCRIBE       _IOR('P', 0xa3, int)
+/*! Subscribe a PMIC event for user notification*/
+#define PMIC_NOTIFY_USER       _IOR('P', 0xa4, int)
+/*! Get the PMIC event occured for which user recieved notification */
+#define PMIC_GET_NOTIFY	       _IOW('P', 0xa5, int)
+/*! @} */
+
+/*!
+ * This is PMIC registers valid bits
+ */
+#define PMIC_ALL_BITS           0xFFFFFF
+#define PMIC_MAX_EVENTS		48
+
+#define PMIC_ARBITRATION	"NULL"
+
+#ifdef CONFIG_MXC_PMIC_MC13783
+/*!
+ * This is the enumeration of register names of MC13783
+ */
+typedef enum {
+	/*!
+	 * REG_INTERRUPT_STATUS_0
+	 */
+	REG_INTERRUPT_STATUS_0 = 0,
+	/*!
+	 * REG_INTERRUPT_MASK_0
+	 */
+	REG_INTERRUPT_MASK_0,
+	/*!
+	 * REG_INTERRUPT_SENSE_0
+	 */
+	REG_INTERRUPT_SENSE_0,
+	/*!
+	 * REG_INTERRUPT_STATUS_1
+	 */
+	REG_INTERRUPT_STATUS_1,
+	/*!
+	 * REG_INTERRUPT_MASK_1
+	 */
+	REG_INTERRUPT_MASK_1,
+	/*!
+	 * REG_INTERRUPT_SENSE_1
+	 */
+	REG_INTERRUPT_SENSE_1,
+	/*!
+	 * REG_POWER_UP_MODE_SENSE
+	 */
+	REG_POWER_UP_MODE_SENSE,
+	/*!
+	 * REG_REVISION
+	 */
+	REG_REVISION,
+	/*!
+	 * REG_SEMAPHORE
+	 */
+	REG_SEMAPHORE,
+	/*!
+	 * REG_ARBITRATION_PERIPHERAL_AUDIO
+	 */
+	REG_ARBITRATION_PERIPHERAL_AUDIO,
+	/*!
+	 * REG_ARBITRATION_SWITCHERS
+	 */
+	REG_ARBITRATION_SWITCHERS,
+	/*!
+	 * REG_ARBITRATION_REGULATORS_0
+	 */
+	REG_ARBITRATION_REGULATORS_0,
+	/*!
+	 * REG_ARBITRATION_REGULATORS_1
+	 */
+	REG_ARBITRATION_REGULATORS_1,
+	/*!
+	 * REG_POWER_CONTROL_0
+	 */
+	REG_POWER_CONTROL_0,
+	/*!
+	 * REG_POWER_CONTROL_1
+	 */
+	REG_POWER_CONTROL_1,
+	/*!
+	 * REG_POWER_CONTROL_2
+	 */
+	REG_POWER_CONTROL_2,
+	/*!
+	 * REG_REGEN_ASSIGNMENT
+	 */
+	REG_REGEN_ASSIGNMENT,
+	/*!
+	 * REG_CONTROL_SPARE
+	 */
+	REG_CONTROL_SPARE,
+	/*!
+	 * REG_MEMORY_A
+	 */
+	REG_MEMORY_A,
+	/*!
+	 * REG_MEMORY_B
+	 */
+	REG_MEMORY_B,
+	/*!
+	 * REG_RTC_TIME
+	 */
+	REG_RTC_TIME,
+	/*!
+	 * REG_RTC_ALARM
+	 */
+	REG_RTC_ALARM,
+	/*!
+	 * REG_RTC_DAY
+	 */
+	REG_RTC_DAY,
+	/*!
+	 * REG_RTC_DAY_ALARM
+	 */
+	REG_RTC_DAY_ALARM,
+	/*!
+	 * REG_SWITCHERS_0
+	 */
+	REG_SWITCHERS_0,
+	/*!
+	 * REG_SWITCHERS_1
+	 */
+	REG_SWITCHERS_1,
+	/*!
+	 * REG_SWITCHERS_2
+	 */
+	REG_SWITCHERS_2,
+	/*!
+	 * REG_SWITCHERS_3
+	 */
+	REG_SWITCHERS_3,
+	/*!
+	 * REG_SWITCHERS_4
+	 */
+	REG_SWITCHERS_4,
+	/*!
+	 * REG_SWITCHERS_5
+	 */
+	REG_SWITCHERS_5,
+	/*!
+	 * REG_REGULATOR_SETTING_0
+	 */
+	REG_REGULATOR_SETTING_0,
+	/*!
+	 * REG_REGULATOR_SETTING_1
+	 */
+	REG_REGULATOR_SETTING_1,
+	/*!
+	 * REG_REGULATOR_MODE_0
+	 */
+	REG_REGULATOR_MODE_0,
+	/*!
+	 * REG_REGULATOR_MODE_1
+	 */
+	REG_REGULATOR_MODE_1,
+	/*!
+	 * REG_POWER_MISCELLANEOUS
+	 */
+	REG_POWER_MISCELLANEOUS,
+	/*!
+	 * REG_POWER_SPARE
+	 */
+	REG_POWER_SPARE,
+	/*!
+	 * REG_AUDIO_RX_0
+	 */
+	REG_AUDIO_RX_0,
+	/*!
+	 * REG_AUDIO_RX_1
+	 */
+	REG_AUDIO_RX_1,
+	/*!
+	 * REG_AUDIO_TX
+	 */
+	REG_AUDIO_TX,
+	/*!
+	 * REG_AUDIO_SSI_NETWORK
+	 */
+	REG_AUDIO_SSI_NETWORK,
+	/*!
+	 * REG_AUDIO_CODEC
+	 */
+	REG_AUDIO_CODEC,
+	/*!
+	 * REG_AUDIO_STEREO_DAC
+	 */
+	REG_AUDIO_STEREO_DAC,
+	/*!
+	 * REG_AUDIO_SPARE
+	 */
+	REG_AUDIO_SPARE,
+	/*!
+	 * REG_ADC_0
+	 */
+	REG_ADC_0,
+	/*!
+	 * REG_ADC_1
+	 */
+	REG_ADC_1,
+	/*!
+	 * REG_ADC_2
+	 */
+	REG_ADC_2,
+	/*!
+	 * REG_ADC_3
+	 */
+	REG_ADC_3,
+	/*!
+	 * REG_ADC_4
+	 */
+	REG_ADC_4,
+	/*!
+	 * REG_CHARGER
+	 */
+	REG_CHARGER,
+	/*!
+	 * REG_USB
+	 */
+	REG_USB,
+	/*!
+	 * REG_CHARGE_USB_SPARE
+	 */
+	REG_CHARGE_USB_SPARE,
+	/*!
+	 * REG_LED_CONTROL_0
+	 */
+	REG_LED_CONTROL_0,
+	/*!
+	 * REG_LED_CONTROL_1
+	 */
+	REG_LED_CONTROL_1,
+	/*!
+	 * REG_LED_CONTROL_2
+	 */
+	REG_LED_CONTROL_2,
+	/*!
+	 * REG_LED_CONTROL_3
+	 */
+	REG_LED_CONTROL_3,
+	/*!
+	 * REG_LED_CONTROL_4
+	 */
+	REG_LED_CONTROL_4,
+	/*!
+	 * REG_LED_CONTROL_5
+	 */
+	REG_LED_CONTROL_5,
+	/*!
+	 * REG_SPARE
+	 */
+	REG_SPARE,
+	/*!
+	 * REG_TRIM_0
+	 */
+	REG_TRIM_0,
+	/*!
+	 * REG_TRIM_1
+	 */
+	REG_TRIM_1,
+	/*!
+	 * REG_TEST_0
+	 */
+	REG_TEST_0,
+	/*!
+	 * REG_TEST_1
+	 */
+	REG_TEST_1,
+	/*!
+	 * REG_TEST_2
+	 */
+	REG_TEST_2,
+	/*!
+	 * REG_TEST_3
+	 */
+	REG_TEST_3,
+	/*!
+	 * REG_NB
+	 */
+	REG_NB,
+} pmic_reg;
+
+/*!
+ * This is event list of mc13783 interrupt
+ */
+
+typedef enum {
+	/*!
+	 * ADC has finished requested conversions
+	 */
+	EVENT_ADCDONEI = 0,
+	/*!
+	 * ADCBIS has finished requested conversions
+	 */
+	EVENT_ADCBISDONEI = 1,
+	/*!
+	 * Touchscreen wakeup
+	 */
+	EVENT_TSI = 2,
+	/*!
+	 * ADC reading above high limit
+	 */
+	EVENT_WHIGHI = 3,
+	/*!
+	 * ADC reading below low limit
+	 */
+	EVENT_WLOWI = 4,
+	/*!
+	 * Charger attach and removal
+	 */
+	EVENT_CHGDETI = 6,
+	/*!
+	 * Charger over-voltage detection
+	 */
+	EVENT_CHGOVI = 7,
+	/*!
+	 * Charger path reverse current
+	 */
+	EVENT_CHGREVI = 8,
+	/*!
+	 * Charger path short circuit
+	 */
+	EVENT_CHGSHORTI = 9,
+	/*!
+	 * BP regulator current or voltage regulation
+	 */
+	EVENT_CCCVI = 10,
+	/*!
+	 * Charge current below threshold
+	 */
+	EVENT_CHRGCURRI = 11,
+	/*!
+	 * BP turn on threshold detection
+	 */
+	EVENT_BPONI = 12,
+	/*!
+	 * End of life / low battery detect
+	 */
+	EVENT_LOBATLI = 13,
+	/*!
+	 * Low battery warning
+	 */
+	EVENT_LOBATHI = 14,
+	/*!
+	 * USB detect
+	 */
+	EVENT_USBI = 16,
+	/*!
+	 * USB ID Line detect
+	 */
+	EVENT_IDI = 19,
+	/*!
+	 * Single ended 1 detect
+	 */
+	EVENT_SE1I = 21,
+	/*!
+	 * Car-kit detect
+	 */
+	EVENT_CKDETI = 22,
+	/*!
+	 * 1 Hz time-tick
+	 */
+	EVENT_E1HZI = 24,
+	/*!
+	 * Time of day alarm
+	 */
+	EVENT_TODAI = 25,
+	/*!
+	 * ON1B event
+	 */
+	EVENT_ONOFD1I = 27,
+	/*!
+	 * ON2B event
+	 */
+	EVENT_ONOFD2I = 28,
+	/*!
+	 * ON3B event
+	 */
+	EVENT_ONOFD3I = 29,
+	/*!
+	 * System reset
+	 */
+	EVENT_SYSRSTI = 30,
+	/*!
+	 * RTC reset occurred
+	 */
+	EVENT_RTCRSTI = 31,
+	/*!
+	 * Power cut event
+	 */
+	EVENT_PCI = 32,
+	/*!
+	 * Warm start event
+	 */
+	EVENT_WARMI = 33,
+	/*!
+	 * Memory hold event
+	 */
+	EVENT_MEMHLDI = 34,
+	/*!
+	 * Power ready
+	 */
+	EVENT_PWRRDYI = 35,
+	/*!
+	 * Thermal warning lower threshold
+	 */
+	EVENT_THWARNLI = 36,
+	/*!
+	 * Thermal warning higher threshold
+	 */
+	EVENT_THWARNHI = 37,
+	/*!
+	 * Clock source change
+	 */
+	EVENT_CLKI = 38,
+	/*!
+	 * Semaphore
+	 */
+	EVENT_SEMAFI = 39,
+	/*!
+	 * Microphone bias 2 detect
+	 */
+	EVENT_MC2BI = 41,
+	/*!
+	 * Headset attach
+	 */
+	EVENT_HSDETI = 42,
+	/*!
+	 * Stereo headset detect
+	 */
+	EVENT_HSLI = 43,
+	/*!
+	 * Thermal shutdown ALSP
+	 */
+	EVENT_ALSPTHI = 44,
+	/*!
+	 * Short circuit on AHS outputs
+	 */
+	EVENT_AHSSHORTI = 45,
+	/*!
+	 * number of event
+	 */
+	EVENT_NB,
+} type_event;
+
+/*!
+ * This enumeration all senses of MC13783.
+ */
+typedef enum {
+	/*!
+	 * Charger attach sense
+	 */
+	SENSE_CHGDETS = 6,
+	/*!
+	 * Charger over-voltage sense
+	 */
+	SENSE_CHGOVS,
+	/*!
+	 * Charger reverse current
+	 * If 1 current flows into phone
+	 */
+	SENSE_CHGREVS,
+	/*!
+	 * Charger short circuit
+	 */
+	SENSE_CHGSHORTS,
+	/*!
+	 * Charger regulator operating mode
+	 */
+	SENSE_CCCVS,
+	/*!
+	 * Charger current below threshold
+	 */
+	SENSE_CHGCURRS,
+	/*!
+	 * BP turn on
+	 */
+	SENSE_BPONS,
+	/*!
+	 * Low bat detect
+	 */
+	SENSE_LOBATLS,
+	/*!
+	 * Low bat warning
+	 */
+	SENSE_LOBATHS,
+	/*!
+	 * UDPS
+	 */
+	SENSE_UDPS,
+	/*!
+	 * USB 4V4
+	 */
+	SENSE_USB4V4S,
+	/*!
+	 * USB 2V0
+	 */
+	SENSE_USB2V0S,
+	/*!
+	 * USB 0V8
+	 */
+	SENSE_USB0V8S,
+	/*!
+	 * ID Floats
+	 */
+	SENSE_ID_FLOATS,
+	/*!
+	 * ID Gnds
+	 */
+	SENSE_ID_GNDS,
+	/*!
+	 * Single ended
+	 */
+	SENSE_SE1S,
+	/*!
+	 * Car-kit detect
+	 */
+	SENSE_CKDETS,
+	/*!
+	 * UDMS
+	 */
+	SENSE_UDMS,
+	/*!
+	 * mic bias detect
+	 */
+	SENSE_MC2BS,
+	/*!
+	 * headset attached
+	 */
+	SENSE_HSDETS,
+	/*!
+	 * ST headset attached
+	 */
+	SENSE_HSLS,
+	/*!
+	 * Thermal shutdown ALSP
+	 */
+	SENSE_ALSPTHS,
+	/*!
+	 * short circuit on AHS
+	 */
+	SENSE_AHSSHORTS,
+	/*!
+	 * ON1B pin is hight
+	 */
+	SENSE_ONOFD1S,
+	/*!
+	 * ON2B pin is hight
+	 */
+	SENSE_ONOFD2S,
+	/*!
+	 * ON3B pin is hight
+	 */
+	SENSE_ONOFD3S,
+	/*!
+	 * System reset power ready
+	 */
+	SENSE_PWRRDYS,
+	/*!
+	 * Thermal warning higher threshold
+	 */
+	SENSE_THWARNHS,
+	/*!
+	 * Thermal warning lower threshold
+	 */
+	SENSE_THWARNLS,
+	/*!
+	 * Clock source is XTAL
+	 */
+	SENSE_CLKS,
+} t_sensor;
+
+/*!
+ * This structure is used to read all sense bits of MC13783.
+ */
+typedef struct {
+	/*!
+	 * Charger attach sense
+	 */
+	bool sense_chgdets;
+	/*!
+	 * Charger over-voltage sense
+	 */
+	bool sense_chgovs;
+	/*!
+	 * Charger reverse current
+	 * If 1 current flows into phone
+	 */
+	bool sense_chgrevs;
+	/*!
+	 * Charger short circuit
+	 */
+	bool sense_chgshorts;
+	/*!
+	 * Charger regulator operating mode
+	 */
+	bool sense_cccvs;
+	/*!
+	 * Charger current below threshold
+	 */
+	bool sense_chgcurrs;
+	/*!
+	 * BP turn on
+	 */
+	bool sense_bpons;
+	/*!
+	 * Low bat detect
+	 */
+	bool sense_lobatls;
+	/*!
+	 * Low bat warning
+	 */
+	bool sense_lobaths;
+	/*!
+	 * USB 4V4
+	 */
+	bool sense_usb4v4s;
+	/*!
+	 * USB 2V0
+	 */
+	bool sense_usb2v0s;
+	/*!
+	 * USB 0V8
+	 */
+	bool sense_usb0v8s;
+	/*!
+	 * ID Floats
+	 */
+	bool sense_id_floats;
+	/*!
+	 * ID Gnds
+	 */
+	bool sense_id_gnds;
+	/*!
+	 * Single ended
+	 */
+	bool sense_se1s;
+	/*!
+	 * Car-kit detect
+	 */
+	bool sense_ckdets;
+	/*!
+	 * mic bias detect
+	 */
+	bool sense_mc2bs;
+	/*!
+	 * headset attached
+	 */
+	bool sense_hsdets;
+	/*!
+	 * ST headset attached
+	 */
+	bool sense_hsls;
+	/*!
+	 * Thermal shutdown ALSP
+	 */
+	bool sense_alspths;
+	/*!
+	 * short circuit on AHS
+	 */
+	bool sense_ahsshorts;
+	/*!
+	 * ON1B pin is hight
+	 */
+	bool sense_onofd1s;
+	/*!
+	 * ON2B pin is hight
+	 */
+	bool sense_onofd2s;
+	/*!
+	 * ON3B pin is hight
+	 */
+	bool sense_onofd3s;
+	/*!
+	 * System reset power ready
+	 */
+	bool sense_pwrrdys;
+	/*!
+	 * Thermal warning higher threshold
+	 */
+	bool sense_thwarnhs;
+	/*!
+	 * Thermal warning lower threshold
+	 */
+	bool sense_thwarnls;
+	/*!
+	 * Clock source is XTAL
+	 */
+	bool sense_clks;
+} t_sensor_bits;
+
+#endif				/*CONFIG_MXC_PMIC_MC13783 */
+
+#if defined(CONFIG_MXC_PMIC_MC13892_MODULE) || defined(CONFIG_MXC_PMIC_MC13892)
+enum {
+	REG_INT_STATUS0 = 0,
+	REG_INT_MASK0,
+	REG_INT_SENSE0,
+	REG_INT_STATUS1,
+	REG_INT_MASK1,
+	REG_INT_SENSE1,
+	REG_PU_MODE_S,
+	REG_IDENTIFICATION,
+	REG_UNUSED0,
+	REG_ACC0,
+	REG_ACC1,		/*10 */
+	REG_UNUSED1,
+	REG_UNUSED2,
+	REG_POWER_CTL0,
+	REG_POWER_CTL1,
+	REG_POWER_CTL2,
+	REG_REGEN_ASSIGN,
+	REG_UNUSED3,
+	REG_MEM_A,
+	REG_MEM_B,
+	REG_RTC_TIME,		/*20 */
+	REG_RTC_ALARM,
+	REG_RTC_DAY,
+	REG_RTC_DAY_ALARM,
+	REG_SW_0,
+	REG_SW_1,
+	REG_SW_2,
+	REG_SW_3,
+	REG_SW_4,
+	REG_SW_5,
+	REG_SETTING_0,		/*30 */
+	REG_SETTING_1,
+	REG_MODE_0,
+	REG_MODE_1,
+	REG_POWER_MISC,
+	REG_UNUSED4,
+	REG_UNUSED5,
+	REG_UNUSED6,
+	REG_UNUSED7,
+	REG_UNUSED8,
+	REG_UNUSED9,		/*40 */
+	REG_UNUSED10,
+	REG_UNUSED11,
+	REG_ADC0,
+	REG_ADC1,
+	REG_ADC2,
+	REG_ADC3,
+	REG_ADC4,
+	REG_CHARGE,
+	REG_USB0,
+	REG_USB1,		/*50 */
+	REG_LED_CTL0,
+	REG_LED_CTL1,
+	REG_LED_CTL2,
+	REG_LED_CTL3,
+	REG_UNUSED12,
+	REG_UNUSED13,
+	REG_TRIM0,
+	REG_TRIM1,
+	REG_TEST0,
+	REG_TEST1,		/*60 */
+	REG_TEST2,
+	REG_TEST3,
+	REG_TEST4,
+};
+
+typedef enum {
+	EVENT_ADCDONEI = 0,
+	EVENT_ADCBISDONEI = 1,
+	EVENT_TSI = 2,
+	EVENT_VBUSVI = 3,
+	EVENT_IDFACI = 4,
+	EVENT_USBOVI = 5,
+	EVENT_CHGDETI = 6,
+	EVENT_CHGFAULTI = 7,
+	EVENT_CHGREVI = 8,
+	EVENT_CHGRSHORTI = 9,
+	EVENT_CCCVI = 10,
+	EVENT_CHGCURRI = 11,
+	EVENT_BPONI = 12,
+	EVENT_LOBATLI = 13,
+	EVENT_LOBATHI = 14,
+	EVENT_IDFLOATI = 19,
+	EVENT_IDGNDI = 20,
+	EVENT_SE1I = 21,
+	EVENT_CKDETI = 22,
+	EVENT_1HZI = 24,
+	EVENT_TODAI = 25,
+	EVENT_PWRONI = 27,
+	EVENT_WDIRESETI = 29,
+	EVENT_SYSRSTI = 30,
+	EVENT_RTCRSTI = 31,
+	EVENT_PCI = 32,
+	EVENT_WARMI = 33,
+	EVENT_MEMHLDI = 34,
+	EVENT_THWARNLI = 36,
+	EVENT_THWARNHI = 37,
+	EVENT_CLKI = 38,
+	EVENT_SCPI = 40,
+	EVENT_LBPI = 44,
+	EVENT_NB,
+} type_event;
+
+typedef enum {
+	SENSE_VBUSVS = 3,
+	SENSE_IDFACS = 4,
+	SENSE_USBOVS = 5,
+	SENSE_CHGDETS = 6,
+	SENSE_CHGREVS = 8,
+	SENSE_CHGRSHORTS = 9,
+	SENSE_CCCVS = 10,
+	SENSE_CHGCURRS = 11,
+	SENSE_BPONS = 12,
+	SENSE_LOBATLS = 13,
+	SENSE_LOBATHS = 14,
+	SENSE_IDFLOATS = 19,
+	SENSE_IDGNDS = 20,
+	SENSE_SE1S = 21,
+	SENSE_PWRONS = 27,
+	SENSE_THWARNLS = 36,
+	SENSE_THWARNHS = 37,
+	SENSE_CLKS = 38,
+	SENSE_LBPS = 44,
+	SENSE_NB,
+} t_sensor;
+
+typedef struct {
+	bool sense_vbusvs;
+	bool sense_idfacs;
+	bool sense_usbovs;
+	bool sense_chgdets;
+	bool sense_chgrevs;
+	bool sense_chgrshorts;
+	bool sense_cccvs;
+	bool sense_chgcurrs;
+	bool sense_bpons;
+	bool sense_lobatls;
+	bool sense_lobaths;
+	bool sense_idfloats;
+	bool sense_idgnds;
+	bool sense_se1s;
+	bool sense_pwrons;
+	bool sense_thwarnls;
+	bool sense_thwarnhs;
+	bool sense_clks;
+	bool sense_lbps;
+} t_sensor_bits;
+
+extern struct i2c_client *mc13892_client;
+int pmic_i2c_24bit_read(struct i2c_client *client, unsigned int reg_num,
+			unsigned int *value);
+int pmic_read(int reg_num, unsigned int *reg_val);
+int pmic_write(int reg_num, const unsigned int reg_val);
+void gpio_pmic_active(void);
+void pmic_event_list_init(void);
+void mc13892_power_off(void);
+
+#endif
+
+#if defined(CONFIG_MXC_PMIC_MC34704_MODULE) || defined(CONFIG_MXC_PMIC_MC34704)
+
+typedef enum {
+	/* register names for mc34704 */
+	REG_MC34704_GENERAL1 = 0x01,
+	REG_MC34704_GENERAL2 = 0x02,
+	REG_MC34704_GENERAL3 = 0x03,
+	REG_MC34704_VGSET1 = 0x04,
+	REG_MC34704_VGSET2 = 0x05,
+	REG_MC34704_REG2SET1 = 0x06,
+	REG_MC34704_REG2SET2 = 0x07,
+	REG_MC34704_REG3SET1 = 0x08,
+	REG_MC34704_REG3SET2 = 0x09,
+	REG_MC34704_REG4SET1 = 0x0A,
+	REG_MC34704_REG4SET2 = 0x0B,
+	REG_MC34704_REG5SET1 = 0x0C,
+	REG_MC34704_REG5SET2 = 0x0D,
+	REG_MC34704_REG5SET3 = 0x0E,
+	REG_MC34704_REG6SET1 = 0x0F,
+	REG_MC34704_REG6SET2 = 0x10,
+	REG_MC34704_REG6SET3 = 0x11,
+	REG_MC34704_REG7SET1 = 0x12,
+	REG_MC34704_REG7SET2 = 0x13,
+	REG_MC34704_REG7SET3 = 0x14,
+	REG_MC34704_REG8SET1 = 0x15,
+	REG_MC34704_REG8SET2 = 0x16,
+	REG_MC34704_REG8SET3 = 0x17,
+	REG_MC34704_FAULTS = 0x18,
+	REG_MC34704_I2CSET1 = 0x19,
+	REG_MC34704_REG3DAC = 0x49,
+	REG_MC34704_REG7CR0 = 0x58,
+	REG_MC34704_REG7DAC = 0x59,
+	REG_NB = 0x60,
+} pmic_reg;
+
+typedef enum {
+	/* events for mc34704 */
+	EVENT_FLT1 = 0,
+	EVENT_FLT2,
+	EVENT_FLT3,
+	EVENT_FLT4,
+	EVENT_FLT5,
+	EVENT_FLT6,
+	EVENT_FLT7,
+	EVENT_FLT8,
+	EVENT_NB,
+} type_event;
+
+typedef enum {
+	MCU_SENSOR_NOT_SUPPORT
+} t_sensor;
+
+typedef enum {
+	MCU_SENSOR_BIT_NOT_SUPPORT
+} t_sensor_bits;
+
+#endif				/* MXC_PMIC_MC34704 */
+
+/* EXPORTED FUNCTIONS */
+#ifdef __KERNEL__
+
+#if defined(CONFIG_MXC_PMIC)
+/*!
+ * This function is used to determine the PMIC type and its revision.
+ *
+ * @return      Returns the PMIC type and its revision.
+ */
+pmic_version_t pmic_get_version(void);
+
+/*!
+ * This function is called by PMIC clients to read a register on PMIC.
+ *
+ * @param        priority   priority of access
+ * @param        reg        number of register
+ * @param        reg_value   return value of register
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_read_reg(int reg, unsigned int *reg_value,
+			  unsigned int reg_mask);
+/*!
+ * This function is called by PMIC clients to write a register on MC13783.
+ *
+ * @param        priority   priority of access
+ * @param        reg        number of register
+ * @param        reg_value  New value of register
+ * @param        reg_mask   Bitmap mask indicating which bits to modify
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_write_reg(int reg, unsigned int reg_value,
+			   unsigned int reg_mask);
+
+/*!
+ * This function is called by PMIC clients to subscribe on an event.
+ *
+ * @param        event_sub   structure of event, it contains type of event and callback
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_event_subscribe(type_event event,
+				 pmic_event_callback_t callback);
+/*!
+* This function is called by PMIC clients to un-subscribe on an event.
+*
+* @param        event_unsub   structure of event, it contains type of event and callback
+*
+* @return       This function returns PMIC_SUCCESS if successful.
+*/
+PMIC_STATUS pmic_event_unsubscribe(type_event event,
+				   pmic_event_callback_t callback);
+PMIC_STATUS pmic_event_unsubscribe(type_event event,
+				   pmic_event_callback_t callback);
+/*!
+* This function is called to read all sensor bits of PMIC.
+*
+* @param        sensor    Sensor to be checked.
+*
+* @return       This function returns true if the sensor bit is high;
+*               or returns false if the sensor bit is low.
+*/
+bool pmic_check_sensor(t_sensor sensor);
+
+/*!
+* This function checks one sensor of PMIC.
+*
+* @param        sensor_bits  structure of all sensor bits.
+*
+* @return       This function returns PMIC_SUCCESS if successful.
+*/
+PMIC_STATUS pmic_get_sensors(t_sensor_bits * sensor_bits);
+
+void pmic_event_callback(type_event event);
+void pmic_event_list_init(void);
+
+#ifdef CONFIG_REGULATOR_MC13783
+/*!
+ * This function is used to initialize the regulator for MC13783.
+ *
+ * @return      Returns 0.
+ */
+int reg_mc13783_probe(void);
+#else
+static inline int reg_mc13783_probe(void)
+{
+	return 0;
+};
+#endif
+
+#ifdef CONFIG_REGULATOR_MC13892
+int reg_mc13892_probe(void);
+#else
+static inline int reg_mc13892_probe(void)
+{
+	return 0;
+};
+#endif
+
+#ifdef CONFIG_REGULATOR_MC34704
+int reg_mc34704_probe(void);
+#endif
+#endif				/*CONFIG_MXC_PMIC*/
+#endif				/* __KERNEL__ */
+/* CONFIG_MXC_PMIC_MC13783 || CONFIG_MXC_PMIC_MC9SDZ60 */
+
+#endif				/* __ASM_ARCH_MXC_PMIC_EXTERNAL_H__ */
diff --git a/include/linux/pmic_light.h b/include/linux/pmic_light.h
new file mode 100644
index 0000000..8490dc1
--- /dev/null
+++ b/include/linux/pmic_light.h
@@ -0,0 +1,1082 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_LIGHT_H__
+#define __ASM_ARCH_MXC_PMIC_LIGHT_H__
+
+/*!
+ * @defgroup PMIC_LIGHT PMIC Light Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file arch-mxc/pmic_light.h
+ * @brief This is the header of PMIC Light driver.
+ *
+ * @ingroup PMIC_LIGHT
+ */
+
+#include <linux/ioctl.h>
+#include <linux/pmic_status.h>
+#include <linux/pmic_external.h>
+
+/*!
+ * @name IOCTL user space interface
+ */
+
+/*! @{ */
+/*!
+ * Enable Backlight.
+ * Argument type: none.
+ */
+#define PMIC_BKLIT_ENABLE                   _IO('p', 0xe0)
+/*!
+ * Disable Backlight.
+ * Argument type: none.
+ */
+#define PMIC_BKLIT_DISABLE                  _IO('p', 0xe1)
+/*!
+ * Set backlight configuration.
+ * Argument type: pointer to t_bklit_setting_param
+ */
+#define PMIC_SET_BKLIT                      _IOW('p', 0xe2, int)
+/*!
+ * Get backlight configuration.
+ * Argument type: pointer to t_bklit_setting_param
+ */
+#define PMIC_GET_BKLIT                      _IOWR('p', 0xe3, int)
+/*!
+ * Ramp up configuration.
+ * Argument type: t_bklit_channel
+ */
+#define PMIC_RAMPUP_BKLIT                   _IOW('p', 0xe4, int)
+/*!
+ * Ramp down configuration.
+ * Argument type: t_bklit_channel
+ */
+#define PMIC_RAMPDOWN_BKLIT                 _IOW('p', 0xe5, int)
+/*!
+ * Enable Tri-color LED.
+ * Argument type: t_tcled_enable_param
+ */
+#define PMIC_TCLED_ENABLE                   _IOW('p', 0xe6, int)
+/*!
+ * Disable Tri-color LED.
+ * Argument type: t_funlight_bank
+ */
+#define PMIC_TCLED_DISABLE                  _IOW('p', 0xe7, int)
+/*!
+ * Start Tri-color LED pattern.
+ * Argument type: t_fun_param
+ */
+#define PMIC_TCLED_PATTERN                  _IOW('p', 0xe8, int)
+/*!
+ * Enable Backlight & tcled.
+ * Argument type: none.
+ */
+#define PMIC_BKLIT_TCLED_ENABLE             _IO('p', 0xe9)
+/*!
+ * Disable Backlight & tcled.
+ * Argument type: none.
+ */
+#define PMIC_BKLIT_TCLED_DISABLE            _IO('p', 0xea)
+/*!
+ * Reset ramp up configuration.
+ * Argument type: t_bklit_channel
+ */
+#define PMIC_OFF_RAMPUP_BKLIT               _IOW('p', 0xeb, int)
+/*!
+ * Reset ramp down configuration.
+ * Argument type: t_bklit_channel
+ */
+#define PMIC_OFF_RAMPDOWN_BKLIT             _IOW('p', 0xec, int)
+/*!
+ * Set tcled ind configuration.
+ * Argument type: t_tcled_ind_param
+ */
+#define PMIC_SET_TCLED			    _IOW('p', 0xed, int)
+/*!
+ * Get tcled ind configuration.
+ * Argument type: t_tcled_ind_param
+ */
+#define PMIC_GET_TCLED			    _IOWR('p', 0xee, int)
+/*! @} */
+/*!
+ * @enum t_bklit_mode
+ * @brief Backlight modes.
+ */
+typedef enum {
+	BACKLIGHT_CURRENT_CTRL_MODE,	/*! < Current control mode */
+	BACKLIGHT_TRIODE_MODE	/*! < Triode mode */
+} t_bklit_mode;
+
+/*!
+ * @enum t_bklit_channel
+ * @brief Backlight channels.
+ */
+typedef enum {
+	BACKLIGHT_LED1,		/*! < Backlight channel 1 */
+	BACKLIGHT_LED2,		/*! < Backlight channel 2 */
+	BACKLIGHT_LED3		/*! < Backlight channel 3 */
+} t_bklit_channel;
+
+/*!
+ * @enum t_bklit_strobe_mode
+ * @brief Backlight Strobe Light Pulsing modes.
+ */
+typedef enum {
+	/*!
+	 * No Strobe Light Pulsing
+	 */
+	BACKLIGHT_STROBE_NONE,
+	/*!
+	 * Strobe Light Pulsing at 3.3% duty cycle over 300msec (Driver goes
+	 * into Triode Mode with pulses constrained to 10msec.)
+	 */
+	BACKLIGHT_STROBE_FAST,
+	/*!
+	 * Strobe Light Pulsing at 10% duty cycle over 100msec (Driver goes
+	 * into Triode Mode with pulses constrained to 10msec.)
+	 */
+	BACKLIGHT_STROBE_SLOW
+} t_bklit_strobe_mode;
+
+/*!
+ * @struct t_bklit_setting_param
+ * @brief Backlight setting.
+ */
+
+typedef struct {
+	t_bklit_channel channel;	/*!< Channel */
+	t_bklit_mode mode;	/*!< Mode */
+	t_bklit_strobe_mode strobe;	/*!< Strobe mode */
+	unsigned char current_level;	/*!< Current level */
+	unsigned char duty_cycle;	/*!< Duty cycle */
+	unsigned char cycle_time;	/*!< Cycle time */
+	bool edge_slow;		/*!< Edge Slow */
+	bool en_dis;		/*!< Enable disable boost mode */
+	unsigned int abms;	/*!< Adaptive boost
+				 *   mode selection */
+	unsigned int abr;	/*!< Adaptive
+				 *   boost reference */
+} t_bklit_setting_param;
+
+/*!
+ * @enum t_funlight_bank
+ * @brief Tri-color LED fun light banks.
+ */
+typedef enum {
+	TCLED_FUN_BANK1 = 0,	/*! < Fun light bank 1 */
+	TCLED_FUN_BANK2,	/*! < Fun light bank 2 */
+	TCLED_FUN_BANK3		/*! < Fun light bank 3 */
+} t_funlight_bank;
+
+/*!
+ * @enum t_tcled_mode
+ * @brief Tri-color LED operation modes.
+ *
+ * The Tri-Color LED Driver circuitry includes 2 modes of operation. In LED
+ * Indicator Mode, this circuitry operates as Red and Green LED Drivers with
+ * flasher timing to indicate GSM network status. In Fun Light Mode, this
+ * circuitry provides expanded capability for current control and distribution
+ * that supplements the three channels.
+ */
+typedef enum {
+	TCLED_IND_MODE = 0,	/*! < LED Indicator Mode */
+	TCLED_FUN_MODE		/*! < Fun Light Mode */
+} t_tcled_mode;
+
+/*!
+ * @struct t_tcled_enable_param
+ * @brief enable setting.
+ */
+typedef struct {
+	t_funlight_bank bank;	/*!< Bank */
+	t_tcled_mode mode;	/*!< Mode */
+} t_tcled_enable_param;
+
+/*!
+ * @enum t_ind_channel
+ * @brief Tri-color LED indicator mode channels.
+ *
+ */
+
+typedef enum {
+	TCLED_IND_RED = 0,	/*! < Red LED */
+	TCLED_IND_GREEN,	/*! < Green LED */
+	TCLED_IND_BLUE		/*! < Blue LED */
+} t_ind_channel;
+
+/*!
+ * @enum t_funlight_channel
+ * @brief Tri-color LED fun light mode channels.
+ *
+ */
+typedef enum {
+	TCLED_FUN_CHANNEL1 = 0,	/*! < Fun light channel 1 (Red) */
+	TCLED_FUN_CHANNEL2,	/*! < Fun light channel 2 (Green) */
+	TCLED_FUN_CHANNEL3	/*! < Fun light channel 3 (Blue) */
+} t_funlight_channel;
+
+/*!
+ * @enum t_tcled_ind_blink_pattern
+ * @brief Tri-color LED Indicator Mode blinking mode.
+ */
+typedef enum {
+	TCLED_IND_OFF = 0,	/*! < Continuous off */
+	TCLED_IND_BLINK_1,	/*! < 1 / 31 */
+	TCLED_IND_BLINK_2,	/*! < 2 / 31 */
+	TCLED_IND_BLINK_3,	/*! < 3 / 31  */
+	TCLED_IND_BLINK_4,	/*! < 4 / 31  */
+	TCLED_IND_BLINK_5,	/*! < 5 / 31  */
+	TCLED_IND_BLINK_6,	/*! < 6 / 31  */
+	TCLED_IND_BLINK_7,	/*! < 7 / 31  */
+	TCLED_IND_BLINK_8,	/*! < 8 / 31  */
+	TCLED_IND_BLINK_9,	/*! < 9 / 31  */
+	TCLED_IND_BLINK_10,	/*! < 10 / 31  */
+	TCLED_IND_BLINK_11,	/*! < 11 / 31  */
+	TCLED_IND_BLINK_12,	/*! < 12 / 31  */
+	TCLED_IND_BLINK_13,	/*! < 13 / 31  */
+	TCLED_IND_BLINK_14,	/*! < 14 / 31  */
+	TCLED_IND_BLINK_15,	/*! < 15 / 31  */
+	TCLED_IND_BLINK_16,	/*! < 16 / 31  */
+	TCLED_IND_BLINK_17,	/*! < 17 / 31  */
+	TCLED_IND_BLINK_18,	/*! < 18 / 31  */
+	TCLED_IND_BLINK_19,	/*! < 19 / 31  */
+	TCLED_IND_BLINK_20,	/*! < 20 / 31  */
+	TCLED_IND_BLINK_21,	/*! < 21 / 31  */
+	TCLED_IND_BLINK_22,	/*! < 22 / 31  */
+	TCLED_IND_BLINK_23,	/*! < 23 / 31  */
+	TCLED_IND_BLINK_24,	/*! < 24 / 31  */
+	TCLED_IND_BLINK_25,	/*! < 25 / 31  */
+	TCLED_IND_BLINK_26,	/*! < 26 / 31  */
+	TCLED_IND_BLINK_27,	/*! < 27 / 31  */
+	TCLED_IND_BLINK_28,	/*! < 28 / 31  */
+	TCLED_IND_BLINK_29,	/*! < 29 / 31  */
+	TCLED_IND_BLINK_30,	/*! < 30 / 31  */
+	TCLED_IND_ON		/*! < Continuous on */
+} t_tcled_ind_blink_pattern;
+
+/*!
+ * @enum t_tcled_cur_level
+ * @brief Tri-color LED current levels.
+ */
+typedef enum {
+	TCLED_CUR_LEVEL_1 = 0,	/*! < Tri-Color LED current level 1 */
+	TCLED_CUR_LEVEL_2,	/*! < Tri-Color LED current level 2 */
+	TCLED_CUR_LEVEL_3,	/*! < Tri-Color LED current level 3 */
+	TCLED_CUR_LEVEL_4	/*! < Tri-Color LED current level 4 */
+} t_tcled_cur_level;
+
+/*!
+ * @enum t_tcled_fun_cycle_time
+ * @brief Tri-color LED fun light mode cycle time.
+ */
+typedef enum {
+	TC_CYCLE_TIME_1 = 0,	/*! < Tri-Color LED cycle time 1 */
+	TC_CYCLE_TIME_2,	/*! < Tri-Color LED cycle time 2 */
+	TC_CYCLE_TIME_3,	/*! < Tri-Color LED cycle time 3 */
+	TC_CYCLE_TIME_4		/*! < Tri-Color LED cycle time 4 */
+} t_tcled_fun_cycle_time;
+
+/*!
+ * @enum t_tcled_fun_speed
+ * @brief Tri-color LED fun light mode pattern speed.
+ */
+typedef enum {
+	TC_OFF = 0,		/*! < Tri-Color pattern off */
+	TC_SLOW,		/*! < Tri-Color slow pattern */
+	TC_FAST			/*! < Tri-Color fast pattern */
+} t_tcled_fun_speed;
+
+/*!
+ * @enum t_tcled_fun_speed
+ * @brief Tri-color LED fun light mode pattern speed.
+ */
+typedef enum {
+	TC_STROBE_OFF = 0,	/*! < No strobe */
+	TC_STROBE_SLOW,		/*! < Slow strobe pattern */
+	TC_STROBE_FAST		/*! < fast strobe pattern */
+} t_tcled_fun_strobe_speed;
+
+/*!
+ * @enum t_chaselight_pattern
+ * @brief Tri-color LED fun light mode chasing light patterns.
+ */
+typedef enum {
+	PMIC_RGB = 0,		/*!< R -> G -> B */
+	BGR			/*!< B -> G -> R */
+} t_chaselight_pattern;
+
+/*!
+ * This enumeration of Fun Light Pattern.
+ */
+typedef enum {
+	/*!
+	 * Blended ramps slow
+	 */
+	BLENDED_RAMPS_SLOW,
+	/*!
+	 * Blended ramps fast
+	 */
+	BLENDED_RAMPS_FAST,
+	/*!
+	 * Saw ramps slow
+	 */
+	SAW_RAMPS_SLOW,
+	/*!
+	 * Saw ramps fast
+	 */
+	SAW_RAMPS_FAST,
+	/*!
+	 * Blended bowtie slow
+	 */
+	BLENDED_BOWTIE_SLOW,
+	/*!
+	 * Blended bowtie fast
+	 */
+	BLENDED_BOWTIE_FAST,
+	/*!
+	 * Strobe slow
+	 */
+	STROBE_SLOW,
+	/*!
+	 * Strobe fast
+	 */
+	STROBE_FAST,
+	/*!
+	 * Chasing Light RGB Slow
+	 */
+	CHASING_LIGHT_RGB_SLOW,
+	/*!
+	 * Chasing Light RGB fast
+	 */
+	CHASING_LIGHT_RGB_FAST,
+	/*!
+	 * Chasing Light BGR Slow
+	 */
+	CHASING_LIGHT_BGR_SLOW,
+	/*!
+	 * Chasing Light BGR fast
+	 */
+	CHASING_LIGHT_BGR_FAST,
+} t_fun_pattern;
+
+/*!
+ * @struct t_fun_param
+ * @brief LED fun pattern IOCTL parameter
+ */
+typedef struct {
+	t_funlight_bank bank;	/*!< TCLED bank */
+	t_funlight_channel channel;	/*!< TCLED channel */
+	t_fun_pattern pattern;	/*!< Fun pattern */
+} t_fun_param;
+
+/*!
+ * @enum t_led_channel
+ * @brief LED channels including backlight and tri-color LEDs.
+ */
+typedef enum {
+	AUDIO_LED1,		/*! < Backlight channel 1 */
+	AUDIO_LED2,		/*! < Backlight channel 2 */
+	AUDIO_LEDR,		/*! < Fun light channel 1 (Red) */
+	AUDIO_LEDG,		/*! < Fun light channel 2 (Green) */
+	AUDIO_LEDB		/*! < Fun light channel 3 (Blue) */
+} t_led_channel;
+
+/*!
+ * @enum t_aud_path
+ * @brief LED audio modulation in-out audio channels
+ */
+typedef enum {
+	MIXED_RX = 0,		/*!<  Mixed L & R Channel RX audio */
+	TX			/*!<  TX path */
+} t_aud_path;
+
+/*!
+ * @enum t_aud_gain
+ * @brief LED audio modulation in-out audio channels
+ */
+typedef enum {
+	GAIN_MINUS6DB = 0,	/*!< -6 dB */
+	GAIN_0DB,		/*!< 0 dB */
+	GAIN_6DB,		/*!< 6 dB */
+	GAIN_12DB		/*!< 12 dB */
+} t_aud_gain;
+
+/*!
+ * @struct t_tcled_ind_param
+ * @brief LED parameter
+ */
+typedef struct {
+	t_funlight_bank bank;	/*! < tcled bank */
+	t_ind_channel channel;	/*! < tcled channel */
+	t_tcled_cur_level level;	/*! < tcled current level */
+	t_tcled_ind_blink_pattern pattern;	/*! < tcled dutty cycle */
+	bool skip;		/*! < tcled skip */
+	bool rampup;		/*! < tcled rampup */
+	bool rampdown;		/*! < tcled rampdown */
+	bool half_current;	/*! < tcled half current */
+} t_tcled_ind_param;
+
+#if defined(CONFIG_MXC_PMIC_MC13892)
+
+enum curr_level {
+	LIT_CURR_0 = 0,
+	LIT_CURR_3,
+	LIT_CURR_6,
+	LIT_CURR_9,
+	LIT_CURR_12,
+	LIT_CURR_15,
+	LIT_CURR_18,
+	LIT_CURR_21,
+	/* below setting only used for main/aux/keypad */
+	LIT_CURR_HI_0,
+	LIT_CURR_HI_6,
+	LIT_CURR_HI_12,
+	LIT_CURR_HI_18,
+	LIT_CURR_HI_24,
+	LIT_CURR_HI_30,
+	LIT_CURR_HI_36,
+	LIT_CURR_HI_42,
+};
+
+enum lit_channel {
+	LIT_MAIN = 0,
+	LIT_AUX,
+	LIT_KEY,
+	LIT_RED,
+	LIT_GREEN,
+	LIT_BLUE,
+};
+
+#endif
+
+/* EXPORTED FUNCTIONS */
+#ifdef __KERNEL__
+/*!
+ * This function enables backlight & tcled.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_tcled_master_enable(void);
+
+/*!
+ * This function disables backlight & tcled.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful
+ */
+PMIC_STATUS pmic_bklit_tcled_master_disable(void);
+
+/*!
+ * This function enables backlight.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_master_enable(void);
+
+/*!
+ * This function disables backlight.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_master_disable(void);
+
+/*!
+ * This function sets backlight current level.
+ *
+ * @param        channel   Backlight channel
+ * @param        level     Backlight current level, as the following table.
+ *                         @verbatim
+                               level     current
+                               ------    -----------
+                                 0         0 mA
+                                 1         12 mA
+                                 2         24 mA
+                                 3         36 mA
+                                 4         48 mA
+                                 5         60 mA
+                                 6         72 mA
+                                 7         84 mA
+                            @endverbatim
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_current(t_bklit_channel channel,
+				   unsigned char level);
+
+/*!
+ * This function retrives backlight current level.
+ *
+ * @param        channel   Backlight channel
+ * @param        level     Pointer to store backlight current level result.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_current(t_bklit_channel channel,
+				   unsigned char *level);
+
+/*!
+ * This function sets a backlight channel duty cycle.
+ * LED perceived brightness for each zone may be individually set by setting
+ * duty cycle. The default setting is for 0% duty cycle; this keeps all zone
+ * drivers turned off even after the master enable command. Each LED current
+ * sink can be turned on and adjusted for brightness with an independent 4 bit
+ * word for a duty cycle ranging from 0% to 100% in approximately 6.7% steps.
+ *
+ * @param        channel   Backlight channel.
+ * @param        dc        Backlight duty cycle, as the following table.
+ *                         @verbatim
+                                dc        Duty Cycle (% On-time over Cycle Time)
+                               ------    ---------------------------------------
+                                  0        0%
+                                  1        6.7%
+                                  2        13.3%
+                                  3        20%
+                                  4        26.7%
+                                  5        33.3%
+                                  6        40%
+                                  7        46.7%
+                                  8        53.3%
+                                  9        60%
+                                 10        66.7%
+                                 11        73.3%
+                                 12        80%
+                                 13        86.7%
+                                 14        93.3%
+                                 15        100%
+                             @endverbatim
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_dutycycle(t_bklit_channel channel, unsigned char dc);
+
+/*!
+ * This function retrives a backlight channel duty cycle.
+ *
+ * @param        channel   Backlight channel.
+ * @param        cycle     Pointer to backlight duty cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_dutycycle(t_bklit_channel channel,
+				     unsigned char *dc);
+
+/*!
+ * This function sets a backlight channel cycle time.
+ * Cycle Time is defined as the period of a complete cycle of
+ * Time_on + Time_off. The default Cycle Time is set to 0.01 seconds such that
+ * the 100 Hz on-off cycling is averaged out by the eye to eliminate
+ * flickering. Additionally, the Cycle Time can be programmed to intentionally
+ * extend the period of on-off cycles for a visual pulsating or blinking effect.
+ *
+ * @param        period    Backlight cycle time, as the following table.
+ *                         @verbatim
+                                period      Cycle Time
+                               --------    ------------
+                                  0          0.01 seconds
+                                  1          0.1 seconds
+                                  2          0.5 seconds
+                                  3          2 seconds
+                             @endverbatim
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_cycle_time(unsigned char period);
+
+/*!
+ * This function retrives a backlight channel cycle time setting.
+ *
+ * @param        period    Pointer to save backlight cycle time setting result.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_cycle_time(unsigned char *period);
+
+/*!
+ * This function sets backlight operation mode. There are two modes of
+ * operations: current control and triode mode.
+ * The Duty Cycle/Cycle Time control is retained in Triode Mode. Audio
+ * coupling is not available in Triode Mode.
+ *
+ * @param        channel   Backlight channel.
+ * @param        mode      Backlight operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_mode(t_bklit_channel channel, t_bklit_mode mode);
+/*!
+ * This function gets backlight operation mode. There are two modes of
+ * operations: current control and triode mode.
+ * The Duty Cycle/Cycle Time control is retained in Triode Mode. Audio
+ * coupling is not available in Triode Mode.
+ *
+ * @param        channel   Backlight channel.
+ * @param        mode      Backlight operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_mode(t_bklit_channel channel, t_bklit_mode * mode);
+/*!
+ * This function starts backlight brightness ramp up function; ramp time is
+ * fixed at 0.5 seconds.
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_rampup(t_bklit_channel channel);
+/*!
+ * This function stops backlight brightness ramp up function;
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_off_rampup(t_bklit_channel channel);
+/*!
+ * This function starts backlight brightness ramp down function; ramp time is
+ * fixed at 0.5 seconds.
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_rampdown(t_bklit_channel channel);
+/*!
+ * This function stops backlight brightness ramp down function.
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_off_rampdown(t_bklit_channel channel);
+/*!
+ * This function enables backlight analog edge slowing mode. Analog Edge
+ * Slowing slows down the transient edges to reduce the chance of coupling LED
+ * modulation activity into other circuits. Rise and fall times will be targeted
+ * for approximately 50usec.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_enable_edge_slow(void);
+
+/*!
+ * This function disables backlight analog edge slowing mode. The backlight
+ * drivers will default to an Instant On mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_disable_edge_slow(void);
+/*!
+ * This function gets backlight analog edge slowing mode. DThe backlight
+ *
+ * @param        edge      Edge slowing mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_edge_slow(bool * edge);
+/*!
+ * This function sets backlight Strobe Light Pulsing mode.
+ *
+ * @param        channel   Backlight channel.
+ * @param        mode      Strobe Light Pulsing mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_strobemode(t_bklit_channel channel,
+				      t_bklit_strobe_mode mode);
+
+/*!
+ * This function enables tri-color LED.
+ *
+ * @param        mode      Tri-color LED operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_enable(t_tcled_mode mode, t_funlight_bank bank);
+/*!
+ * This function disables tri-color LED.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_disable(t_funlight_bank bank);
+/*!
+ * This function retrives tri-color LED operation mode.
+ *
+ * @param        mode      Pointer to Tri-color LED operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_get_mode(t_tcled_mode * mode, t_funlight_bank bank);
+/*!
+ * This function sets a tri-color LED channel current level in indicator mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Current level.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_ind_set_current(t_ind_channel channel,
+				       t_tcled_cur_level level,
+				       t_funlight_bank bank);
+/*!
+ * This function retrives a tri-color LED channel current level in indicator mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Pointer to current level.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_ind_get_current(t_ind_channel channel,
+				       t_tcled_cur_level * level,
+				       t_funlight_bank bank);
+/*!
+ * This function sets a tri-color LED channel blinking pattern in indication
+ * mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        pattern      Blinking pattern.
+ * @param        skip         If true, skip a cycle after each cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_tcled_ind_set_blink_pattern(t_ind_channel channel,
+					     t_tcled_ind_blink_pattern pattern,
+					     bool skip, t_funlight_bank bank);
+/*!
+ * This function retrives a tri-color LED channel blinking pattern in
+ * indication mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        pattern      Pointer to Blinking pattern.
+ * @param        skip         Pointer to a boolean variable indicating if skip
+ *                            a cycle after each cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_ind_get_blink_pattern(t_ind_channel channel,
+					     t_tcled_ind_blink_pattern *
+					     pattern, bool * skip,
+					     t_funlight_bank bank);
+/*!
+ * This function sets a tri-color LED channel current level in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Current level.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_set_current(t_funlight_bank bank,
+				       t_funlight_channel channel,
+				       t_tcled_cur_level level);
+
+/*!
+ * This function retrives a tri-color LED channel current level
+ * in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Pointer to current level.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_get_current(t_funlight_bank bank,
+				       t_funlight_channel channel,
+				       t_tcled_cur_level * level);
+
+/*!
+ * This function sets tri-color LED cycle time in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        ct           Cycle time.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_set_cycletime(t_funlight_bank bank,
+					 t_tcled_fun_cycle_time ct);
+
+/*!
+ * This function retrives tri-color LED cycle time in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        ct           Pointer to cycle time.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_get_cycletime(t_funlight_bank bank,
+					 t_tcled_fun_cycle_time * ct);
+
+/*!
+ * This function sets a tri-color LED channel duty cycle in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        dc           Duty cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_set_dutycycle(t_funlight_bank bank,
+					 t_funlight_channel channel,
+					 unsigned char dc);
+
+/*!
+ * This function retrives a tri-color LED channel duty cycle in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        dc           Pointer to duty cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_get_dutycycle(t_funlight_bank bank,
+					 t_funlight_channel channel,
+					 unsigned char *dc);
+
+/*!
+ * This function initiates Blended Ramp fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_blendedramps(t_funlight_bank bank,
+					t_tcled_fun_speed speed);
+
+/*!
+ * This function initiates Saw Ramp fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_sawramps(t_funlight_bank bank,
+				    t_tcled_fun_speed speed);
+
+/*!
+ * This function initiates Blended Bowtie fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_blendedbowtie(t_funlight_bank bank,
+					 t_tcled_fun_speed speed);
+
+/*!
+ * This function initiates Chasing Lights fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        pattern      Chasing light pattern mode.
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_chasinglightspattern(t_funlight_bank bank,
+						t_chaselight_pattern pattern,
+						t_tcled_fun_speed speed);
+
+/*!
+ * This function initiates Strobe Mode fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_strobe(t_funlight_bank bank,
+				  t_funlight_channel channel,
+				  t_tcled_fun_strobe_speed speed);
+
+/*!
+ * This function initiates Tri-color LED brightness Ramp Up function; Ramp time
+ * is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampup       Ramp-up configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_rampup(t_funlight_bank bank,
+				  t_funlight_channel channel, bool rampup);
+/*!
+ * This function gets Tri-color LED brightness Ramp Up function; Ramp time
+ * is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampup       Ramp-up configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_get_fun_rampup(t_funlight_bank bank,
+				      t_funlight_channel channel,
+				      bool * rampup);
+
+/*!
+ * This function initiates Tri-color LED brightness Ramp Down function; Ramp
+ * time is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampdown     Ramp-down configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_rampdown(t_funlight_bank bank,
+				    t_funlight_channel channel, bool rampdown);
+/*!
+ * This function initiates Tri-color LED brightness Ramp Down function; Ramp
+ * time is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampdown     Ramp-down configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_get_fun_rampdown(t_funlight_bank bank,
+					t_funlight_channel channel,
+					bool * rampdown);
+
+/*!
+ * This function enables a Tri-color channel triode mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_triode_on(t_funlight_bank bank,
+				     t_funlight_channel channel);
+
+/*!
+ * This function disables a Tri-color LED channel triode mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_triode_off(t_funlight_bank bank,
+				      t_funlight_channel channel);
+
+/*!
+ * This function enables Tri-color LED edge slowing.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_enable_edge_slow(void);
+
+/*!
+ * This function disables Tri-color LED edge slowing.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_disable_edge_slow(void);
+
+/*!
+ * This function enables Tri-color LED half current mode.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_enable_half_current(void);
+
+/*!
+ * This function disables Tri-color LED half current mode.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_disable_half_current(void);
+
+/*!
+ * This function enables backlight or Tri-color LED audio modulation.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_enable_audio_modulation(t_led_channel channel,
+					       t_aud_path path,
+					       t_aud_gain gain,
+					       bool lpf_bypass);
+
+/*!
+ * This function disables backlight or Tri-color LED audio modulation.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_disable_audio_modulation(void);
+/*!
+ * This function enables the boost mode.
+ * Only on mc13783 2.0 or higher
+ *
+ * @param       en_dis   Enable or disable the boost mode
+ *
+ * @return      This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_set_boost_mode(bool en_dis);
+
+/*!
+ * This function gets the boost mode.
+ * Only on mc13783 2.0 or higher
+ *
+ * @param       en_dis   Enable or disable the boost mode
+ *
+ * @return      This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_get_boost_mode(bool * en_dis);
+
+/*!
+ * This function sets boost mode configuration
+ * Only on mc13783 2.0 or higher
+ *
+ * @param    abms      Define adaptive boost mode selection
+ * @param    abr       Define adaptive boost reference
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_config_boost_mode(unsigned int abms, unsigned int abr);
+
+/*!
+ * This function gets boost mode configuration
+ * Only on mc13783 2.0 or higher
+ *
+ * @param    abms      Define adaptive boost mode selection
+ * @param    abr       Define adaptive boost reference
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_gets_boost_mode(unsigned int *abms, unsigned int *abr);
+
+#if defined(CONFIG_MXC_PMIC_MC13892)
+
+PMIC_STATUS mc13892_bklit_set_current(enum lit_channel channel,
+				      unsigned char level);
+PMIC_STATUS mc13892_bklit_get_current(enum lit_channel channel,
+				      unsigned char *level);
+PMIC_STATUS mc13892_bklit_set_dutycycle(enum lit_channel channel,
+					unsigned char dc);
+PMIC_STATUS mc13892_bklit_get_dutycycle(enum lit_channel channel,
+					unsigned char *dc);
+PMIC_STATUS mc13892_bklit_set_ramp(enum lit_channel channel, int flag);
+PMIC_STATUS mc13892_bklit_get_ramp(enum lit_channel channel, int *flag);
+PMIC_STATUS mc13892_bklit_set_blink_p(enum lit_channel channel, int period);
+PMIC_STATUS mc13892_bklit_get_blink_p(enum lit_channel channel, int *period);
+
+#endif
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_PMIC_LIGHT_H__ */
diff --git a/include/linux/pmic_rtc.h b/include/linux/pmic_rtc.h
new file mode 100644
index 0000000..2f7aeda
--- /dev/null
+++ b/include/linux/pmic_rtc.h
@@ -0,0 +1,153 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_PMIC_RTC_H__
+#define __ASM_ARCH_MXC_PMIC_RTC_H__
+
+/*!
+ * @defgroup PMIC_RTC PMIC RTC Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file arch-mxc/pmic_rtc.h
+ * @brief This is the header of PMIC RTC driver.
+ *
+ * @ingroup PMIC_RTC
+ */
+
+/*
+ * Includes
+ */
+#include <linux/ioctl.h>
+#include <linux/pmic_status.h>
+#include <linux/pmic_external.h>
+
+#define         PMIC_RTC_SET_TIME                    _IOWR('p',0xd1, int)
+#define         PMIC_RTC_GET_TIME                    _IOWR('p',0xd2, int)
+#define         PMIC_RTC_SET_ALARM		     _IOWR('p',0xd3, int)
+#define         PMIC_RTC_GET_ALARM		     _IOWR('p',0xd4, int)
+#define         PMIC_RTC_WAIT_ALARM		     _IOWR('p',0xd5, int)
+#define         PMIC_RTC_ALARM_REGISTER              _IOWR('p',0xd6, int)
+#define         PMIC_RTC_ALARM_UNREGISTER            _IOWR('p',0xd7, int)
+
+/*!
+ * This enumeration define all RTC interrupt
+ */
+typedef enum {
+	/*!
+	 * Time of day alarm
+	 */
+	RTC_IT_ALARM,
+	/*!
+	 * 1 Hz timetick
+	 */
+	RTC_IT_1HZ,
+	/*!
+	 * RTC reset occurred
+	 */
+	RTC_IT_RST,
+} t_rtc_int;
+
+/*
+ * RTC PMIC API
+ */
+
+/* EXPORTED FUNCTIONS */
+#ifdef __KERNEL__
+
+/*!
+ * This function set the real time clock of PMIC
+ *
+ * @param        pmic_time  	value of date and time
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_set_time(struct timeval *pmic_time);
+
+/*!
+ * This function get the real time clock of PMIC
+ *
+ * @param        pmic_time  	return value of date and time
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_get_time(struct timeval *pmic_time);
+
+/*!
+ * This function set the real time clock alarm of PMIC
+ *
+ * @param        pmic_time  	value of date and time
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_set_time_alarm(struct timeval *pmic_time);
+
+/*!
+ * This function get the real time clock alarm of PMIC
+ *
+ * @param        pmic_time  	return value of date and time
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_get_time_alarm(struct timeval *pmic_time);
+
+/*!
+ * This function wait the Alarm event
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_wait_alarm(void);
+
+/*!
+ * This function is used to un/subscribe on RTC event IT.
+ *
+ * @param        event  	type of event.
+ * @param        callback  	event callback function.
+ * @param        sub      	define if Un/subscribe event.
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_event(t_rtc_int event, void *callback, bool sub);
+
+/*!
+ * This function is used to subscribe on RTC event IT.
+ *
+ * @param        event  	type of event.
+ * @param        callback  	event callback function.
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_event_sub(t_rtc_int event, void *callback);
+
+/*!
+ * This function is used to un-subscribe on RTC event IT.
+ *
+ * @param        event  	type of event.
+ * @param        callback  	event callback function.
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_event_unsub(t_rtc_int event, void *callback);
+
+/*!
+ * This function is used to tell if PMIC RTC has been correctly loaded.
+ *
+ * @return       This function returns 1 if RTC was successfully loaded
+ * 		 0 otherwise.
+ */
+int pmic_rtc_loaded(void);
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_PMIC_RTC_H__ */
diff --git a/include/linux/pmic_status.h b/include/linux/pmic_status.h
new file mode 100644
index 0000000..19410fa
--- /dev/null
+++ b/include/linux/pmic_status.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_STATUS_H__
+#define __ASM_ARCH_MXC_PMIC_STATUS_H__
+#include <asm-generic/errno-base.h>
+#ifdef __KERNEL__
+#include <asm/uaccess.h>	/* copy_{from,to}_user() */
+#endif
+/*!
+ * @file arch-mxc/pmic_status.h
+ * @brief PMIC APIs return code definition.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+/*!
+ * @enum PMIC_STATUS
+ * @brief Define return values for all PMIC APIs.
+ *
+ * These return values are used by all of the PMIC APIs.
+ *
+ * @ingroup PMIC
+ */
+typedef enum {
+	PMIC_SUCCESS = 0,	/*!< The requested operation was successfully
+				   completed.                                     */
+	PMIC_ERROR = -1,	/*!< The requested operation could not be completed
+				   due to an error.                               */
+	PMIC_PARAMETER_ERROR = -2,	/*!< The requested operation failed because
+					   one or more of the parameters was
+					   invalid.                             */
+	PMIC_NOT_SUPPORTED = -3,	/*!< The requested operation could not be
+					   completed because the PMIC hardware
+					   does not support it. */
+	PMIC_SYSTEM_ERROR_EINTR = -EINTR,
+
+	PMIC_MALLOC_ERROR = -5,	/*!< Error in malloc function             */
+	PMIC_UNSUBSCRIBE_ERROR = -6,	/*!< Error in un-subscribe event          */
+	PMIC_EVENT_NOT_SUBSCRIBED = -7,	/*!< Event occur and not subscribed       */
+	PMIC_EVENT_CALL_BACK = -8,	/*!< Error - bad call back                */
+	PMIC_CLIENT_NBOVERFLOW = -9,	/*!< The requested operation could not be
+					   completed because there are too many
+					   PMIC client requests */
+} PMIC_STATUS;
+
+/*
+ * Bitfield macros that use rely on bitfield width/shift information.
+ */
+#define BITFMASK(field) (((1U << (field ## _WID)) - 1) << (field ## _LSH))
+#define BITFVAL(field, val) ((val) << (field ## _LSH))
+#define BITFEXT(var, bit) ((var & BITFMASK(bit)) >> (bit ## _LSH))
+
+/*
+ * Macros implementing error handling
+ */
+#define CHECK_ERROR(a)			\
+do {					\
+		int ret = (a); 			\
+		if (ret != PMIC_SUCCESS)	\
+	return ret; 			\
+} while (0)
+
+#define CHECK_ERROR_KFREE(func, freeptrs) \
+do { \
+	int ret = (func); \
+	if (ret != PMIC_SUCCESS) { \
+		freeptrs;	\
+		return ret;	\
+	}	\
+} while (0);
+
+#endif				/* __ASM_ARCH_MXC_PMIC_STATUS_H__ */
diff --git a/sound/arm/mxc-alsa-pmic.c b/sound/arm/mxc-alsa-pmic.c
index a23ae0c..6ac7fd9 100644
--- a/sound/arm/mxc-alsa-pmic.c
+++ b/sound/arm/mxc-alsa-pmic.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -44,28 +44,25 @@
 #include <linux/slab.h>
 #include <linux/dma-mapping.h>
 #include <linux/soundcard.h>
-
-#ifdef CONFIG_PM
+#include <linux/pmic_external.h>
 #include <linux/pm.h>
-#endif				/* CONFIG_PM */
+#include <linux/fs.h>
+#include <linux/clk.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/control.h>
 
+#include <asm/arch/pmic_audio.h>
 #include <asm/arch/dma.h>
 #include <asm/mach-types.h>
 
 #include <ssi/ssi.h>
 #include <ssi/registers.h>
 #include <dam/dam.h>
-#include <asm/arch/pmic_external.h>
-#include <asm/arch/pmic_audio.h>
 
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/initval.h>
-#include <sound/control.h>
 #include "mxc-alsa-pmic.h"
 #include "mxc-alsa-common.h"
-#include <linux/fs.h>
-#include <linux/clk.h>
 
 /*
  * PMIC driver buffer policy.
diff --git a/sound/soc/imx/imx-3stack-bt.c b/sound/soc/imx/imx-3stack-bt.c
index c86af54..de5873e 100644
--- a/sound/soc/imx/imx-3stack-bt.c
+++ b/sound/soc/imx/imx-3stack-bt.c
@@ -19,6 +19,8 @@
 #include <linux/i2c.h>
 #include <linux/clk.h>
 #include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/pmic_external.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/soc.h>
@@ -26,9 +28,6 @@
 #include <sound/initval.h>
 
 #include <asm/hardware.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/mxc.h>
-#include <asm/arch/pmic_external.h>
 
 #include "imx-pcm.h"
 #include "imx-ssi.h"
-- 
1.5.4.4

